import ast
import ctypes
import datetime
import math
import gc
from itertools import chain
import hid
import psutil
import mplcursors
from PIL import Image
from PyQt5 import QtCore, QtWidgets, QtGui
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QMessageBox, QDialog, QTableWidget, QTableWidgetItem
import cv2
import io
import os
import openpyxl
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import QTimer
from PyQt5.QtCore import *
from PyQt5.QtCore import QObject
import sys
import time
import serial
import pandas as pd
import numpy as np
import csv
from openpyxl.styles import Font, Alignment, Border, Side
from openpyxl.utils import get_column_letter
import dialogs
import DB_Connector
import lens_offset
from GUI import UiMainWindow
from logger import logger
import matplotlib.pyplot as plt
import ui_to_plc
import threading
from lens_offset import LensOffset
import clr
import mtf
import excel
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.image import imread

var = clr.AddReference(r"{}\dlls\MANTRA_MFS100.dll".format(os.path.abspath(".")))
from MANTRA import MFS100, FingerData


class Glue_purge_dialog(QDialog):
    def __init__(self):
        super().__init__()

        self.resize(500, 350)
        self.setWindowFlags(Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)

    def paintEvent(self, event):
        """ Override paint event to create a curved dialog """
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        rect = self.rect()
        painter.setBrush(QColor("#8ab0ab"))
        painter.setPen(Qt.NoPen)
        painter.drawRoundedRect(rect, 15, 15)


class Main(QtWidgets.QMainWindow, UiMainWindow):
    """
    This is main the class.
    It is used to setup the UI and its functionality.
    """

    def __init__(self, screen_resolutions, parent=None):
        self.abort_auto_sequence_clicked = False
        self.diagnostic_current_value = None
        self.glue_teach_btn_dclose_clicked = False
        self.resolution_index = None
        self.value_to_move = None
        self.res = None
        self.sender_create = None
        try:
            super(Main, self).__init__(parent=parent)
            self.relay_width_value = None
            self.recipe_path = None
            self.mycursor = None
            self.relay_height_value = None
            self.recipe_btn_type = None
            self.roi = None
            self.relay_angle_value = None
            self.relay_radius_value = None
            self.collimator_radius_value = None
            self.collimator_height_value = None
            self.collimator_width_value = None
            self.collimator_angle_value = None
            self.teaching_glue_clicked = False
            self.close_fingerprint_thread = False
            self.c_mtf_threshold = 0.05
            self.tl_mtf_threshold = 0.05
            self.tr_mtf_threshold = 0.05
            self.bl_mtf_threshold = 0.05
            self.br_mtf_threshold = 0.05
            self.path = None
            self.data = None
            self.app_opened_now = True
            self.action_1 = None
            self.mod_serial = None
            self.base_serial = None
            self.start_button_clicked = None
            self.excel_date = None
            self.camera_connected = None
            self.product_name = None
            self.camera_name = None
            self.centre = None
            self.excel = None
            self.resolution = None
            self.expo = None
            self.is_config_loaded = False
            self.plt_graph = plt
            self.refresh_btn_clicked = False
            self.dialog = QDialog()
            self.window_width = 0
            self.window_height = 0
            self.screen_resolution = screen_resolutions
            self.collimator_clicked = False
            self.relay_clicked = False
            self.update = False
            self.fingerprint_create_flag = False
            self.abort_clicked = False
            self.collimator_simulate_clicked = False
            self.relay_simulate_clicked = False
            self.loading_saved = False
            self.relay_saved = False
            self.curing_saved = False
            self.collimator_saved = False
            self.height_sensor_saved = False
            self.gluing_saved = False
            self.ready_port = False
            self.change_resolution = False
            self.change_format_type = False
            self.fingerprint_list = None
            self.excel_path = None
            self.after_glue_clicked = False
            self.after_curing_clicked = False
            self.init_clicked = False
            self.i_o_refresh_btn = False
            self.port_refresh_btn = False
            self.glue_offset_write = True
            self.format_type = None
            self.frame_saved = None
            self.optimal_height = None
            self.rois = {}
            self.optimal_width = None
            self.resolution = None
            self.identify_btn = None
            self.user_call_init_yes = False
            self.wait_user_response = False
            self.error_msg_response = False
            self.ok_pressed = False
            self.user_call_init_no = False
            self.is_all_homing = False
            self.timer = False
            self.diagnostics_clicked = False
            self.step_run_btn_clicked = False
            self.first_step_run_clicked = False
            self.first_start_btn_clicked = False
            self.focus_station_y_value = None
            self.focus_station_x_value = None
            self.collimator_tr_intensity = None
            self.collimator_br_intensity = None
            self.collimator_bl_intensity = None
            self.collimator_tl_intensity = None
            self.collimator_c_intensity = None
            self.collimator_list_items = None
            self.collimator_light_type = None

            self.push_button_timer = QTimer()
            self.init_timer = QTimer()

            self.setup_type = "Collimator station"
            self.monochrome = "No"
            self.isp_tuning = "Yes"
            self.validation_clicked = False
            self.get_result_clicked = False
            self.machine_movement_clicked = False
            self.chart_check_clicked = False
            self.hic = False
            self.relay_chart_check_clicked = None
            self.collimator_chart_check_clicked = None
            self.collimator_validation = False
            self.relay_validation = False
            self.relay_offset_clicked = False
            self.collimator_offset_clicked = False
            self.camera_connect = False
            self.fingerprint_login = False
            self.machine_flow = dialogs.Machine_control_Window()
            self.db_connection_class = DB_Connector.DBConnector()
            self.lens_offset_class = lens_offset.LensOffset()
            self.bypass_option = {"Right door": False, "Left door": False, "Front door open": False,
                                  "Front door close": False, "Product presence": False, "Gd left open": False,
                                  "Gd left close": False, "Gd right open": False, "Gd right close": False,
                                  "Gluing motor alarm": False, "UV door cylinder open": False,
                                  "UV door cylinder close": False}
            self.y_act_current_value = 0.0
            self.x_act_current_value = 0.0
            self.relay_z_act_current_value = 0.0
            self.gluing_z_act_current_value = 0.0
            self.gluing_x1_act_current_value = 0.0
            self.gluing_x2_act_current_value = 0.0
            self.gluing_y_act_current_value = 0.0
            self.curing_z_act_current_value = 0.0
            self.gripper_act_current_value = 0.0
            self.slider_act_current_value = 0.0
            self.uv_door_act_open = False
            self.part_loading_act_in = True
            self.stop_duplicate_window()

            while self.window_height == 0 and self.window_width == 0:
                self.login_setupUi(self)

            self.login_btn.clicked.connect(self.evt_login_btn)
            self.emp_id_txtbox.returnPressed.connect(self.animate_password_box)
            self.move_login_btn.clicked.connect(self.animate_password_box)
            self.pwd_txtbox.returnPressed.connect(self.evt_login_btn)
            self.emp_id_txtbox.textChanged.connect(self.on_emp_changed_for_login)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at init function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def evt_login_btn(self):
        try:
            """
            This method is used to pass the user role.
            param lists: None
            return: None
            """
            logger.info("login button clicked")
            if self.emp_id_txtbox.text() == "":
                self.msg_box_call("Empty emp id", "Please enter your EMP ID", "Critical")
            elif self.pwd_txtbox.text() == "":
                self.msg_box_call("Critical", "Please enter your Password", "Critical")
            else:
                if self.pwd == self.pwd_txtbox.text():
                    self.evt_btn_mode(texts=self.user_text)
                else:
                    self.msg_box_call("Critical", "Password doesn't match with your profile", "Critical")
                    self.pwd_txtbox.clear()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at evt_login_btn function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def evt_btn_mode(self, texts):
        try:
            """
            This method is used to set the UI based on user's role.
            param lists: texts as user's role and datatype is str.
            return: None
            """
            if texts == "ADMIN" or texts == "OPERATOR" or texts == "SUPERVISOR" or texts == "Auto Mode":
                logger.info('Auto mode page shows')
                self.window_width = 0
                self.window_height = 0
                while self.window_height == 0 and self.window_width == 0:
                    self.setupUi(self)

                self.user_name_lbl.setText("User Name : {}".format(self.user_name))
                logger.info(f"User Name: {self.user_name} login time: {datetime.datetime.now().strftime('%H:%M:%S')}")
                if texts == "OPERATOR":
                    self.select_recipe_btn.show()
                    self.init_btn.show()
                    self.btn_start.show()
                    self.step_run_btn.hide()
                    self.machine_cntrl_btn.hide()
                    self.user_setting.hide()
                    self.progress_bar.setGeometry(QtCore.QRect(30, (self.window_height - 130), 260, 30))
                    if not self.ready_port:
                        time.sleep(1)
                        ui.port_refresh_btn = True
                        self.connect_ports_thread()
                        self.machine_flow.port_btn_refresh.clicked.connect(self.connect_ports_thread)
                        self.machine_flow.port_btn_dclose.clicked.connect(self.close_dialog)
                        self.machine_flow.port_dialog.exec()

                    if not self.ready_port:
                        self.statusbar.setText("Ports not connected")
                    elif not self.is_all_homing:
                        self.statusbar.setText("Machine state is not in homing")
                    elif not self.is_config_loaded:
                        self.statusbar.setText("Config file is not loaded")
                    else:
                        self.load_config(path=self.recipe_path)
                        config_name = str(os.path.basename(self.recipe_path)).split(".")
                        self.config_name_lbl.setText("Config Name: {}".format(config_name[0]))
                        self.mod_serial_lnedt.setReadOnly(False)
                        self.base_serial_lnedt.setReadOnly(False)
                        self.product_serial_lnedt.setReadOnly(False)
                        if self.is_config_loaded and self.ready_port and not self.push_button_timer.isActive() and \
                                self.is_all_homing:
                            self.push_button_timer.start()
                    self.logout_btn.setEnabled(True)

                elif texts == "SUPERVISOR":
                    self.diagnostics.setVisible(False)
                    self.bypass.setVisible(False)
                    self.user_setting.hide()
                    if not self.ready_port:
                        time.sleep(2)
                        ui.port_refresh_btn = True
                        self.connect_ports_thread()
                        self.machine_flow.port_btn_refresh.clicked.connect(self.connect_ports_thread)
                        self.machine_flow.port_btn_dclose.clicked.connect(self.close_dialog)
                        self.machine_flow.port_dialog.exec()

                elif texts == "ADMIN":
                    self.btn_start.show()
                    self.step_run_btn.show()
                    self.machine_cntrl_btn.show()
                    self.user_setting.show()
                    self.select_recipe_btn.show()
                    self.init_btn.show()
                    self.line.show()
                    self.diagnostics.setVisible(True)
                    self.bypass.setVisible(True)
                    if not self.ready_port:
                        time.sleep(1)
                        ui.port_refresh_btn = True
                        self.connect_ports_thread()
                        self.machine_flow.port_btn_refresh.clicked.connect(self.connect_ports_thread)
                        self.machine_flow.port_btn_dclose.clicked.connect(self.close_dialog)
                        self.machine_flow.port_dialog.exec()

                self.logout_btn.clicked.connect(self.log_out)
                self.init_btn.clicked.connect(self.homing_all)
                self.glue_teach_btn.clicked.connect(self.teaching_gluing_station)
                self.select_recipe_btn.clicked.connect(self.recipe_select)
                self.main_page_abort_btn.clicked.connect(self.abort_auto_sequence)
                self.machine_cntrl_btn.machine_menu.triggered.connect(self.machine_control_btn)
                self.user_setting.machine_menu.triggered.connect(self.user_recipe_settings)
                self.btn_start.clicked.connect(self.start_button_pressed)
                self.step_run_btn.clicked.connect(self.step_run_pressed)
                self.mod_serial_lnedt.textChanged.connect(self.set_focus_change)
                self.base_serial_lnedt.textChanged.connect(self.set_focus_change)
                self.product_serial_lnedt.textChanged.connect(self.set_focus_change)
                self.tableWidget.show()
                self.user_name_lbl.show()
                self.progress_bar.show()
                self.No_preview_found("No")
            else:
                self.statusbar.setText("Actuators and PLC is not in homing state")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at evt_btn_mode function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def mousePressEvent(self, event):
        """
        This method is used to get the mouse click position on UI.
        param lists: event.
        return: None
        """
        if event.button() == Qt.LeftButton:
            logger.info("Left mouse button clicked at ({}, {})".format(event.x(), event.y()))

        elif event.button() == Qt.RightButton:
            logger.info("Right mouse button clicked at ({}, {})".format(event.x(), event.y()))

    def step_run_pressed(self):
        """
        This method is used to start the step run sequence.
        param lists: None.
        return: None
        """
        if not self.first_step_run_clicked:
            if not self.ready_port:
                self.statusbar.setText("Port connection is not done")
                return
            elif not self.is_all_homing:
                self.statusbar.setText("Homing is not done")
                return
            elif not self.is_config_loaded:
                self.statusbar.setText("Config file is not loaded")
                return
            else:
                return_value = self.start_btn_streaming()
                if return_value:
                    self.start_button_clicked = False
                    self.push_button_timer.stop()
                    self.progress_bar.setValue(0)
                    self.select_recipe_btn.setEnabled(False)
                    self.btn_start.setEnabled(False)
                    self.step_run_btn.setEnabled(False)
                    self.machine_cntrl_btn.setEnabled(False)
                    self.user_setting.setEnabled(False)
                    self.glue_teach_btn.setEnabled(False)
                    self.main_page_abort_btn.setEnabled(True)
                    self.init_btn.setEnabled(False)
                    self.logout_btn.setEnabled(False)
                    self.mod_serial_lnedt.setReadOnly(True)
                    self.base_serial_lnedt.setReadOnly(True)
                    self.product_serial_lnedt.setReadOnly(True)
                    item = QtWidgets.QTableWidgetItem(str("In progress"))
                    item.setTextAlignment(Qt.AlignCenter)
                    item.setForeground(QColor(245, 100, 20))
                    self.tableWidget.setItem(3, 1, item)
                    self.first_step_run_clicked = True
                    self.abort_auto_sequence_clicked = False
                    self.run_thread()

            mouse_pos = self.mapFromGlobal(self.cursor().pos())
            logger.info("Step run button  clicked {}".format(mouse_pos.x()))

        self.step_run_btn_clicked = True

    def start_button_pressed(self):
        try:
            """
            This method is used to start the auto sequence.
            param lists: None.
            return: None
            """
            if not self.ready_port:
                self.statusbar.setText("Port connection is not done")
                return
            elif not self.is_all_homing:
                self.statusbar.setText("Homing is not done")
                return
            elif not self.is_config_loaded:
                self.statusbar.setText("Config file is not loaded")
                return
            else:
                self.start_button_clicked = True
                self.abort_auto_sequence_clicked = False

            mouse_pos = self.mapFromGlobal(self.cursor().pos())
            logger.info("Start button  clicked {}".format(mouse_pos.x()))

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at start button pressed function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def start_btn_streaming(self):
        try:
            """
            This method is used to verify the config details.
            param lists: None.
            return: Bool
            """
            if self.is_config_loaded and not self.timer and self.is_all_homing:
                self.statusbar.setText("")
                if str(self.excel["Module Serial No."]["Product details"]) not in self.mod_serial_lnedt.text() and \
                        not pd.isna(self.excel["Module Serial No."]["Product details"]):
                    if self.mod_serial_lnedt.text() == "":
                        self.msg_box_call("Alert", "Mod-board serial should not be empty", "Critical")
                    else:
                        self.msg_box_call("Alert", "Mod-board serial doesn't match with config file", "Critical")
                    self.mod_serial_lnedt.clear()
                    return False

                elif str(self.excel["Base Serial No."]["Product details"]) not in self.base_serial_lnedt.text() and \
                        not pd.isna(self.excel["Base Serial No."]["Product details"]):
                    if self.base_serial_lnedt.text() == "":
                        self.msg_box_call("Alert", "Baseboard serial should not be empty", "Critical")
                    else:
                        self.msg_box_call("Alert", "Baseboard serial doesn't match with config file", "Critical")
                    self.base_serial_lnedt.clear()
                    return False

                elif (str(self.excel["Product Serial No."]["Product details"])
                      not in self.product_serial_lnedt.text()
                      and not pd.isna(self.excel["Product Serial No."]["Product details"])):
                    if self.product_serial_lnedt.text() == "":
                        self.msg_box_call("Alert", "Product serial should not be empty", "Critical")
                    else:
                        self.msg_box_call("Alert", "Product serial doesn't match with config file", "Critical")
                    self.product_serial_lnedt.clear()
                    return False

                consider_focus_chart = self.mtf_excel["Consider one region"].upper()
                remove_space = consider_focus_chart.replace(" ", "")
                split_text = remove_space.split(",")
                self.consider_focus_chart = split_text[1]
                if split_text[0].upper() == "FALSE":
                    self.consider_focus_chart_flag = False
                elif split_text[0].upper() == "TRUE":
                    self.consider_focus_chart_flag = True
                else:
                    self.consider_focus_chart_flag = False

                if self.consider_focus_chart not in ["C", "TL", "TR", "BL", "BR"]:
                    self.msg_box_call("Alert", "Consider focus is wrong", "Critical")
                    return False

                if bool(self.excel["Gluing Status"]["Gluing station"]):
                    if self.excel["Gluing x1"]["Gluing station"] == "" or str(
                            self.excel["Gluing x1"]["Gluing station"]).isalpha():
                        self.msg_box_call("Alert", "Gluing x1 offset value is incorrect", "Critical")
                        return False

                    elif self.excel["Gluing x2"]["Gluing station"] == "" or str(
                            self.excel["Gluing x2"]["Gluing station"]).isalpha():
                        self.msg_box_call("Alert", "Gluing x2 offset value is incorrect", "Critical")
                        return False

                if self.consider_focus_chart_flag and \
                        bool(self.mtf_excel["Consider all region"]):  # Another config
                    logger.error("Consider one region flag and consider all region both are true")
                    self.msg_box_call("Alert", "Unable to proceed the rotation, Kindly check the recipe file.",
                                      "Critical")
                    return False

                elif not self.consider_focus_chart_flag and \
                        not bool(self.mtf_excel["Consider all region"]):  # Another config
                    logger.error("Consider one region flag and consider all region both are false")
                    self.msg_box_call("Alert", "Unable to proceed the rotation, Kindly check the recipe file.",
                                      "Critical")
                    return False

                else:
                    try:
                        dataframe = openpyxl.load_workbook(r".\media\machine control bypass file.xlsx")
                        dataframe1 = dataframe.worksheets[1]
                        for x, y in enumerate(self.bypass_option.items(), start=2):
                            self.bypass_option[y[0]] = dataframe1.cell(row=x, column=2).value

                    except FileNotFoundError:
                        logger.error("Machine control excel file is not found.")
                        self.statusbar.setText("Machine control excel file is not found.")
                        return False

                    except Exception as e:
                        logger.error("Machine control excel file is wrong.")
                        self.statusbar.setText("Machine control excel file is wrong.")
                        return False

                    self.folder_path = self.create_folder_structure(self.product_name)
                    if self.folder_path != "":
                        new_path = os.path.join(os.path.dirname(self.folder_path), "Intermediate")
                        self.intermediate_excel_path = "{}\\{}".format(new_path, "MTF_Validation_Report.xlsx")

                        new_path = os.path.join(os.path.dirname(self.folder_path), "Passed")
                        self.passed_excel_path = "{}\\{}".format(new_path, "MTF_Validation_Report.xlsx")

                        new_path = os.path.join(os.path.dirname(self.folder_path), "Failed")
                        self.failed_excel_path = "{}\\{}".format(new_path, "MTF_Validation_Report.xlsx")

                        self.intermediate_excel_obj = excel.AxExcel(self.intermediate_excel_path, self.rois)
                        self.passed_excel_obj = excel.AxExcel(self.passed_excel_path, self.rois)
                        self.failed_excel_obj = excel.AxExcel(self.failed_excel_path, self.rois)

                        if self.failed_excel_obj.isFileOpened():
                            self.excel_closed = False
                            self.msg_box_call("Permission Denied!",
                                              "Unable to access the excel file \"MTF_Validation.xlsx\".Kindly close "
                                              "the file "
                                              "and continue with validation <br><br> <b>Note:</b> Hence validated "
                                              "data will not be saved properly", "Critical")
                            return False
                        if self.passed_excel_obj.isFileOpened():
                            self.excel_closed = False
                            self.msg_box_call("Permission Denied!",
                                              "Unable to access the excel file \"MTF_Validation.xlsx\". Kindly close "
                                              "the file "
                                              "and continue with validation <br><br> <b>Note:</b> Hence validated "
                                              "data will not be saved properly", "Critical")
                            return False
                        if self.intermediate_excel_obj.isFileOpened():
                            self.excel_closed = False
                            self.msg_box_call("Permission Denied!",
                                              "Unable to access the excel file \"MTF_Validation.xlsx\". Kindly close "
                                              "the file "
                                              "and continue with validation <br><br> <b>Note:</b> Hence validated "
                                              "data will not be saved properly", "Critical")
                            return False

                        return True

                    else:
                        self.statusbar.setText("Error to create folder structure")
                        return False
            else:
                if not self.is_config_loaded:
                    self.statusbar.setText("Config file is not loaded")

                elif not self.is_all_homing:
                    self.statusbar.setText("Machine state is not in homing")

                self.timer = False
                return False

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at start_btn_streaming function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            return False

    def set_focus_change(self):
        try:
            """
            This method is used to change the cursor once it reaches its length.
            param lists: None.
            return: Bool
            """
            """Mod board, Base board, Product serial is True"""
            if self.is_config_loaded and not pd.isna(self.excel["Product Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Module Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Base Serial No."]["Product details"]):
                if len(self.mod_serial_lnedt.text()) >= int(self.excel["Module Serial len"]["Product details"]):
                    self.base_serial_lnedt.setFocus()
                if len(self.base_serial_lnedt.text()) >= int(self.excel["Base Serial len"]["Product details"]):
                    self.product_serial_lnedt.setFocus()

                """if Mod board and Base board is True"""
            elif self.is_config_loaded and pd.isna(self.excel["Product Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Module Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Base Serial No."]["Product details"]):
                if len(self.mod_serial_lnedt.text()) >= int(self.excel["Module Serial len"]["Product details"]):
                    self.base_serial_lnedt.setFocus()

                """if base board and Product serial is True"""
            elif not pd.isna(self.excel["Product Serial No."]["Product details"]) and \
                    pd.isna(self.excel["Module Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Base Serial No."]["Product details"]):
                if len(self.base_serial_lnedt.text()) >= int(self.excel["Base Serial len"]["Product details"]):
                    self.product_serial_lnedt.setFocus()

                """if mod board and Product serial is True"""
            elif not pd.isna(self.excel["Product Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Module Serial No."]["Product details"]) and \
                    pd.isna(self.excel["Base Serial No."]["Product details"]):
                if len(self.mod_serial_lnedt.text()) >= int(self.excel["Module Serial len"]["Product details"]):
                    self.product_serial_lnedt.setFocus()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at set_focus_change function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    @staticmethod
    def auto_port_connection():
        try:
            """
            This method is used to get the port name using its serial number from the config.
            param lists: None.
            return: str
            """
            light_panel_port = ""
            plc_port = ""
            plc_port_2 = ""
            actuator_port = ""
            uv_port = ""
            collimator_port = ""
            port_path = r".\media\port_details.csv"
            if os.path.isfile(port_path):
                with open(port_path, mode='r') as file:
                    csvFile = csv.reader(file)
                    plc_serial = []
                    for lines in csvFile:
                        if lines[0] == 'ï»¿Module_Name':
                            continue
                        else:
                            if lines[0] == "PLC":
                                plc_serial.append(lines[1])
                            if lines[0] == "PLC_2":
                                plc_serial.append(lines[1])
                            if lines[0] == "Actuator":
                                plc_serial.append(lines[1])
                            if lines[0] == "Uv Curing":
                                plc_serial.append(lines[1])
                            if lines[0] == "Light Panel":
                                plc_serial.append(lines[1])
                    port_list = list(serial.tools.list_ports.comports())
                    ports = []
                    if not port_list:
                        return "Ports is None"

                    for port in port_list:
                        ports.append((port.device, port.serial_number, port.description))
                        if "CH340" in port.description:
                            collimator_port = port.device

                    for x in ports:
                        if x[1] == plc_serial[0]:
                            plc_port = x[0]
                        elif x[1] == plc_serial[1]:
                            plc_port_2 = x[0]
                        elif x[1] == plc_serial[2]:
                            actuator_port = x[0]
                        elif x[1] == plc_serial[3]:
                            uv_port = x[0]
                        elif plc_serial[4] in x[2]:
                            light_panel_port = x[0]

                    return plc_port, plc_port_2, actuator_port, uv_port, light_panel_port, collimator_port

            else:
                return "Port details csv file not found"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at auto_port_connection function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def update_glue_teach_statusbar(self, status_msg):
        """
        This method is used to set the text for glue purge dialog box.
        param lists: None.
        return: None
        """
        self.gluing_teaching_statusbar_lbl.setText(status_msg)

    def teaching_glue_thread(self):
        try:
            """
            This method is used to start the thread for glue purge button.
            param lists: None.
            return: None
            """
            if self.gluing_teaching_purge_lndt.text() == "":
                self.msg_box_call("Alert", "Please enter the purge time.", "Critical")
                return

            if float(self.gluing_teaching_purge_lndt.text()) > 9:
                self.msg_box_call("Alert", "The maximum allowable time is 9 seconds.", "Critical")
                return

            if self.push_button_timer.isActive():
                self.push_button_timer.stop()

            if not self.teaching_glue_clicked:
                logger.info("Teaching_glue_Thread initialization started")
                threadCount = QThreadPool.globalInstance().maxThreadCount()
                pool = QThreadPool.globalInstance()
                pool.setMaxThreadCount(16)
                if threadCount >= 2:
                    self.teaching_glue_clicked = True
                    runnable_ports = Runnable_teaching_glue(pool)
                    runnable_ports.signals.glue_teach_status_updated.connect(self.update_glue_teach_statusbar)
                    runnable_ports.signals.call_ResetPreview.connect(self.No_preview_found)
                    pool.start(runnable_ports)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at teaching_glue_thread function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def teaching_gluing_station(self):
        try:
            """
            This method is used to create UI for glue purge.
            param lists: None.
            return: None
            """
            self.gluing_teaching_dialog = Glue_purge_dialog()
            self.gluing_teaching_dialog.setObjectName("gluing_teaching_dialog")
            self.gluing_teaching_dialog.setStyleSheet("QDialog {\n"
                                                      "background-color: rgba(196,236,236,255);\n"
                                                      "color: rgb(220, 220, 220);\n"
                                                      "border-radius: 20px;\n"
                                                      "}\n")
            self.gluing_teaching_title_lbl = QtWidgets.QLabel(self.gluing_teaching_dialog)
            self.gluing_teaching_title_lbl.setGeometry(QtCore.QRect(180, 20, 140, 30))
            self.gluing_teaching_title_lbl.setText("Glue Purge")
            font = QtGui.QFont()
            font.setPointSize(15)
            font.setBold(True)
            font.setWeight(75)
            self.gluing_teaching_title_lbl.setFont(font)
            self.gluing_teaching_title_lbl.setAlignment(QtCore.Qt.AlignCenter)
            self.gluing_teaching_title_lbl.setObjectName("gluing_teaching_title_lbl")
            self.gluing_teaching_content_lbl = QtWidgets.QLabel(self.gluing_teaching_dialog)
            self.gluing_teaching_content_lbl.setGeometry(QtCore.QRect(70, 80, 380, 90))
            self.gluing_teaching_content_lbl.setText("1. Make sure the glue dispenser is changed\n"
                                                     "        successfully.\n"
                                                     "\n"
                                                     "2. Make sure the air pressure is correct.")
            font = QtGui.QFont()
            font.setPointSize(11)
            font.setBold(True)
            font.setWeight(75)
            self.gluing_teaching_content_lbl.setFont(font)
            self.gluing_teaching_content_lbl.setObjectName("gluing_teaching_content_lbl")
            self.gluing_teaching_statusbar_lbl = QtWidgets.QLabel(self.gluing_teaching_dialog)
            self.gluing_teaching_statusbar_lbl.setGeometry(QtCore.QRect(250, 320, 230, 20))
            self.gluing_teaching_statusbar_lbl.setText("")
            font = QtGui.QFont()
            font.setPointSize(10)
            font.setBold(True)
            font.setWeight(75)
            self.gluing_teaching_statusbar_lbl.setFont(font)
            self.gluing_teaching_statusbar_lbl.setAlignment(
                QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
            self.gluing_teaching_statusbar_lbl.setObjectName("gluing_teaching_statusbar_lbl")

            self.gluing_teaching_purge_lbl = QtWidgets.QLabel(self.gluing_teaching_dialog)
            self.gluing_teaching_purge_lbl.setGeometry(QtCore.QRect(75, 195, 120, 20))
            self.gluing_teaching_purge_lbl.setText("Purge Time : ")
            font = QtGui.QFont()
            font.setPointSize(11)
            font.setBold(True)
            font.setWeight(75)
            self.gluing_teaching_purge_lbl.setFont(font)
            self.gluing_teaching_purge_lbl.setObjectName("gluing_teaching_purge_lbl")
            self.gluing_teaching_purge_lbl = QtWidgets.QLabel(self.gluing_teaching_dialog)
            self.gluing_teaching_purge_lbl.setGeometry(QtCore.QRect(75, 195, 120, 20))
            self.gluing_teaching_purge_lbl.setText("Purge Time : ")
            font = QtGui.QFont()
            font.setPointSize(11)
            font.setBold(True)
            font.setWeight(75)
            self.gluing_teaching_purge_lbl.setFont(font)
            self.gluing_teaching_purge_lbl.setObjectName("gluing_teaching_purge_lbl")
            self.gluing_teaching_purge_lndt = QtWidgets.QLineEdit(self.gluing_teaching_dialog)
            self.gluing_teaching_purge_lndt.setGeometry(QtCore.QRect(200, 190, 160, 30))
            regx = QRegExp(r'^(\d|[1-9]\d)(\.\d{1,2})?$')
            emp_id_txtbox = QRegExpValidator(regx, self.gluing_teaching_purge_lndt)
            self.gluing_teaching_purge_lndt.setValidator(emp_id_txtbox)
            self.gluing_teaching_purge_lndt.setStyleSheet("background-color: #8ab0ab;"
                                                          "border: 1px solid black;")
            self.gluing_teaching_purge_lndt.setText("9")
            font = QtGui.QFont()
            font.setPointSize(11)
            font.setBold(True)
            font.setWeight(75)
            self.gluing_teaching_purge_lndt.setFont(font)
            self.gluing_teaching_purge_lndt.setObjectName("gluing_teaching_purge_lndt")

            self.gluing_teaching_purge_btn = QtWidgets.QPushButton(self.gluing_teaching_dialog)
            self.gluing_teaching_purge_btn.setGeometry(QtCore.QRect(100, 260, 100, 35))
            self.gluing_teaching_purge_btn.setText("Purge")
            font = QtGui.QFont()
            font.setPointSize(13)
            font.setBold(True)
            font.setWeight(75)
            self.gluing_teaching_purge_btn.setFont(font)
            self.gluing_teaching_purge_btn.setStyleSheet("QPushButton:enabled{\n"
                                                        "background-color:rgb(0, 51, 51);\n"
                                                        "color:rgb(255, 255, 255);\n"
                                                        "border-radius: 10px;\n"
                                                        "}"
                                                        "QPushButton:Pressed{\n"
                                                        "padding-left:5px;\n"
                                                        "padding-top:5px;\n"
                                                        "background-color: #1a5276;\n"
                                                        "}"
                                                        "QPushButton:disabled"
                                                        "{"
                                                        "background-color:#95a5a6;"
                                                        "}"
                                                        )
            self.gluing_teaching_purge_btn.clicked.connect(self.teaching_glue_thread)
            self.gluing_teaching_purge_btn.setObjectName("gluing_teaching_purge_btn")

            self.glue_teach_btn_dclose = QtWidgets.QPushButton(self.gluing_teaching_dialog)
            self.glue_teach_btn_dclose.clicked.connect(self.glue_teach_close_dialog)
            self.glue_teach_btn_dclose.setGeometry(QtCore.QRect(300, 260, 100, 35))
            font = QtGui.QFont()
            font.setPointSize(14)
            self.glue_teach_btn_dclose.setFont(font)
            self.glue_teach_btn_dclose.setStyleSheet("QPushButton:enabled{\n"
                                                    "background-color:rgb(0, 51, 51);\n"
                                                    "color:rgb(255, 255, 255);\n"
                                                    "border-radius: 10px;\n"
                                                    "}"
                                                    "QPushButton:Pressed{\n"
                                                    "padding-left:5px;\n"
                                                    "padding-top:5px;\n"
                                                    "background-color: #1a5276;\n"
                                                    "}"
                                                    "QPushButton:disabled"
                                                    "{"
                                                    "background-color:#95a5a6;"
                                                    "}"
                                                    )
            self.glue_teach_btn_dclose.setText("Close")
            self.glue_teach_btn_dclose.setObjectName("glue_teach_btn_dclose")
            self.gluing_teaching_dialog.exec()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at teaching_gluing_staion function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def glue_teach_close_dialog(self):
        try:
            """
            This method is used to close the glue purge Ui.
            param lists: None.
            return: None
            """
            self.glue_teach_btn_dclose_clicked = True
            self.gluing_teaching_dialog.close()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at glue_teach_close_dialog function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def glue_change_positions(self, text):
        try:
            """
            This method is used change the position of label and textbox based on glue type.
            param lists: None.
            return: None
            """
            if text == "Continuous glue":
                self.gluing_cntrl_groupbox.setMinimumSize(QtCore.QSize(0, 300))
                self.gluing_cntrl_gluing_btn.setText("Gluing")
                self.gluing_on_delay_Continuous_lbl.show()
                self.gluing_on_delay_Continuous_lndt.show()
                self.gluing_off_delay_Continuous_lbl.show()
                self.gluing_off_delay_Continuous_lndt.show()
                self.gluing_detail_speed_lbl.show()
                self.gluing_detail_speed_lndt.show()
                self.gluing_detail_diameter_lbl.show()
                self.gluing_detail_diameter_lndt.show()
                self.gluing_cntrl_gluing_btn.show()
                self.gluing_cntrl_homing_btn.show()
                self.gluing_dispenser_type_lbl.hide()
                self.gluing_dispenser_type_cmb.hide()
                self.gluing_dispenser_timer_lbl.hide()
                self.gluing_dispenser_timer_lndt.hide()
                self.gluing_dispenser_apply_btn.hide()
                self.gluing_dispenser_off_btn.hide()
                self.gluing_on_delay_Continuous_lbl.setGeometry(QtCore.QRect(10, 100, 80, 15))
                self.gluing_on_delay_Continuous_lndt.setGeometry(QtCore.QRect(100, 95, 130, 30))
                self.gluing_off_delay_Continuous_lbl.setGeometry(QtCore.QRect(10, 155, 80, 15))
                self.gluing_off_delay_Continuous_lndt.setGeometry(QtCore.QRect(100, 150, 130, 30))
                self.gluing_detail_speed_lbl.setGeometry(QtCore.QRect(10, 205, 80, 15))
                self.gluing_detail_speed_lndt.setGeometry(QtCore.QRect(100, 200, 130, 30))
                self.gluing_detail_diameter_lbl.setGeometry(QtCore.QRect(10, 255, 80, 15))
                self.gluing_detail_diameter_lndt.setGeometry(QtCore.QRect(100, 250, 130, 30))
                self.gluing_cntrl_gluing_btn.setGeometry(QtCore.QRect(260, 245, 80, 40))
                self.gluing_cntrl_homing_btn.setGeometry(QtCore.QRect(260, 190, 80, 40))

            elif text == "Spot glue":
                self.gluing_cntrl_groupbox.setMinimumSize(QtCore.QSize(0, 220))
                self.gluing_cntrl_gluing_btn.setText("Purge")
                self.gluing_dispenser_type_lbl.show()
                self.gluing_dispenser_type_cmb.show()
                self.gluing_dispenser_timer_lbl.show()
                self.gluing_dispenser_timer_lndt.show()
                self.gluing_dispenser_apply_btn.show()
                self.gluing_dispenser_off_btn.show()
                self.gluing_dispenser_type_lbl.setGeometry(QtCore.QRect(10, 95, 80, 15))
                self.gluing_dispenser_type_cmb.setGeometry(QtCore.QRect(100, 90, 130, 30))
                self.gluing_dispenser_timer_lbl.setGeometry(QtCore.QRect(10, 155, 80, 15))
                self.gluing_dispenser_timer_lndt.setGeometry(QtCore.QRect(100, 150, 130, 30))
                self.gluing_dispenser_apply_btn.setGeometry(QtCore.QRect(260, 85, 80, 40))
                self.gluing_dispenser_off_btn.setGeometry(QtCore.QRect(260, 145, 80, 40))
                self.gluing_on_delay_Continuous_lbl.hide()
                self.gluing_on_delay_Continuous_lndt.hide()
                self.gluing_off_delay_Continuous_lbl.hide()
                self.gluing_off_delay_Continuous_lndt.hide()
                self.gluing_detail_speed_lbl.hide()
                self.gluing_detail_speed_lndt.hide()
                self.gluing_detail_diameter_lbl.hide()
                self.gluing_detail_diameter_lndt.hide()
                self.gluing_cntrl_gluing_btn.hide()
                self.gluing_cntrl_homing_btn.hide()

            else:
                self.gluing_cntrl_groupbox.setMinimumSize(QtCore.QSize(0, 220))
                self.gluing_cntrl_gluing_btn.setText("Dry run")
                self.gluing_detail_speed_lbl.show()
                self.gluing_detail_speed_lndt.show()
                self.gluing_detail_diameter_lbl.show()
                self.gluing_detail_diameter_lndt.show()
                self.gluing_cntrl_gluing_btn.show()
                self.gluing_cntrl_homing_btn.show()
                self.gluing_on_delay_Continuous_lbl.hide()
                self.gluing_on_delay_Continuous_lndt.hide()
                self.gluing_off_delay_Continuous_lbl.hide()
                self.gluing_off_delay_Continuous_lndt.hide()
                self.gluing_dispenser_type_lbl.hide()
                self.gluing_dispenser_type_cmb.hide()
                self.gluing_dispenser_timer_lbl.hide()
                self.gluing_dispenser_timer_lndt.hide()
                self.gluing_dispenser_apply_btn.hide()
                self.gluing_dispenser_off_btn.hide()
                self.gluing_detail_speed_lbl.setGeometry(QtCore.QRect(10, 95, 80, 15))
                self.gluing_detail_speed_lndt.setGeometry(QtCore.QRect(100, 90, 130, 30))
                self.gluing_detail_diameter_lbl.setGeometry(QtCore.QRect(10, 155, 80, 15))
                self.gluing_detail_diameter_lndt.setGeometry(QtCore.QRect(100, 150, 130, 30))
                self.gluing_cntrl_homing_btn.setGeometry(QtCore.QRect(260, 85, 80, 40))
                self.gluing_cntrl_gluing_btn.setGeometry(QtCore.QRect(260, 145, 80, 40))

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at glue_change_positions function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def relay_offset_option_check(self, text):
        try:
            """
            This method is used change the position of label and textbox based on relay offset option.
            param lists: None.
            return: None
            """
            if text == "No":
                self.relay_offset_groupbox.setMinimumSize(QtCore.QSize(0, 420))
                self.relay_dx_offset_tolerence_lbl.show()
                self.relay_dx_offset_tolerence_lndt.show()
                self.relay_dy_offset_tolerence_lbl.show()
                self.relay_dy_offset_tolerence_lndt.show()
                self.relay_lens_offset_check_btn.show()
                self.pixel_in_mm_lbl.show()
                self.pixel_in_mm_lndt.show()
                self.relay_fixture_offset_cmb.setEnabled(True)
            else:
                self.relay_offset_groupbox.setMinimumSize(QtCore.QSize(0, 300))
                self.relay_dx_offset_tolerence_lbl.hide()
                self.relay_dx_offset_tolerence_lndt.hide()
                self.relay_dy_offset_tolerence_lbl.hide()
                self.relay_dy_offset_tolerence_lndt.hide()
                self.relay_lens_offset_check_btn.hide()
                self.pixel_in_mm_lbl.hide()
                self.pixel_in_mm_lndt.hide()
                self.relay_fixture_offset_cmb.setEnabled(False)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at relay_offset_option_check function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno,
                                                                                   e))

    def collimator_offset_option_check(self, text):
        try:
            """
            This method is used change the position of label and textbox based on collimator offset option.
            param lists: None.
            return: None
            """
            if text == "Yes":
                self.Collimator_chart_details_groupbox.setMinimumSize(QtCore.QSize(0, 620))
                self.collimator_details_update_btn.setGeometry(QtCore.QRect(100, 535, 80, 30))
                self.collimator_details_simulate_btn.setGeometry(QtCore.QRect(10, 535, 80, 30))
                self.collimator_details_chart_check_btn.setGeometry(QtCore.QRect(190, 535, 80, 30))
            else:
                self.Collimator_chart_details_groupbox.setMinimumSize(QtCore.QSize(0, 500))
                self.collimator_details_update_btn.setGeometry(QtCore.QRect(150, 435, 80, 30))
                self.collimator_details_simulate_btn.setGeometry(QtCore.QRect(30, 435, 80, 30))
                self.collimator_details_chart_check_btn.setGeometry(QtCore.QRect(270, 435, 80, 30))

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at collimator_offset_option_check function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                        exc_tb.tb_lineno, e))

    def on_emp_changed_for_login(self, text):
        try:
            """
            This method is used get the emp id from the emp id textbox.
            param lists: None.
            return: None
            """
            if len(text) == 9:
                pass
            else:
                self.fingerprint_lbl.hide()
                self.pwd_txtbox.hide()
                self.pwd_txtbox.clear()
                self.move_login_btn.show()
                self.login_btn.hide()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at on_emp_changed_for_login function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def Collimator_simulate_show(self):
        try:
            """
            This method is used set the simulate on streaming.
            param lists: None.
            return: None
            """
            if not self.camera_connect:
                self.msg_box_call("Warning", "Please connect the camera", "Critical")
                return
            ui.collimator_azimuth_lndt.setText("27")
            ui.collimator_width_lndt.setText("200")
            ui.collimator_height_lndt.setText("200")
            ui.collimator_radius_lndt.setText("500")
            self.collimator_simulate_clicked = True
            self.collimator_clicked = False
            self.collimator_chart_check_clicked = False
            self.collimator_validation = False
            self.relay_validation = False
            self.collimator_offset_clicked = False

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at Collimator_simulate_show function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                           exc_tb.tb_lineno, e))

    def relay_offset_check(self):
        try:
            """
            This method is used validate the offset.
            param lists: None.
            return: None
            """
            if not self.camera_connect:
                self.msg_box_call("Warning", "Please connect the camera", "Critical")
                return

            self.relay_clicked = False
            self.relay_simulate_clicked = False
            self.collimator_chart_check_clicked = False
            self.collimator_validation = False
            self.relay_validation = False
            self.relay_chart_check_clicked = False
            self.relay_offset_clicked = True
            self.collimator_offset_clicked = True

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at relay_offset_check function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def save_frame_option(self):
        try:
            """
            This method is used save the frame.
            param lists: None.
            return: None
            """
            if not self.camera_connect:
                self.msg_box_call("Warning", "Please connect the camera", "Critical")
                return
            self.frame_saved = True

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at save_frame_option function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def collimator_offset_check(self):
        try:
            """
            This method is used validate the offset.
            param lists: None.
            return: None
            """
            if not self.camera_connect:
                self.msg_box_call("Warning", "Please connect the camera", "Critical")
                return

            self.collimator_clicked = False
            self.collimator_simulate_clicked = False
            self.collimator_chart_check_clicked = False
            self.collimator_validation = False
            self.relay_validation = False
            self.relay_chart_check_clicked = False
            self.collimator_offset_clicked = True
            self.relay_offset_clicked = True

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at collimator_offset_check function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                          exc_tb.tb_lineno, e))

    def fingerprint_create(self):
        try:
            """
            This method is used to call the thread for fingerprint creation.
            param lists: None.
            return: None
            """
            self.scanning_lbl.show()
            self.fingerprint_create_flag = True
            self.fingerprint_thread()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at fingerprint_create function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def collimator_update(self):
        try:
            """
            This method is used to create the azimuth angle.
            param lists: None.
            return: None
            """
            if not self.camera_connect:
                self.msg_box_call("Warning", "Please connect the camera", "Critical")
                return
            if self.collimator_azimuth_lndt.text() == "":
                self.msg_box_call("Warning", "Azimuth angle should not be empty", "Critical")
                return
            if self.collimator_radius_lndt.text() == "":
                self.msg_box_call("Warning", "Radius should not be empty", "Critical")
                return
            if self.collimator_width_lndt.text() == "":
                self.msg_box_call("Warning", "Width should not be empty", "Critical")
                return
            if self.collimator_height_lndt.text() == "":
                self.msg_box_call("Warning", "Height should not be empty", "Critical")
                return

            self.collimator_width_value = float(self.collimator_width_lndt.text())
            self.collimator_height_value = float(self.collimator_height_lndt.text())
            self.collimator_angle_value = float(self.collimator_azimuth_lndt.text())
            self.collimator_radius_value = float(self.collimator_radius_lndt.text())
            self.collimator_clicked = True
            self.collimator_simulate_clicked = False
            self.collimator_chart_check_clicked = False
            self.collimator_validation = False
            self.relay_validation = False
            self.relay_chart_check_clicked = False
            self.collimator_offset_clicked = False
            self.relay_offset_clicked = False

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at collimator_update function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def relay_update(self):
        try:
            """
            This method is used to create the azimuth angle.
            param lists: None.
            return: None
            """
            if not self.camera_connect:
                self.msg_box_call("Warning", "Please connect the camera", "Critical")
                return
            if self.azimuth_ang_txtbox.text() == "":
                self.msg_box_call("Warning", "Azimuth angle should not be empty", "Critical")
                return
            if self.outer_radius_txtbox.text() == "":
                self.msg_box_call("Warning", "Radius should not be empty", "Critical")
                return
            if self.width_txtbox.text() == "":
                self.msg_box_call("Warning", "Width should not be empty", "Critical")
                return
            if self.height_txtbox.text() == "":
                self.msg_box_call("Warning", "Height should not be empty", "Critical")
                return

            self.roi = self.no_of_ROI_txtbox.currentText()
            logger.info("No.of.ROI: {}, Chart Position: {}".format(self.roi, self.chart_position_box.currentText()))
            if self.roi == "5":
                self.relay_angle_value = float(self.azimuth_ang_txtbox.text())
                self.relay_radius_value = float(self.outer_radius_txtbox.text())

            elif self.roi == "9" and self.chart_position_box.currentText() == 'ITL, ITR, IBL, IBR':
                self.relay_angle_value = float(self.azimuth_ang_txtbox.text())
                self.relay_radius_value = float(self.outer_radius_txtbox.text())
                self.inr_angle = float(self.inr_azimuth_ang_txtbox.text())


            elif self.roi == "9" and self.chart_position_box.currentText() == 'TC, BC, RC, LC':
                self.relay_angle_value = float(self.azimuth_ang_txtbox.text())
                self.relay_radius_value = float(self.outer_radius_txtbox.text())

            elif self.roi == "13":
                self.relay_angle_value = float(self.azimuth_ang_txtbox.text())
                self.relay_radius_value = float(self.outer_radius_txtbox.text())
                self.inr_angle = float(self.inr_azimuth_ang_txtbox.text())

            self.relay_width_value = float(self.width_txtbox.text())
            self.relay_height_value = float(self.height_txtbox.text())
            self.relay_clicked = True
            self.relay_simulate_clicked = False
            self.collimator_chart_check_clicked = False
            self.collimator_validation = False
            self.relay_validation = False
            self.relay_chart_check_clicked = False
            self.collimator_offset_clicked = False
            self.relay_offset_clicked = False

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at relay_update function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def relay_simulate(self, image):
        try:
            """This method is used to simulate for relay station.
            param lists: None.
            return: None"""

            if not self.camera_connect:
                self.msg_box_call("Warning", "Please connect the camera", "Critical")
                return
            self.no_roi = self.no_of_ROI_txtbox.currentText()
            width_half = image.shape[1] // 2
            height_half = image.shape[0] // 2
            radius = [800, 800, 0, 800, 800]
            width = 100
            height = 100
            if self.no_roi == "5":
                angle = [29, (180 - 29), 0, 180 + 29, 360 - 29]
                ROI = ['TL', 'TR', 'C', 'BL', 'BR']
                label_list = ['TL', 'TR', 'C', 'BL', 'BR']
                roi = {}
                for x, y, z in zip(range(5), angle, radius):
                    if ROI[x] in label_list:
                        roi[ROI[x]] = []
                        centre = [width_half, height_half]
                        radian = np.math.radians(y)
                        dy = z * np.math.sin(radian)
                        dx = z * np.math.cos(radian)
                        point_x = centre[0] + dx
                        point_y = centre[1] - dy
                        x1, y1 = [int(point_x - width / 2), int(point_y - height / 2)]
                        x2, y2 = [int(point_x + width / 2), int(point_y + height / 2)]
                        roi[ROI[x]] = [y1, y2, x1, x2]

                for j, k in roi.items():
                    radius = int(
                        np.math.sqrt(abs(image.shape[1] // 2 - (k[2] + (k[3] - k[2]) // 2)) ** 2
                                     + abs(
                            image.shape[0] // 2 - (k[0] + (k[1] - k[0]) // 2)) ** 2))

                    cv2.circle(image, (image.shape[1] // 2, image.shape[0] // 2),
                               radius, (0, 255, 255), 2)
                    cv2.line(image, (image.shape[1] // 2, image.shape[0] // 2),
                             (int(k[2] + (k[3] - k[2]) // 2), int(k[0] + (k[1] - k[0]) // 2)),
                             (0, 255, 255), 2)
                    cv2.rectangle(image, tuple([k[2], k[0]]), tuple([k[3], k[1]]),
                                  (0, 255, 255), 2)

            elif self.no_roi == "9" and self.chart_position_box.currentText() == 'ITL, ITR, IBL, IBR':
                roi = {}
                angle = [29, (180 - 29), 0, 180 + 29, 360 - 29, 35, (180 - 35), 180 + 35, 360 - 35]
                radius = [600, 600, 0, 600, 600, 500, 500, 500, 500]
                ROI = ['TL', 'TR', 'C', 'BL', 'BR', 'TC', 'BC', 'RC', 'LC', 'ITL', 'ITR', 'IBL', 'IBR']
                label_list = ['TL', 'TR', 'C', 'BL', 'BR', 'TC', 'BC', 'RC', 'LC', 'ITL', 'ITR', 'IBL', 'IBR']
                for x, y, z in zip(range(9), angle, radius):
                    if ROI[x] in label_list:
                        roi[ROI[x]] = []
                        centre = [width_half, height_half]
                        radian = np.math.radians(y)
                        dy = z * np.math.sin(radian)
                        dx = z * np.math.cos(radian)
                        point_x = centre[0] + dx
                        point_y = centre[1] - dy
                        x1, y1 = [int(point_x - width / 2), int(point_y - height / 2)]
                        x2, y2 = [int(point_x + width / 2), int(point_y + height / 2)]
                        roi[ROI[x]] = [y1, y2, x1, x2]

                for j, k in roi.items():
                    radius = int(
                        np.math.sqrt(abs(image.shape[1] // 2 - (k[2] + (k[3] - k[2]) // 2)) ** 2
                                     + abs(
                            image.shape[0] // 2 - (k[0] + (k[1] - k[0]) // 2)) ** 2))
                    cv2.circle(image, (image.shape[1] // 2, image.shape[0] // 2),
                               radius, (0, 255, 255), 2)
                    cv2.line(image, (image.shape[1] // 2, image.shape[0] // 2),
                             (int(k[2] + (k[3] - k[2]) // 2), int(k[0] + (k[1] - k[0]) // 2)),
                             (0, 255, 255), 2)
                    cv2.rectangle(image, tuple([k[2], k[0]]), tuple([k[3], k[1]]),
                                  (0, 255, 255), 2)

            elif self.no_roi == "9" and self.chart_position_box.currentText() == 'TC, BC, RC, LC':
                roi = {}
                angle = [29, (180 - 29), 0, 180 + 29, 360 - 29, 90, 270, 0, 180]
                radius = [600, 600, 0, 600, 600, 500, 500, 500, 500]
                width = 100
                height = 100
                ROI = ['TL', 'TR', 'C', 'BL', 'BR', 'TC', 'BC', 'RC', 'LC', 'ITL', 'ITR', 'IBL', 'IBR']
                label_list = ['TL', 'TR', 'C', 'BL', 'BR', 'TC', 'BC', 'RC', 'LC', 'ITL', 'ITR', 'IBL', 'IBR']
                for x, y, z in zip(range(9), angle, radius):
                    if ROI[x] in label_list:
                        roi[ROI[x]] = []
                        centre = [width_half, height_half]
                        radian = np.math.radians(y)
                        dy = z * np.math.sin(radian)
                        dx = z * np.math.cos(radian)
                        point_x = centre[0] + dx
                        point_y = centre[1] - dy
                        x1, y1 = [int(point_x - width / 2), int(point_y - height / 2)]
                        x2, y2 = [int(point_x + width / 2), int(point_y + height / 2)]
                        roi[ROI[x]] = [y1, y2, x1, x2]
                for j, k in roi.items():
                    radius = int(
                        np.math.sqrt(abs(image.shape[1] // 2 - (k[2] + (k[3] - k[2]) // 2)) ** 2
                                     + abs(
                            image.shape[0] // 2 - (k[0] + (k[1] - k[0]) // 2)) ** 2))
                    cv2.circle(image, (image.shape[1] // 2, image.shape[0] // 2),
                               radius, (0, 255, 255), 2)
                    cv2.line(image, (image.shape[1] // 2, image.shape[0] // 2),
                             (int(k[2] + (k[3] - k[2]) // 2), int(k[0] + (k[1] - k[0]) // 2)),
                             (0, 255, 255), 2)
                    cv2.rectangle(image, tuple([k[2], k[0]]), tuple([k[3], k[1]]),
                                  (0, 255, 255), 2)

            elif self.no_roi == "13":
                width_half = image.shape[1] // 2
                height_half = image.shape[0] // 2
                roi = {}
                angle = [29, (180 - 29), 0, 180 + 29, 360 - 29, 90, 270, 0, 180, 35, (180 - 35), 180 + 35, 360 - 35]
                radius = [600, 600, 0, 600, 600, 500, 500, 500, 500, 400, 400, 400, 400]
                width = 100
                height = 100
                ROI = ['TL', 'TR', 'C', 'BL', 'BR', 'TC', 'BC', 'RC', 'LC', 'ITL', 'ITR', 'IBL', 'IBR']
                label_list = ['TL', 'TR', 'C', 'BL', 'BR', 'TC', 'BC', 'RC', 'LC', 'ITL', 'ITR', 'IBL', 'IBR']
                for x, y, z in zip(range(13), angle, radius):
                    if ROI[x] in label_list:
                        roi[ROI[x]] = []
                        centre = [width_half, height_half]
                        radian = np.math.radians(y)
                        dy = z * np.math.sin(radian)
                        dx = z * np.math.cos(radian)
                        point_x = centre[0] + dx
                        point_y = centre[1] - dy
                        x1, y1 = [int(point_x - width / 2), int(point_y - height / 2)]
                        x2, y2 = [int(point_x + width / 2), int(point_y + height / 2)]
                        roi[ROI[x]] = [y1, y2, x1, x2]
                for j, k in roi.items():
                    radius = int(
                        np.math.sqrt(abs(image.shape[1] // 2 - (k[2] + (k[3] - k[2]) // 2)) ** 2
                                     + abs(
                            image.shape[0] // 2 - (k[0] + (k[1] - k[0]) // 2)) ** 2))
                    cv2.circle(image, (image.shape[1] // 2, image.shape[0] // 2),
                               radius, (0, 255, 255), 2)
                    cv2.line(image, (image.shape[1] // 2, image.shape[0] // 2),
                             (int(k[2] + (k[3] - k[2]) // 2), int(k[0] + (k[1] - k[0]) // 2)),
                             (0, 255, 255), 2)
                    cv2.rectangle(image, tuple([k[2], k[0]]), tuple([k[3], k[1]]),
                                  (0, 255, 255), 2)
        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at relay_simulate function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def relay_simulate_show(self):
        try:
            """
            This method is used to change the flag value.
            param lists: None.
            return: None
            """
            if not self.camera_connect:
                self.msg_box_call("Warning", "Please connect the camera", "Critical")
                return

            self.no_roi = self.no_of_ROI_txtbox.currentText()
            logger.info("NO.of ROI : {}".format(self.no_roi))
            if self.no_roi == "5":
                self.azimuth_ang_txtbox.setText("29")
                self.width_txtbox.setText("100")
                self.height_txtbox.setText("100")
                self.outer_radius_txtbox.setText("960")
            elif self.no_roi == "9" and self.chart_position_box.currentText() == 'ITL, ITR, IBL, IBR':
                self.azimuth_ang_txtbox.setText("29")
                self.width_txtbox.setText("100")
                self.height_txtbox.setText("100")
                self.outer_radius_txtbox.setText("960")
                self.inr_azimuth_ang_txtbox.setText("35")
                self.inr_radius_txtbox.setText("760")
            elif self.no_roi == "9" and self.chart_position_box.currentText() == 'TC, BC, RC, LC':
                self.azimuth_ang_txtbox.setText("29")
                self.width_txtbox.setText("100")
                self.height_txtbox.setText("100")
                self.outer_radius_txtbox.setText("760")
                self.inr_radius_txtbox.setText("570")
            elif self.no_roi == "13":
                self.azimuth_ang_txtbox.setText("29")
                self.width_txtbox.setText("100")
                self.height_txtbox.setText("100")
                self.outer_radius_txtbox.setText("760")
                self.inr_azimuth_ang_txtbox.setText("35")
                self.inr_radius_txtbox.setText("760")
                self.deep_inr_radius_txtbox.setText("400")

            self.relay_simulate_clicked = True
            self.relay_clicked = False
            self.collimator_offset_clicked = False
            self.relay_offset_clicked = False
            self.collimator_chart_check_clicked = False
            self.collimator_validation = False
            self.relay_validation = False
            self.relay_chart_check_clicked = False

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at relay_simulate_show function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def chart_check_click(self, station):
        try:
            """
            This method is used to change the flag for validate the mtf calculation.
            param lists: None.
            return: None
            """
            if not self.camera_connect:
                self.msg_box_call("Warning", "Please connect the camera", "Critical")
                return
            if station == "Relay":
                if self.azimuth_ang_txtbox.text() == "":
                    self.msg_box_call("Warning", "Azimuth angle should not be empty", "Critical")
                    return
                if self.outer_radius_txtbox.text() == "":
                    self.msg_box_call("Warning", "Radius should not be empty", "Critical")
                    return
                if self.width_txtbox.text() == "":
                    self.msg_box_call("Warning", "Width should not be empty", "Critical")
                    return
                if self.height_txtbox.text() == "":
                    self.msg_box_call("Warning", "Height should not be empty", "Critical")
                    return
                if self.relay_black_lvl_value_lndt.text() == "":
                    self.msg_box_call("Warning", "Black level value should not be empty\n"
                                                 "if you don't need black level subtraction please enter as 0",
                                      "Critical")
                    return
                if self.relay_median_frame_cnt_lndt.text() == "":
                    self.msg_box_call("Warning", "Median frame textbox should not be empty", "Critical")
                    return
                if self.relay_red_value_lndt.text() == "":
                    self.msg_box_call("Warning", "Red value textbox should not be empty\n"
                                                 "if you don't need red value please enter as 0", "Critical")
                    return
                if self.relay_blue_value_lndt.text() == "":
                    self.msg_box_call("Warning", "Blue value textbox should not be empty\n"
                                                 "if you don't need blue value please enter as 0", "Critical")
                    return
                if self.relay_green_value_lndt.text() == "":
                    self.msg_box_call("Warning", "Green value textbox should not be empty\n"
                                                 "if you don't need green value please enter as 0", "Critical")
                    return
                self.relay_chart_check_clicked = True
                self.collimator_validation = False
                self.relay_validation = True

            elif station == "Collimator":
                if self.collimator_azimuth_lndt.text() == "":
                    self.msg_box_call("Warning", "Azimuth angle should not be empty", "Critical")
                    return
                if self.collimator_radius_lndt.text() == "":
                    self.msg_box_call("Warning", "Radius should not be empty", "Critical")
                    return
                if self.collimator_width_lndt.text() == "":
                    self.msg_box_call("Warning", "Width should not be empty", "Critical")
                    return
                if self.collimator_height_lndt.text() == "":
                    self.msg_box_call("Warning", "Height should not be empty", "Critical")
                    return
                if self.collimator_black_lvl_value_lndt.text() == "":
                    self.msg_box_call("Warning", "Black level value should not be empty\n"
                                                 "if you don't need black level subtraction please enter as 0",
                                      "Critical")
                    return
                if self.collimator_median_frame_cnt_lndt.text() == "":
                    self.msg_box_call("Warning", "Median frame textbox should not be empty",
                                      "Critical")
                    return
                if self.collimator_red_value_lndt.text() == "":
                    self.msg_box_call("Warning", "Red value textbox should not be empty\n"
                                                 "if you don't need red value please enter as 0", "Critical")
                    return
                if self.collimator_blue_value_lndt.text() == "":
                    self.msg_box_call("Warning", "Blue value textbox should not be empty\n"
                                                 "if you don't need blue value please enter as 0", "Critical")
                    return
                if self.collimator_green_value_lndt.text() == "":
                    self.msg_box_call("Warning", "Green value textbox should not be empty\n"
                                                 "if you don't need green value please enter as 0", "Critical")
                    return
                self.collimator_validation = True
                self.relay_validation = False
                self.collimator_chart_check_clicked = True

            self.collimator_simulate_clicked = False
            self.collimator_clicked = False
            self.relay_simulate_clicked = False
            self.relay_clicked = False
            self.collimator_offset_clicked = False
            self.relay_offset_clicked = False

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at chart_check_click function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def collimator_simulate(self, image):
        try:
            """
            This method is used to draw the simulate on collimator station.
            param lists: None.
            return: None
            """
            width_half = image.shape[1] // 2
            height_half = image.shape[0] // 2
            angle = [27, (180 - 27), 0, 180 + 27, 360 - 27]
            cv2.circle(image, (width_half, height_half), 1, (0, 255, 0), 10)
            radius = [500, 500, 0, 500, 500]
            width = 200
            height = 200
            ROI = ['TL', 'TR', 'C', 'BL', 'BR']
            label_list = ['TL', 'TR', 'C', 'BL', 'BR']
            roi = {}
            for x, y, z in zip(range(5), angle, radius):
                if ROI[x] in label_list:
                    roi[ROI[x]] = []
                    centre = [width_half, height_half]
                    radian = np.math.radians(y)
                    dy = z * np.math.sin(radian)
                    dx = z * np.math.cos(radian)
                    point_x = centre[0] + dx
                    point_y = centre[1] - dy
                    x1, y1 = [int(point_x - width / 2), int(point_y - height / 2)]
                    x2, y2 = [int(point_x + width / 2), int(point_y + height / 2)]
                    roi[ROI[x]] = [y1, y2, x1, x2]
            for j, k in roi.items():
                radius = int(np.math.sqrt(
                    abs(image.shape[1] // 2 - (k[2] + (k[3] - k[2]) // 2)) ** 2
                    + abs(image.shape[0] // 2 - (k[0] + (k[1] - k[0]) // 2)) ** 2))

                cv2.circle(image, (image.shape[1] // 2, image.shape[0] // 2),
                           radius, (0, 255, 255), 2)

                cv2.line(image, (image.shape[1] // 2, image.shape[0] // 2),
                         (int(k[2] + (k[3] - k[2]) // 2), int(k[0] + (k[1] - k[0]) // 2)),
                         (0, 255, 255), 2)

                cv2.rectangle(image, tuple([k[2], k[0]]), tuple([k[3], k[1]]),
                              (0, 255, 255), 2)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at collimator_simulate function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                      exc_tb.tb_lineno, e))

    def on_resolution_changed(self, value):
        try:
            """
           This method is used to set the aspect ratio when user change the resolution.
           param lists: None.
           return: None
           """
            var = list(self.resolution_box.currentText())
            self.resolution_index = self.resolution_box.currentIndex()
            var_string = ''.join(var)
            var_list = var_string.split(', ')
            var1 = [element.strip('()\'"') for element in var_list]
            x_w = var1[2]
            x_h = var1[3]
            self.image_resolution = [int(x_w), int(x_h)]
            self.change_resolution = True

            width_ratio = self.image_resolution[0] / self.image_resolution[1]
            height_ratio = self.image_resolution[0] / self.image_resolution[1]
            self.optimal_width = int(width_ratio * self.image_preview_1.geometry().height())
            self.optimal_height = int(height_ratio * self.image_preview_1.geometry().width())

            if self.image_preview_1.geometry().height() >= int(x_h) and self.image_preview_1.geometry().width() >= int(
                    x_w):
                self.dim = (int(x_w), int(x_h))
            elif self.image_preview_1.geometry().width() > self.optimal_width:
                self.dim = (self.optimal_width, self.image_preview_1.geometry().height())
            elif self.image_preview_1.geometry().height() > self.optimal_height:
                self.dim = (self.image_preview_1.geometry().width(), self.optimal_height)
            else:
                self.dim = (self.image_preview_1.geometry().width(), self.image_preview_1.geometry().height())

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at on_resolution_changed function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def on_format_changed(self):
        try:
            """
           This method is used to change the flag status when user change the resolution.
           param lists: None.
           return: None
           """
            self.change_format_type = True

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at on_format_changed function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def close_dialog(self):
        try:
            """
           This method is used to close the dialog box of machine controls.
           param lists: None.
           return: None
           """
            if self.machine_flow.sensor_dialog.isVisible():
                self.machine_flow.sensor_dialog.close()
            elif self.machine_flow.port_dialog.isVisible():
                self.machine_flow.port_dialog.close()
            elif self.machine_flow.diagnostic_dialog.isVisible():
                self.machine_flow.diagnostic_dialog.close()
                try:
                    ui.abort_clicked = True
                except Exception as e:
                    logger.error(f"Error stopping thread: {e}")

            elif self.machine_flow.machine_sensor_dialog.isVisible():
                self.machine_flow.machine_sensor_dialog.close()
            else:
                logger.error("dialog box not found")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at close_dialog function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def read_machine_control_xl(self, option="Diagnostic"):
        try:
            """
           This method is used to read the machine control excel file.
           param lists: None.
           return: None
           """
            if os.path.isfile(r".\media\machine control bypass file.xlsx"):
                dataframe = openpyxl.load_workbook(r".\media\machine control bypass file.xlsx")
                if option == "Diagnostic":
                    dataframe1 = dataframe.worksheets[0]
                else:
                    dataframe1 = dataframe.worksheets[1]

                values_dict = {}
                for row in range(1, dataframe1.max_row):
                    li = []
                    for col in dataframe1.iter_cols(1, dataframe1.max_column):
                        li.append(col[row].value)
                    values_dict[f"{li[0]}"] = li[1:]
                return values_dict

            else:
                self.msg_box_call("Alert", "Machine control excel file is not found", "Critical")
                return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at read_machine_control_xl function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def user_recipe_settings(self):
        try:
            """
               This method is used to choose the option from settings button.
               param lists: None.
               return: None
               """
            logger.info('Recipe create mode page shows')
            if self.push_button_timer.isActive():
                self.push_button_timer.stop()

            if self.init_timer.isActive():
                self.init_timer.stop()

            user_option = self.user_setting.machine_menu.sender().text()
            self.edit_user_table = QtWidgets.QTableWidget()
            self.is_config_loaded = False

            if user_option == "Create User":
                self.setupUi(self, mode="recipe_create")
                self.stackedWidget_1.setGeometry(
                    QtCore.QRect(450, 80, self.window_width - 500, self.window_height - 200))
                self.btn_next.hide()
                self.btn_prev.hide()
                self.btn_save.hide()
                self.btn_save_recipe.hide()
                self.btn_cancel.hide()
                self.btn_mode.show()
                self.evt_create_user(text='Create User')
                self.btn_user_create.clicked.connect(self.db_btn)
                self.btn_fingerprint_create.clicked.connect(self.fingerprint_create)

            elif user_option == 'Edit User':
                self.setupUi(self, mode="recipe_create")
                self.stackedWidget_1.setGeometry(
                    QtCore.QRect(450, 80, self.window_width - 500, self.window_height - 200))
                self.btn_next.hide()
                self.btn_prev.hide()
                self.btn_save.hide()
                self.btn_save_recipe.hide()
                self.btn_cancel.hide()
                self.btn_mode.show()
                self.evt_create_user(text='Edit User')
                self.btn_user_create.clicked.connect(self.db_btn)
                self.edit_user_table.cellClicked.connect(self.get_cell_value)

            elif user_option == 'Delete User':
                self.setupUi(self, mode="recipe_create")
                self.stackedWidget_1.setGeometry(
                    QtCore.QRect(450, 80, self.window_width - 500, self.window_height - 200))
                self.btn_next.hide()
                self.btn_prev.hide()
                self.btn_save.hide()
                self.btn_save_recipe.hide()
                self.btn_cancel.hide()
                self.btn_mode.show()
                self.evt_create_user(text='Delete User')
                self.btn_user_create.clicked.connect(self.db_btn)
                self.edit_user_table.cellClicked.connect(self.get_cell_value)

            elif user_option == 'Create Recipe' or user_option == 'Edit Recipe':
                self.abort_clicked = False
                self.diagnostics_clicked = False
                if user_option == 'Create Recipe':
                    if self.ready_port and self.is_all_homing:
                        self.setupUi(self, mode="recipe_create")
                        self.evt_create_recipe()
                    elif not self.ready_port:
                        self.msg_box_call('Alert', 'Ports are not connected.', 'Critical')
                        return
                    elif not self.is_all_homing:
                        self.msg_box_call('Alert', 'Machine is not in homing position.', 'Critical')
                        return

                elif user_option == 'Edit Recipe':
                    if self.ready_port and self.is_all_homing:
                        self.setupUi(self, mode="recipe_create")
                        self.evt_edit_recipe()
                    elif not self.ready_port:
                        self.msg_box_call('Alert', 'Ports are not connected.', 'Critical')
                        return
                    elif not self.is_all_homing:
                        self.msg_box_call('Alert', 'Machine is not in homing position.', 'Critical')
                        return

                self.stackedWidget_1.setGeometry(
                    QtCore.QRect(450, 50, self.window_width - 500, self.window_height - 200))
                self.btn_next.show()
                self.btn_prev.hide()
                self.btn_save.show()
                self.btn_save_recipe.hide()
                self.btn_cancel.show()
                self.btn_mode.hide()

                self.btn_cancel.clicked.connect(self.cancel)
                self.btn_save_recipe.clicked.connect(self.save_recipe)
                self.btn_next.clicked.connect(
                    lambda: self.slideToIndex(new_index=int(self.stackedWidget.currentIndex()) + 1))
                self.btn_prev.clicked.connect(
                    lambda: self.slideToIndex(new_index=int(self.stackedWidget.currentIndex()) - 1))
                self.no_of_ROI_txtbox.currentIndexChanged.connect(self.on_combobox_changed)
                self.chart_position_box.currentTextChanged.connect(self.on_combobox_changed)
                self.collimator_type_cmb.currentTextChanged.connect(self.on_collimator_changed)
                self.mod_board_check_box.stateChanged.connect(self.on_checkbox_changed)
                self.base_board_check_box.stateChanged.connect(self.on_checkbox_changed)
                self.product_board_check_box.stateChanged.connect(self.on_checkbox_changed)
                self.stored_values_dict = self.read_machine_control_xl()
                self.loading_x_axis_mini_lndt.setToolTip(
                    "The X-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['X-actuator'][1]
                    )
                )
                self.loading_y_axis_mini_lndt.setToolTip(
                    "The Y-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['Y-actuator'][1]
                    )
                )
                self.loading_slider_mini_lndt.setToolTip(
                    "The slider value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['Slider'][1]
                    )
                )
                self.loading_gripper_mini_lndt.setToolTip(
                    "The gripper value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['Gripper'][1]
                    )
                )
                self.lens_rotator_x_axis_mini_lndt.setToolTip(
                    "The X-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['X-actuator'][1]
                    )
                )
                self.lens_rotator_y_axis_mini_lndt.setToolTip(
                    "The Y-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['Y-actuator'][1]
                    )
                )
                self.collimator_x_axis_mini_lndt.setToolTip(
                    "The X-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['X-actuator'][1]
                    )
                )
                self.collimator_y_axis_mini_lndt.setToolTip(
                    "The Y-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['Y-actuator'][1]
                    )
                )
                self.relay_x_axis_mini_lndt.setToolTip(
                    "The X-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['X-actuator'][1]
                    )
                )
                self.relay_y_axis_mini_lndt.setToolTip(
                    "The Y-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['Y-actuator'][1]
                    )
                )
                self.relay_light_panel_actuator_mini_lndt.setToolTip(
                    "The Z-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['Relay Z-actuator'][1]
                    )
                )
                self.gluing_x_axis_mini_lndt.setToolTip(
                    "The X-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['X-actuator'][1]
                    )
                )
                self.gluing_y_axis_mini_lndt.setToolTip(
                    "The Y-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['Y-actuator'][1]
                    )
                )
                self.gluing_z_axis_mini_lndt.setToolTip(
                    "The Z-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['Gluing Z-actuator'][1]
                    )
                )
                self.curing_x_axis_mini_lndt.setToolTip(
                    "The X-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['X-actuator'][1]
                    )
                )
                self.curing_y_axis_mini_lndt.setToolTip(
                    "The Y-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['Y-actuator'][1]
                    )
                )
                self.curing_z_axis_mini_lndt.setToolTip(
                    "The Z-Actuator value is limited to a range of 0 to {}".format(
                        self.stored_values_dict['Curing Z-actuator'][1]
                    )
                )

                self.front_door_open_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text="front door open"))
                self.front_door_close_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text="front door close"))
                self.loading_part_load_close_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text="part_loading out"))
                self.loading_part_load_open_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text="part_loading in"))
                self.loading_init_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text="loading_init"))
                self.loading_overall_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text="loading_overall_homing"))

                self.loading_x_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='loading_x_axis_run_btn'))
                self.loading_x_axis_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='loading x_axis_homing btn'))
                self.loading_y_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='loading_y_axis_run_btn'))
                self.loading_y_axis_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='loading y_axis_homing btn'))
                self.loading_slider_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='loading_slider_run_btn'))
                self.loading_slider_init_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='loading slider_homing btn'))
                self.loading_gripper_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='loading_gripper_run_btn'))
                self.loading_gripper_open_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='loading gripper_homing btn'))
                self.loading_rotation_clkwise_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='loading_clockwise'))
                self.loading_rotation_aclkwise_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='loading_anti_clockwise'))

                self.lens_rotator_x_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='lens_rotator_x_axis_run_btn'))
                self.lens_rotator_x_axis_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='lens_rotator_x_axis_homing_btn'))
                self.lens_rotator_y_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='lens_rotator_y_axis_run_btn'))
                self.lens_rotator_y_axis_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='lens_rotator_y_axis_homing_btn'))
                self.lens_rotator_gripper_clkwise_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='lens_rotator_clockwise'))
                self.lens_rotator_gripper_aclkwise_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='lens_rotator_anti_clockwise'))

                self.collimator_x_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='collimator_x_axis_run_btn'))
                self.collimator_x_axis_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='collimator_x_axis_homing_btn'))
                self.collimator_y_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='collimator_y_axis_run_btn'))
                self.collimator_y_axis_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='collimator_y_axis_homing_btn'))
                self.collimator_gripper_clkwise_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='collimator_clockwise_btn'))
                self.collimator_gripper_aclkwise_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='collimator_anti_clockwise_btn'))
                self.collimator_chart_detail_update_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text="Collimator_chart_dst_lux_btn"))

                self.collimator_details_update_btn.clicked.connect(self.collimator_update)
                self.collimator_details_simulate_btn.clicked.connect(self.Collimator_simulate_show)
                self.collimator_details_chart_check_btn.clicked.connect(
                    lambda: self.chart_check_click(station="Collimator"))
                self.collimator_details_save_frame_btn.clicked.connect(self.save_frame_option)

                self.relay_x_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='relay_x_axis_run_btn'))
                self.relay_x_axis_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='relay_x_axis_homing_btn'))
                self.relay_y_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='relay_y_axis_run_btn'))
                self.relay_y_axis_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='relay_y_axis_homing_btn'))
                self.relay_gripper_clkwise_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='relay_clockwise_btn'))
                self.relay_gripper_aclkwise_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='relay_anti_clockwise_btn'))
                self.relay_light_panel_actuator_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='relay_light_panel_actuator_run_btn'))
                self.relay_light_panel_actuator_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='relay_light_panel_actuator_homing_btn'))
                self.relay_light_panel_intensity_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='relay_light_panel_intensity_btn'))

                self.relay_chart_check_btn.clicked.connect(lambda: self.chart_check_click(station="Relay"))
                self.relay_update_btn.clicked.connect(self.relay_update)
                self.relay_simulate_btn.clicked.connect(self.relay_simulate_show)
                self.relay_offset_cmb.currentTextChanged.connect(self.relay_offset_option_check)
                self.relay_lens_offset_check_btn.clicked.connect(self.relay_offset_check)
                self.relay_details_save_frame_btn.clicked.connect(self.save_frame_option)

                self.gluing_type_cmb.currentTextChanged.connect(self.glue_change_positions)
                self.gluing_cntrl_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='Gluing init btn'))
                self.gluing_cntrl_gluing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='gluing_ctrl_gluing_btn'))
                self.gluing_dispenser_apply_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='gluing_dispenser_apply_btn'))
                self.gluing_dispenser_off_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='gluing_dispenser_off_btn'))
                self.gluing_x_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='gluing_x_axis_run_btn'))
                self.gluing_y_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='gluing_y_axis_run_btn'))
                self.gluing_z_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='gluing_z_axis_run_btn'))
                self.gluing_z_gluing_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='gluing_z_axis_homing_btn'))
                self.gluing_teaching_x1_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='gluing_teaching_x1_run_btn'))
                self.gluing_teaching_x2_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='gluing_teaching_x2_run_btn'))
                self.gluing_teaching_y_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='gluing_teaching_y_run_btn'))
                self.gluing_teaching_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='Gluing init btn'))

                self.curing_x_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='curing_x_axis_run_btn'))
                self.curing_y_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='curing_y_axis_run_btn'))
                self.curing_z_axis_run_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='curing_z_axis_run_btn'))
                self.curing_z_axis_homing_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text='curing_z_axis_homing_btn'))
                self.curing_door_in_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text="curing door open"))
                self.curing_door_out_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text="curing door close"))
                self.curing_detail_cure_btn.clicked.connect(
                    lambda: self.spinbox_clicked(text="Curing_on"))

                self.get_device_btn.clicked.connect(self.run_thread_streaming)
                self.path_btn.clicked.connect(self.recipe_path_btn)
                self.btn_save.clicked.connect(self.save_excel)
                self.resolution_box.currentIndexChanged.connect(self.on_resolution_changed)
                self.img_frmt_box.currentTextChanged.connect(self.on_format_changed)

            self.btn_mode.setEnabled(True)
            self.user_setting.hide()
            self.tableWidget.hide()
            self.user_name_lbl.hide()
            self.progress_bar.hide()
            self.user_setting.hide()
            self.statusbar.setText("")
            self.btn_mode.clicked.connect(lambda: self.evt_btn_mode(texts='ADMIN'))
            self.btn_mode.clicked.connect(self.close_fingerprint)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at user_recipe_settings function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def close_fingerprint(self):
        """
           This method is used to close the fingerprint creation.
           param lists: None.
           return: None
       """
        self.close_fingerprint_thread = True
        self.scanning_lbl.hide()

    def find_refresh_button(self, btn_type):
        try:
            """
               This method is used to call the thread of Io status and port connection and
                get the recent status of bypass screen from the config file.
               param lists: btn_type is str.
               return: None
           """
            if btn_type == "I/o refresh":
                self.i_o_refresh_btn = True
                self.machine_flow.sensor_status_btn_refresh.setEnabled(False)
                self.machine_flow.sensor_status_btn_dclose.setEnabled(False)
                self.connect_ports_thread()

            if btn_type == "Port refresh":
                self.port_refresh_btn = True
                self.connect_ports_thread()

            if btn_type == "Bypass Screen":
                checkboxes = [self.machine_flow.right_door_toggle, self.machine_flow.left_door_toggle,
                              self.machine_flow.front_door_open_toggle, self.machine_flow.front_door_close_toggle,
                              self.machine_flow.product_present_toggle, self.machine_flow.gd_left_open_toggle,
                              self.machine_flow.gd_left_close_toggle, self.machine_flow.gd_right_open_toggle,
                              self.machine_flow.gd_right_close_toggle, self.machine_flow.gluing_motor_alarm_toggle,
                              self.machine_flow.uv_door_cylinder_open_toggle,
                              self.machine_flow.uv_door_cylinder_close_toggle]

                for box, idx in zip(checkboxes, self.bypass_option):
                    if box.isChecked():
                        self.bypass_option[idx] = True
                    else:
                        self.bypass_option[idx] = False
                try:
                    dataframe = openpyxl.load_workbook(r".\media\machine control bypass file.xlsx")
                    dataframe1 = dataframe.worksheets[1]
                    for x, y in enumerate(self.bypass_option.values(), start=2):
                        dataframe1.cell(row=x, column=2).value = bool(y)
                    dataframe.save(r".\media\machine control bypass file.xlsx")
                    self.msg_box_call("Successful", "Above details are saved successfully", "Information")

                except PermissionError:
                    self.msg_box_call("Permission Denied!",
                                      "Unable to access the excel file \"machine control bypass file.xlsx\". "
                                      "Kindly close the file and "
                                      "continue with validation <br><br> <b>Note:</b> Hence validated data will not be "
                                      "saved properly", "Critical")
                    return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at find_refresh_button function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def machine_control_btn(self):
        try:
            """
               This method is used to display the UI based on the user selection.
               param lists: None.
               return: None
            """
            logger.info('machine control button is clicked')
            self.diagnostics_clicked = False
            if self.machine_cntrl_btn.machine_menu.sender().text() == 'I/o Check':
                logger.info('I/o Check option is clicked')
                self.machine_flow.sensor_status_dialog(self.machine_flow.i_o_monitor, self.machine_flow.o_p_list)
                self.machine_flow.sensor_status_btn_refresh.clicked.connect(
                    lambda: self.find_refresh_button("I/o refresh"))
                self.machine_flow.sensor_status_btn_dclose.clicked.connect(self.close_dialog)
                self.machine_flow.sensor_dialog.exec()

            if self.machine_cntrl_btn.machine_menu.sender().text() == 'Port Connection':
                logger.info('Port Connection option is clicked')
                self.machine_flow.port_btn_refresh.setEnabled(True)
                self.machine_flow.port_btn_refresh.clicked.connect(lambda: self.find_refresh_button("Port refresh"))
                self.machine_flow.port_btn_dclose.clicked.connect(self.close_dialog)
                self.machine_flow.port_dialog.exec()

            elif self.machine_cntrl_btn.machine_menu.sender().text() == 'Diagnostics Screen':
                logger.info('Diagnostics Screen option is clicked')
                self.machine_flow.diagnostics_btn_dclose.clicked.connect(self.close_dialog)
                values_dict = self.read_machine_control_xl(option="Diagnostic")
                self.machine_flow.gripper_max_distance_lnedt.setText(f"{values_dict['Gripper'][1]}")
                self.machine_flow.gripper_min_distance_lnedt.setText(f"{values_dict['Gripper'][0]}")
                self.machine_flow.slider_max_distance_lnedt.setText(f"{values_dict['Slider'][1]}")
                self.machine_flow.slider_min_distance_lnedt.setText(f"{values_dict['Slider'][0]}")
                self.machine_flow.y_axis_max_distance_lnedt.setText(f"{values_dict['Y-actuator'][1]}")
                self.machine_flow.y_axis_min_distance_lnedt.setText(f"{values_dict['Y-actuator'][0]}")
                self.machine_flow.x_axis_max_distance_lnedt.setText(f"{values_dict['X-actuator'][1]}")
                self.machine_flow.x_axis_min_distance_lnedt.setText(f"{values_dict['X-actuator'][0]}")
                self.machine_flow.light_panel_max_distance_lnedt.setText(f"{values_dict['Relay Z-actuator'][1]}")
                self.machine_flow.light_panel_min_distance_lnedt.setText(f"{values_dict['Relay Z-actuator'][0]}")
                self.machine_flow.gd_z_axis_max_distance_lnedt.setText(f"{values_dict['Gluing Z-actuator'][1]}")
                self.machine_flow.gd_z_axis_min_distance_lnedt.setText(f"{values_dict['Gluing Z-actuator'][0]}")
                self.machine_flow.gluing_x1_max_distance_lnedt.setText(f"{values_dict['Gluing X1-actuator'][1]}")
                self.machine_flow.gluing_x1_min_distance_lnedt.setText(f"{values_dict['Gluing X1-actuator'][0]}")
                self.machine_flow.gluing_x2_max_distance_lnedt.setText(f"{values_dict['Gluing X2-actuator'][1]}")
                self.machine_flow.gluing_x2_min_distance_lnedt.setText(f"{values_dict['Gluing X2-actuator'][0]}")
                self.machine_flow.gluing_y_max_distance_lnedt.setText(f"{values_dict['Gluing Y-actuator'][1]}")
                self.machine_flow.gluing_y_min_distance_lnedt.setText(f"{values_dict['Gluing Y-actuator'][0]}")
                self.machine_flow.uv_z_axis_max_distance_lnedt.setText(f"{values_dict['Curing Z-actuator'][1]}")
                self.machine_flow.uv_z_axis_min_distance_lnedt.setText(f"{values_dict['Curing Z-actuator'][0]}")
                self.diagnostic_get_current_value = {"Slider": 0, "Gripper": 0, "Gluing_x1": 0, "Gluing_x2": 0,
                                                     "Gluing_y": 0}
                for x in self.diagnostic_get_current_value:
                    self.diagnostic_get_current_value[
                        x] = ui_plc_communication.plc_control_class.read_current_values_plc(x)
                    time.sleep(0.15)

                try:
                    self.machine_flow.gripper_act_position_value.setText(
                        f"{self.diagnostic_get_current_value['Gripper']}")
                    ui.gripper_act_current_value = float(self.diagnostic_get_current_value['Gripper'])

                    self.machine_flow.slider_act_position_value.setText(
                        f"{self.diagnostic_get_current_value['Slider']}")
                    ui.slider_act_current_value = float(self.diagnostic_get_current_value['Slider'])

                    if self.diagnostic_get_current_value['Gluing_x1'] == "00.013":
                        self.diagnostic_get_current_value['Gluing_x1'] = 0

                    self.machine_flow.gluing_x1_act_position_value.setText(
                        f"{self.diagnostic_get_current_value['Gluing_x1']}")
                    ui.gluing_x1_act_current_value = float(self.diagnostic_get_current_value['Gluing_x1'])

                    if self.diagnostic_get_current_value['Gluing_x2'] == "00.013":
                        self.diagnostic_get_current_value['Gluing_x2'] = 0

                    self.machine_flow.gluing_x2_act_position_value.setText(
                        f"{self.diagnostic_get_current_value['Gluing_x2']}")
                    ui.gluing_x2_act_current_value = float(self.diagnostic_get_current_value['Gluing_x2'])

                    if self.diagnostic_get_current_value['Gluing_y'] == "00.013":
                        self.diagnostic_get_current_value['Gluing_y'] = 0

                    self.machine_flow.gluing_y_act_position_value.setText(
                        f"{self.diagnostic_get_current_value['Gluing_y']}")
                    ui.gluing_y_act_current_value = float(self.diagnostic_get_current_value['Gluing_y'])

                except Exception as e:
                    logger.error(f"Error occurred in get the current value of Plc: {e}")

                try:
                    read_actuator = ui_plc_communication.modbus_class.read_actuator_current_position(slave_id=1)
                    if read_actuator != "Unable to read actuator":
                        self.machine_flow.y_axis_act_position_value.setText(f"{read_actuator}")
                        self.y_act_current_value = read_actuator
                    else:
                        self.msg_box_call("Alert", "Unable to read actuator", "Critical")
                        return

                    read_actuator = ui_plc_communication.modbus_class.read_actuator_current_position(slave_id=2)
                    if read_actuator != "Unable to read actuator":
                        self.machine_flow.light_panel_act_position_value.setText(f"{read_actuator}")
                        self.relay_z_act_current_value = read_actuator
                    else:
                        self.msg_box_call("Alert", "Unable to read actuator", "Critical")
                        return
                    read_actuator = ui_plc_communication.modbus_class.read_actuator_current_position(slave_id=3)
                    if read_actuator != "Unable to read actuator":
                        self.machine_flow.gd_z_axis_act_position_value.setText(f"{read_actuator}")
                        self.gluing_z_act_current_value = read_actuator
                    else:
                        self.msg_box_call("Alert", "Unable to read actuator", "Critical")
                        return
                    read_actuator = ui_plc_communication.modbus_class.read_actuator_current_position(slave_id=4)
                    if read_actuator != "Unable to read actuator":
                        self.machine_flow.uv_z_axis_act_position_value.setText(f"{read_actuator}")
                        self.curing_z_act_current_value = read_actuator
                    else:
                        self.msg_box_call("Alert", "Unable to read actuator", "Critical")
                        return
                    read_actuator = ui_plc_communication.modbus_class.read_actuator_current_position(slave_id=5)
                    if read_actuator != "Unable to read actuator":
                        self.machine_flow.x_axis_act_position_value.setText(f"{read_actuator}")
                        self.x_act_current_value = read_actuator
                    else:
                        self.msg_box_call("Alert", "Unable to read actuator", "Critical")
                        return

                except Exception as e:
                    logger.error(f"Error occurred in get the current value of Actuator: {e}")

                self.identify_btn = None
                self.machine_flow.gripper_open_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='gripper open'))
                self.machine_flow.gripper_close_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='gripper close'))
                self.machine_flow.gripper_homing_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text="Gripper homing"))
                self.machine_flow.slider_up_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='slider up'))
                self.machine_flow.slider_down_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='slider down'))
                self.machine_flow.slider_homing_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text="Slider homing"))
                self.machine_flow.y_axis_forward_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='y-axis forward'))
                self.machine_flow.y_axis_reverse_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='y-axis reverse'))
                self.machine_flow.y_axis_homing_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text="Y-axis homing diagnostic"))
                self.machine_flow.x_axis_forward_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='x-axis forward'))
                self.machine_flow.x_axis_reverse_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='x-axis reverse'))
                self.machine_flow.x_axis_homing_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text="X-axis homing diagnostic"))
                self.machine_flow.front_door_open_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='front door open diagnostic'))
                self.machine_flow.front_door_close_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='front door close diagnostic'))
                self.machine_flow.roller_clock_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='clockwise btn'))
                self.machine_flow.roller_anticlock_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='anti-clockwise btn'))
                self.machine_flow.loading_save_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='loading save btn'))

                self.machine_flow.light_panel_up_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='light panel up'))
                self.machine_flow.light_panel_down_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='light panel down'))
                self.machine_flow.light_panel_homing_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text="Relay Z-axis homing diagnostic"))
                self.machine_flow.light_panel_intensity_ok_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text="Relay intensity"))
                self.machine_flow.focusing_save_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='focusing save btn'))

                self.machine_flow.gd_z_axis_up_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='Gluing z-axis up'))
                self.machine_flow.gd_z_axis_down_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='Gluing z-axis down'))
                self.machine_flow.gd_z_axis_homing_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text="Gluing Z-axis homing diagnostic"))
                self.machine_flow.gluing_x1_up_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='Gluing x1 inside'))
                self.machine_flow.gluing_x1_down_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='Gluing x1 outside'))
                self.machine_flow.gluing_x2_up_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='Gluing x2 inside'))
                self.machine_flow.gluing_x2_down_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='Gluing x2 outside'))
                self.machine_flow.gluing_y_up_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='Gluing y inside'))
                self.machine_flow.gluing_y_down_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='Gluing y outside'))
                self.machine_flow.glue_purge_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text="Glue purge"))
                self.machine_flow.gluing_homing_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text="Gluing homing"))
                self.machine_flow.gluing_save_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='gluing save btn'))

                self.machine_flow.uv_z_axis_up_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='curing z-axis up'))
                self.machine_flow.uv_z_axis_down_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='curing z-axis down'))
                self.machine_flow.uv_z_axis_homing_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text="Curing Z-axis homing diagnostic"))
                self.machine_flow.uv_door_cylinder_open_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='curing door open diagnostic'))
                self.machine_flow.uv_door_cylinder_close_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='curing door close diagnostic'))
                self.machine_flow.uv_curing_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text="Uv curing diagnostic"))
                self.machine_flow.curing_save_btn.clicked.connect(
                    lambda: self.check_diagnostic_control(text='curing save btn'))
                self.diagnostics_clicked = True
                self.machine_flow.diagnostic_dialog.exec()

            elif self.machine_cntrl_btn.machine_menu.sender().text() == 'Bypass screen':
                logger.info('Bypass screen option is clicked')
                self.machine_flow.machine_sensor_control_dialog()
                self.machine_flow.machine_sensor_cntrl_btn_update.clicked.connect(
                    lambda: self.find_refresh_button("Bypass Screen"))
                self.machine_flow.machine_sensor_cntrl_btn_dclose.clicked.connect(self.close_dialog)
                values_dict = self.read_machine_control_xl(option="Bypass")
                checkboxes = [self.machine_flow.right_door_toggle, self.machine_flow.left_door_toggle,
                              self.machine_flow.front_door_open_toggle, self.machine_flow.front_door_close_toggle,
                              self.machine_flow.product_present_toggle, self.machine_flow.gd_left_open_toggle,
                              self.machine_flow.gd_left_close_toggle, self.machine_flow.gd_right_open_toggle,
                              self.machine_flow.gd_right_close_toggle, self.machine_flow.gluing_motor_alarm_toggle,
                              self.machine_flow.uv_door_cylinder_open_toggle,
                              self.machine_flow.uv_door_cylinder_close_toggle]
                for x, y in zip(values_dict.values(), checkboxes):
                    y.setChecked(bool(x[0]))
                self.machine_flow.machine_sensor_dialog.exec()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at machine_control_btn function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def check_diagnostic_control(self, text):
        try:
            """
               This method is used to verify the negative cases and store the correct values for diagnostic page.
               param lists: datatype is str and text is which button is pressed.
               return: None
            """
            if self.identify_btn is None:
                if text == 'gripper open':
                    if self.machine_flow.gripper_position_lnedt.text() != "" and \
                            (self.machine_flow.gripper_low_radioButton.isChecked() or
                             self.machine_flow.gripper_min_radioButton.isChecked() or
                             self.machine_flow.gripper_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return

                    if (self.machine_flow.gripper_none_radioButton.isChecked() and
                            self.machine_flow.gripper_position_lnedt.text() == ""):
                        self.msg_box_call("Warning", "Please select a valid option or enter the value for gripper",
                                          "Critical")
                        return

                    if self.machine_flow.gripper_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gripper Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.gripper_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gripper Max.distance value should not be empty",
                                          "Critical")
                        return

                    elif self.machine_flow.gripper_position_lnedt.text() == "":
                        if self.machine_flow.gripper_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 0.5
                        elif self.machine_flow.gripper_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 3
                        elif self.machine_flow.gripper_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 5
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:

                        self.identify_btn = 'gripper manual open'
                        self.value_to_move = float(self.machine_flow.gripper_position_lnedt.text())

                elif text == 'gripper close':
                    if self.machine_flow.gripper_position_lnedt.text() != "" and \
                            (self.machine_flow.gripper_low_radioButton.isChecked() or
                             self.machine_flow.gripper_min_radioButton.isChecked() or
                             self.machine_flow.gripper_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.gripper_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gripper Min.distance value should not be empty",
                                          "Critical")
                        return

                    if (self.machine_flow.gripper_none_radioButton.isChecked() and
                            self.machine_flow.gripper_position_lnedt.text() == ""):
                        self.msg_box_call("Warning", "Please select a valid option or enter the value for gripper",
                                          "Critical")
                        return

                    if self.machine_flow.gripper_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gripper Max.distance value should not be empty",
                                          "Critical")
                        return
                    elif self.machine_flow.gripper_position_lnedt.text() == "":
                        if self.machine_flow.gripper_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 0.5
                        elif self.machine_flow.gripper_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 3
                        elif self.machine_flow.gripper_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 5
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = "gripper manual close"
                        self.value_to_move = float(self.machine_flow.gripper_position_lnedt.text())

                elif text == "Slider homing" or text == "Gripper homing":
                    self.identify_btn = text
                    self.value_to_move = 0

                elif text == 'slider up':
                    if self.machine_flow.slider_position_lnedt.text() != "" and \
                            (self.machine_flow.slider_low_radioButton.isChecked() or
                             self.machine_flow.slider_min_radioButton.isChecked() or
                             self.machine_flow.slider_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.slider_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Slider Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.slider_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Slider Max.distance value should not be empty",
                                          "Critical")
                        return

                    if (self.machine_flow.slider_none_radioButton.isChecked() and
                            self.machine_flow.slider_position_lnedt.text() == ""):
                        self.msg_box_call("Warning", "Please select a valid option or enter the value for slider",
                                          "Critical")
                        return

                    elif self.machine_flow.slider_position_lnedt.text() == "":
                        if self.machine_flow.slider_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 0.5
                        elif self.machine_flow.slider_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 3
                        elif self.machine_flow.slider_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 5
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'slider manual up'
                        self.value_to_move = float(self.machine_flow.slider_position_lnedt.text())

                elif text == 'slider down':
                    if self.machine_flow.slider_position_lnedt.text() != "" and \
                            (self.machine_flow.slider_low_radioButton.isChecked() or
                             self.machine_flow.slider_min_radioButton.isChecked() or
                             self.machine_flow.slider_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.slider_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Slider Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.slider_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Slider Max.distance value should not be empty",
                                          "Critical")
                        return

                    if (self.machine_flow.slider_none_radioButton.isChecked() and
                            self.machine_flow.slider_position_lnedt.text() == ""):
                        self.msg_box_call("Warning", "Please select a valid option or enter the value for slider",
                                          "Critical")
                        return

                    elif self.machine_flow.slider_position_lnedt.text() == "":
                        if self.machine_flow.slider_low_radioButton.isChecked():
                            self.identify_btn = text
                            if self.slider_act_current_value > 0.5:
                                self.value_to_move = 0.5
                        elif self.machine_flow.slider_min_radioButton.isChecked():
                            self.identify_btn = text
                            if self.slider_act_current_value > 3:
                                self.value_to_move = 3
                        elif self.machine_flow.slider_max_radioButton.isChecked():
                            self.identify_btn = text
                            if self.slider_act_current_value > 5:
                                self.value_to_move = 5
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'slider manual down'
                        self.value_to_move = float(self.machine_flow.slider_position_lnedt.text())

                elif text == 'y-axis forward':
                    if self.machine_flow.y_axis_move_position_lndt.text() != "" and \
                            (self.machine_flow.y_axis_low_radioButton.isChecked() or
                             self.machine_flow.y_axis_min_radioButton.isChecked() or
                             self.machine_flow.y_axis_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.y_axis_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Y-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.y_axis_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Y-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.y_axis_none_radioButton.isChecked() and
                            self.machine_flow.y_axis_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning", "Please select a valid option or enter the value for y-axis",
                                          "Critical")
                        return
                    elif self.machine_flow.y_axis_move_position_lndt.text() == "":
                        if self.machine_flow.y_axis_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [5]
                        elif self.machine_flow.y_axis_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [25]
                        elif self.machine_flow.y_axis_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [50]
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'y-axis manual forward'
                        self.value_to_move = [float(self.machine_flow.y_axis_move_position_lndt.text())]

                    if self.machine_flow.y_axis_speed_lnedt.text() == "":
                        self.value_to_move.append(15000)
                    else:
                        if float(self.machine_flow.y_axis_speed_lnedt.text()) > 15000:
                            self.msg_box_call("Warning", "The maximum speed for y-axis movement is 15000.",
                                              "Critical")
                            return
                        self.value_to_move.append(int(self.machine_flow.y_axis_speed_lnedt.text()))

                elif text == 'y-axis reverse':
                    if self.machine_flow.y_axis_move_position_lndt.text() != "" and \
                            (self.machine_flow.y_axis_low_radioButton.isChecked() or
                             self.machine_flow.y_axis_min_radioButton.isChecked() or
                             self.machine_flow.y_axis_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.y_axis_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Y-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.y_axis_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Y-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.y_axis_none_radioButton.isChecked() and
                            self.machine_flow.y_axis_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning", "Please select a valid option or enter the value for y-axis",
                                          "Critical")
                        return
                    elif self.machine_flow.y_axis_move_position_lndt.text() == "":
                        if self.machine_flow.y_axis_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [5]
                        elif self.machine_flow.y_axis_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [25]
                        elif self.machine_flow.y_axis_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [50]
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'y-axis manual forward'
                        self.value_to_move = [float(self.machine_flow.y_axis_move_position_lndt.text())]

                    if self.machine_flow.y_axis_speed_lnedt.text() == "":
                        self.value_to_move.append(15000)
                    else:
                        if float(self.machine_flow.y_axis_speed_lnedt.text()) > 15000:
                            self.msg_box_call("Warning", "The maximum speed for y-axis movement is 15000.",
                                              "Critical")
                            return
                        self.value_to_move.append(int(self.machine_flow.y_axis_speed_lnedt.text()))

                elif text == "X-axis homing diagnostic":
                    self.identify_btn = text
                    self.value_to_move = 0

                elif text == "Y-axis homing diagnostic":
                    self.identify_btn = text
                    self.value_to_move = 0

                elif text == 'x-axis forward':
                    if self.machine_flow.x_axis_move_position_lndt.text() != "" and \
                            (self.machine_flow.x_axis_low_radioButton.isChecked() or
                             self.machine_flow.x_axis_min_radioButton.isChecked() or
                             self.machine_flow.x_axis_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.x_axis_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "X-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.x_axis_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "X-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.x_axis_none_radioButton.isChecked() and
                            self.machine_flow.x_axis_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning", "Please select a valid option or enter the value for x-axis",
                                          "Critical")
                        return
                    elif self.machine_flow.x_axis_move_position_lndt.text() == "":
                        if self.machine_flow.x_axis_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [0.5]
                        elif self.machine_flow.x_axis_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [3]
                        elif self.machine_flow.x_axis_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [5]
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'x-axis manual forward'
                        self.value_to_move = [float(self.machine_flow.x_axis_move_position_lndt.text())]

                    if self.machine_flow.x_axis_speed_lnedt.text() == "":
                        self.value_to_move.append(2000)
                    else:
                        if float(self.machine_flow.x_axis_speed_lnedt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed for x-axis movement is 2000.",
                                              "Critical")
                            return
                        self.value_to_move.append(int(self.machine_flow.x_axis_speed_lnedt.text()))

                elif text == 'x-axis reverse':
                    if self.machine_flow.x_axis_move_position_lndt.text() != "" and \
                            (self.machine_flow.x_axis_low_radioButton.isChecked() or
                             self.machine_flow.x_axis_min_radioButton.isChecked() or
                             self.machine_flow.x_axis_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.x_axis_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "X-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.x_axis_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "X-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.x_axis_none_radioButton.isChecked() and
                            self.machine_flow.x_axis_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning", "Please select a valid option or enter the value for x-axis",
                                          "Critical")
                        return
                    elif self.machine_flow.x_axis_move_position_lndt.text() == "":
                        if self.machine_flow.x_axis_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [0.5]
                        elif self.machine_flow.x_axis_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [3]
                        elif self.machine_flow.x_axis_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [5]
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'x-axis manual forward'
                        self.value_to_move = [float(self.machine_flow.x_axis_move_position_lndt.text())]

                    if self.machine_flow.x_axis_speed_lnedt.text() == "":
                        self.value_to_move.append(2000)
                    else:
                        if float(self.machine_flow.x_axis_speed_lnedt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed for x-axis movement is 2000.",
                                              "Critical")
                            return
                        self.value_to_move.append(int(self.machine_flow.x_axis_speed_lnedt.text()))

                elif text == 'clockwise btn':
                    if self.machine_flow.roller_speed_lnedt.text() == "":
                        self.msg_box_call("Warning", "Please enter a value.", "Critical")
                        return

                    self.identify_btn = 'clockwise btn'
                    self.value_to_move = float(self.machine_flow.roller_speed_lnedt.text())

                elif text == 'anti-clockwise btn':
                    if self.machine_flow.roller_speed_lnedt.text() == "":
                        self.msg_box_call("Warning", "Please enter a value.", "Critical")
                        return

                    self.identify_btn = 'anti-clockwise btn'
                    self.value_to_move = float(self.machine_flow.roller_speed_lnedt.text())

                elif text == "front door close diagnostic":
                    self.identify_btn = text
                    self.value_to_move = 0

                elif text == "front door open diagnostic":
                    self.identify_btn = text
                    self.value_to_move = 0


                elif text == "loading save btn":
                    try:
                        if self.machine_flow.gripper_min_distance_lnedt.text() == "":
                            self.msg_box_call("Warning", "Gripper Min.distance value should not be empty",
                                              "Critical")
                            return
                        if self.machine_flow.gripper_max_distance_lnedt.text() == "":
                            self.msg_box_call("Warning", "Gripper Max.distance value should not be empty",
                                              "Critical")
                            return
                        if self.machine_flow.slider_min_distance_lnedt.text() == "":
                            self.msg_box_call("Warning", "Slider Min.distance value should not be empty",
                                              "Critical")
                            return
                        if self.machine_flow.slider_max_distance_lnedt.text() == "":
                            self.msg_box_call("Warning", "Slider Max.distance value should not be empty",
                                              "Critical")
                            return
                        if self.machine_flow.y_axis_min_distance_lnedt.text() == "":
                            self.msg_box_call("Warning", "Y-axis Min.distance value should not be empty",
                                              "Critical")
                            return
                        if self.machine_flow.y_axis_max_distance_lnedt.text() == "":
                            self.msg_box_call("Warning", "Y-axis Max.distance value should not be empty",
                                              "Critical")
                            return
                        if self.machine_flow.x_axis_min_distance_lnedt.text() == "":
                            self.msg_box_call("Warning", "X-axis Min.distance value should not be empty",
                                              "Critical")
                            return
                        if self.machine_flow.x_axis_max_distance_lnedt.text() == "":
                            self.msg_box_call("Warning", "X-axis Max.distance value should not be empty",
                                              "Critical")
                            return
                        dataframe = openpyxl.load_workbook(r".\media\machine control bypass file.xlsx")
                        dataframe1 = dataframe.worksheets[0]
                        g = {'Gripper': [float(self.machine_flow.gripper_min_distance_lnedt.text()),
                                         float(self.machine_flow.gripper_max_distance_lnedt.text())],
                             'Slider': [float(self.machine_flow.slider_min_distance_lnedt.text()),
                                        float(self.machine_flow.slider_max_distance_lnedt.text())],
                             'Y-actuator': [float(self.machine_flow.y_axis_min_distance_lnedt.text()),
                                            float(self.machine_flow.y_axis_max_distance_lnedt.text())],
                             'X-actuator': [float(self.machine_flow.x_axis_min_distance_lnedt.text()),
                                            float(self.machine_flow.x_axis_max_distance_lnedt.text())]}
                        for i in range(2, 4):
                            for x, y in enumerate(g.values(), start=2):
                                dataframe1.cell(row=x, column=i).value = y[i - 2]
                        dataframe.save(r".\media\machine control bypass file.xlsx")
                        self.msg_box_call("Success",
                                          "Loading station details saved successfully", "Information")

                    except PermissionError:
                        self.msg_box_call("Permission Denied!",
                                          "Unable to access the excel file \"machine control bypass file.xlsx\". "
                                          "Kindly close the file and "
                                          "continue with validation <br><br> <b>Note:</b> Hence validated data will "
                                          "not be saved properly", "Critical")
                        return

                elif text == 'light panel up':
                    if self.machine_flow.light_panel_move_position_lndt.text() != "" and \
                            (self.machine_flow.light_panel_low_radioButton.isChecked() or
                             self.machine_flow.light_panel_min_radioButton.isChecked() or
                             self.machine_flow.light_panel_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.light_panel_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Light panel Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.light_panel_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Light panel Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.light_panel_none_radioButton.isChecked() and
                            self.machine_flow.light_panel_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning", "Please select a valid option or enter the value for relay z-axis",
                                          "Critical")
                        return
                    elif self.machine_flow.light_panel_move_position_lndt.text() == "":
                        if self.machine_flow.light_panel_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [5]
                        elif self.machine_flow.light_panel_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [25]
                        elif self.machine_flow.light_panel_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [50]
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'light panel manual up'
                        self.value_to_move = [float(self.machine_flow.light_panel_move_position_lndt.text())]

                    if self.machine_flow.light_panel_speed_lnedt.text() == "":
                        self.value_to_move.append(2000)
                    else:
                        if float(self.machine_flow.light_panel_speed_lnedt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed for z-axis movement is 2000.",
                                              "Critical")
                            return
                        self.value_to_move.append(int(self.machine_flow.light_panel_speed_lnedt.text()))

                elif text == 'light panel down':
                    if self.machine_flow.light_panel_move_position_lndt.text() != "" and \
                            (self.machine_flow.light_panel_low_radioButton.isChecked() or
                             self.machine_flow.light_panel_min_radioButton.isChecked() or
                             self.machine_flow.light_panel_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.light_panel_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Light panel Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.light_panel_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Light panel Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.light_panel_none_radioButton.isChecked() and
                            self.machine_flow.light_panel_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning", "Please select a valid option or enter the value for relay z-axis",
                                          "Critical")
                        return
                    elif self.machine_flow.light_panel_move_position_lndt.text() == "":
                        if self.machine_flow.light_panel_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [5]
                        elif self.machine_flow.light_panel_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [25]
                        elif self.machine_flow.light_panel_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [50]
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'light panel manual down'
                        self.value_to_move = [float(self.machine_flow.light_panel_move_position_lndt.text())]

                    if self.machine_flow.light_panel_speed_lnedt.text() == "":
                        self.value_to_move.append(2000)
                    else:
                        if float(self.machine_flow.light_panel_speed_lnedt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed for z-axis movement is 2000.",
                                              "Critical")
                            return
                        self.value_to_move.append(int(self.machine_flow.light_panel_speed_lnedt.text()))

                elif text == "Relay Z-axis homing diagnostic":
                    self.identify_btn = text
                    self.value_to_move = 0

                elif text == "Relay intensity":
                    if self.machine_flow.light_panel_intensity_lnedt.text() == "":
                        self.msg_box_call("Warning", "light panel intensity value should not be empty",
                                          "Critical")
                        return
                    if self.machine_flow.light_panel_intensity_lnedt.text() != "" and "".join(list(
                            str(self.machine_flow.light_panel_intensity_lnedt.text()).split("."))).isdigit():
                        if int(self.machine_flow.light_panel_intensity_lnedt.text()) > 1024:
                            self.msg_box_call("Warning", "The maximum lux value is 1024", "Warning")
                            return
                        self.identify_btn = text
                        self.value_to_move = int(self.machine_flow.light_panel_intensity_lnedt.text())

                elif text == "focusing save btn":
                    if self.machine_flow.light_panel_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Z-axis Min.distance value should not be empty",
                                          "Critical")
                        return
                    if self.machine_flow.light_panel_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Z-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    try:
                        dataframe = openpyxl.load_workbook(r".\media\machine control bypass file.xlsx")
                        dataframe1 = dataframe.worksheets[0]
                        dataframe1.cell(row=6, column=2).value = float(
                            self.machine_flow.light_panel_min_distance_lnedt.text())
                        dataframe1.cell(row=6, column=3).value = float(
                            self.machine_flow.light_panel_max_distance_lnedt.text())

                        dataframe.save(r".\media\machine control bypass file.xlsx")
                        self.msg_box_call("Success",
                                          "Relay station details saved successfully", "Information")

                    except PermissionError:
                        self.msg_box_call("Permission Denied!",
                                          "Unable to access the excel file \"machine control bypass file.xlsx\". "
                                          "Kindly close the file and "
                                          "continue with validation <br><br> <b>Note:</b> Hence validated data will "
                                          "not be saved properly", "Critical")
                        return

                elif text == 'Gluing z-axis up':
                    if self.machine_flow.gd_z_axis_move_position_lndt.text() != "" and \
                            (self.machine_flow.gd_z_axis_low_radioButton.isChecked() or
                             self.machine_flow.gd_z_axis_min_radioButton.isChecked() or
                             self.machine_flow.gd_z_axis_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.gd_z_axis_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing Z-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.gd_z_axis_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing Z-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.gd_z_axis_none_radioButton.isChecked() and
                            self.machine_flow.gd_z_axis_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning",
                                          "Please select a valid option or enter the value for gluing z-axis",
                                          "Critical")
                        return
                    elif self.machine_flow.gd_z_axis_move_position_lndt.text() == "":
                        if self.machine_flow.gd_z_axis_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [5]
                        elif self.machine_flow.gd_z_axis_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [10]
                        elif self.machine_flow.gd_z_axis_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [20]
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.",
                                              "Critical")
                            return
                    else:
                        self.identify_btn = 'Gluing z-axis manual up'
                        self.value_to_move = [float(self.machine_flow.gd_z_axis_move_position_lndt.text())]

                    if self.machine_flow.gd_z_axis_speed_lnedt.text() == "":
                        self.value_to_move.append(2000)
                    else:
                        if float(self.machine_flow.gd_z_axis_speed_lnedt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed for z-axis movement is 2000.",
                                              "Critical")
                            return
                        self.value_to_move.append(int(self.machine_flow.gd_z_axis_speed_lnedt.text()))

                elif text == 'Gluing z-axis down':
                    if self.machine_flow.gd_z_axis_move_position_lndt.text() != "" and \
                            (self.machine_flow.gd_z_axis_low_radioButton.isChecked() or
                             self.machine_flow.gd_z_axis_min_radioButton.isChecked() or
                             self.machine_flow.gd_z_axis_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.gd_z_axis_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing Z-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.gd_z_axis_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing Z-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.gd_z_axis_none_radioButton.isChecked() and
                            self.machine_flow.gd_z_axis_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning",
                                          "Please select a valid option or enter the value for gluing z-axis",
                                          "Critical")
                        return
                    elif self.machine_flow.gd_z_axis_move_position_lndt.text() == "":
                        if self.machine_flow.gd_z_axis_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [5]
                        elif self.machine_flow.gd_z_axis_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [10]
                        elif self.machine_flow.gd_z_axis_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [20]
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'Gluing z-axis manual down'
                        self.value_to_move = [float(self.machine_flow.gd_z_axis_move_position_lndt.text())]

                    if self.machine_flow.gd_z_axis_speed_lnedt.text() == "":
                        self.value_to_move.append(2000)
                    else:
                        if float(self.machine_flow.gd_z_axis_speed_lnedt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed for z-axis movement is 2000.",
                                              "Critical")
                            return
                        self.value_to_move.append(int(self.machine_flow.gd_z_axis_speed_lnedt.text()))

                elif text == "Gluing Z-axis homing diagnostic":
                    self.identify_btn = text
                    self.value_to_move = 0

                elif text == 'Gluing x1 inside':
                    if self.machine_flow.gluing_x1_move_position_lndt.text() != "" and \
                            (self.machine_flow.gluing_x1_low_radioButton.isChecked() or
                             self.machine_flow.gluing_x1_min_radioButton.isChecked() or
                             self.machine_flow.gluing_x1_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio"
                                                     "button.", "Critical")
                        return
                    if self.machine_flow.gluing_x1_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing X1-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.gluing_x1_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing X1-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.gluing_x1_none_radioButton.isChecked() and
                            self.machine_flow.gluing_x1_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning",
                                          "Please select a valid option or enter the value for gluing x1 actuator",
                                          "Critical")
                        return
                    elif self.machine_flow.gluing_x1_move_position_lndt.text() == "":
                        if self.machine_flow.gluing_x1_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 0.5
                        elif self.machine_flow.gluing_x1_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 3
                        elif self.machine_flow.gluing_x1_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 5
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'Gluing x1 manual inside'
                        self.value_to_move = [float(self.machine_flow.gluing_x1_move_position_lndt.text())]

                    if self.machine_flow.gluing_x1_speed_lnedt.text() == "":
                        self.value_to_move.append(500)
                    else:
                        if float(self.machine_flow.gluing_x1_speed_lnedt.text()) > 1000:
                            self.msg_box_call("Warning", "The maximum speed for glue movement is 1000.",
                                              "Critical")
                            return
                        self.value_to_move.append(float(self.machine_flow.gluing_x1_speed_lnedt.text()))

                elif text == 'Gluing x1 outside':
                    if self.machine_flow.gluing_x1_move_position_lndt.text() != "" and \
                            (self.machine_flow.gluing_x1_low_radioButton.isChecked() or
                             self.machine_flow.gluing_x1_min_radioButton.isChecked() or
                             self.machine_flow.gluing_x1_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.gluing_x1_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing X1-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.gluing_x1_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing X1-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.gluing_x1_none_radioButton.isChecked() and
                            self.machine_flow.gluing_x1_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning",
                                          "Please select a valid option or enter the value for gluing x1 actuator",
                                          "Critical")
                        return
                    elif self.machine_flow.gluing_x1_move_position_lndt.text() == "":
                        if self.machine_flow.gluing_x1_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 0.5
                        elif self.machine_flow.gluing_x1_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 3
                        elif self.machine_flow.gluing_x1_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 5
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'Gluing x1 manual outside'
                        self.value_to_move = [float(self.machine_flow.gluing_x1_move_position_lndt.text())]

                    if self.machine_flow.gluing_x1_speed_lnedt.text() == "":
                        self.value_to_move.append(500)
                    else:
                        if float(self.machine_flow.gluing_x1_speed_lnedt.text()) > 1000:
                            self.msg_box_call("Warning", "The maximum speed for glue movement is 1000.", "Critical")
                            return
                        self.value_to_move.append(float(self.machine_flow.gluing_x1_speed_lnedt.text()))

                elif text == 'Gluing x2 inside':
                    if self.machine_flow.gluing_x2_move_position_lndt.text() != "" and \
                            (self.machine_flow.gluing_x2_low_radioButton.isChecked() or
                             self.machine_flow.gluing_x2_min_radioButton.isChecked() or
                             self.machine_flow.gluing_x2_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.gluing_x2_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing X2-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.gluing_x2_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing X2-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.gluing_x2_none_radioButton.isChecked() and
                            self.machine_flow.gluing_x2_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning",
                                          "Please select a valid option or enter the value for gluing x2 actuator",
                                          "Critical")
                        return
                    elif self.machine_flow.gluing_x2_move_position_lndt.text() == "":
                        if self.machine_flow.gluing_x2_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 0.5
                        elif self.machine_flow.gluing_x2_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 3
                        elif self.machine_flow.gluing_x2_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 5
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'Gluing x2 manual inside'
                        self.value_to_move = [float(self.machine_flow.gluing_x2_move_position_lndt.text())]

                    if self.machine_flow.gluing_x2_speed_lnedt.text() == "":
                        self.value_to_move.append(500)
                    else:
                        if float(self.machine_flow.gluing_x2_speed_lnedt.text()) > 1000:
                            self.msg_box_call("Warning", "The maximum speed for glue movement is 1000.", "Critical")
                            return
                        self.value_to_move.append(float(self.machine_flow.gluing_x2_speed_lnedt.text()))

                elif text == 'Gluing x2 outside':
                    if self.machine_flow.gluing_x2_move_position_lndt.text() != "" and \
                            (self.machine_flow.gluing_x2_low_radioButton.isChecked() or
                             self.machine_flow.gluing_x2_min_radioButton.isChecked() or
                             self.machine_flow.gluing_x2_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.gluing_x2_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing X2-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.gluing_x2_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing X2-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.gluing_x2_none_radioButton.isChecked() and
                            self.machine_flow.gluing_x2_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning",
                                          "Please select a valid option or enter the value for gluing x2 actuator",
                                          "Critical")
                        return
                    if self.machine_flow.gluing_x2_move_position_lndt.text() == "":
                        if self.machine_flow.gluing_x2_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 0.5
                        elif self.machine_flow.gluing_x2_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 3
                        elif self.machine_flow.gluing_x2_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 5
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'Gluing x2 manual outside'
                        self.value_to_move = [float(self.machine_flow.gluing_x2_move_position_lndt.text())]

                    if self.machine_flow.gluing_x2_speed_lnedt.text() == "":
                        self.value_to_move.append(500)
                    else:
                        if float(self.machine_flow.gluing_x2_speed_lnedt.text()) > 1000:
                            self.msg_box_call("Warning", "The maximum speed for glue movement is 1000.", "Critical")
                            return
                        self.value_to_move.append(float(self.machine_flow.gluing_x2_speed_lnedt.text()))

                elif text == 'Gluing y inside':
                    if self.machine_flow.gluing_y_move_position_lndt.text() != "" and \
                            (self.machine_flow.gluing_y_low_radioButton.isChecked() or
                             self.machine_flow.gluing_y_min_radioButton.isChecked() or
                             self.machine_flow.gluing_y_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.gluing_y_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing Y-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.gluing_y_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing Y-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.gluing_y_none_radioButton.isChecked() and
                            self.machine_flow.gluing_y_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning",
                                          "Please select a valid option or enter the value for gluing y actuator",
                                          "Critical")
                        return
                    elif self.machine_flow.gluing_y_move_position_lndt.text() == "":
                        if self.machine_flow.gluing_y_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 0.5
                        elif self.machine_flow.gluing_y_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 3
                        elif self.machine_flow.gluing_y_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 5
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'Gluing y manual inside'
                        self.value_to_move = [float(self.machine_flow.gluing_y_move_position_lndt.text())]

                    if self.machine_flow.gluing_y_speed_lnedt.text() == "":
                        self.value_to_move.append(500)
                    else:
                        if float(self.machine_flow.gluing_y_speed_lnedt.text()) > 1000:
                            self.msg_box_call("Warning", "The maximum speed for glue movement is 1000.", "Critical")
                            return
                        self.value_to_move.append(float(self.machine_flow.gluing_y_speed_lnedt.text()))

                elif text == 'Gluing y outside':
                    if self.machine_flow.gluing_y_move_position_lndt.text() != "" and \
                            (self.machine_flow.gluing_y_low_radioButton.isChecked() or
                             self.machine_flow.gluing_y_min_radioButton.isChecked() or
                             self.machine_flow.gluing_y_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.gluing_y_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing Y-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.gluing_y_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Gluing Y-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.gluing_y_none_radioButton.isChecked() and
                            self.machine_flow.gluing_y_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning",
                                          "Please select a valid option or enter the value for gluing y actuator",
                                          "Critical")
                        return
                    elif self.machine_flow.gluing_y_move_position_lndt.text() == "":
                        if self.machine_flow.gluing_y_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 0.5
                        elif self.machine_flow.gluing_y_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 3
                        elif self.machine_flow.gluing_y_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = 5
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'Gluing y manual outside'
                        self.value_to_move = [float(self.machine_flow.gluing_y_move_position_lndt.text())]

                    if self.machine_flow.gluing_y_speed_lnedt.text() == "":
                        self.value_to_move.append(500)
                    else:
                        if float(self.machine_flow.gluing_y_speed_lnedt.text()) > 1000:
                            self.msg_box_call("Warning", "The maximum speed for glue movement is 1000.", "Critical")
                            return

                        self.value_to_move.append(float(self.machine_flow.gluing_y_speed_lnedt.text()))

                elif text == "Glue purge":
                    if float(self.machine_flow.gluing_purge_lnedt.text()) > 9.9:
                        self.msg_box_call("Warning", "The maximum time limit for glue purge is 9.9 seconds.",
                                          "Critical")
                        return
                    else:
                        self.identify_btn = text
                        self.value_to_move = float(self.machine_flow.gluing_purge_lnedt.text())

                elif text == "Gluing homing":
                    self.identify_btn = text
                    self.value_to_move = 0

                elif text == "gluing save btn":
                    if self.machine_flow.gd_z_axis_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Z-axis Min.distance value should not be empty",
                                          "Critical")
                        return
                    if self.machine_flow.gd_z_axis_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Z-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if self.machine_flow.gluing_x1_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "X1-axis Min.distance value should not be empty",
                                          "Critical")
                        return
                    if self.machine_flow.gluing_x1_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "X1-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if self.machine_flow.gluing_x2_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "X2-axis Min.distance value should not be empty",
                                          "Critical")
                        return
                    if self.machine_flow.gluing_x2_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "X2-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if self.machine_flow.gluing_y_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Y-axis Min.distance value should not be empty",
                                          "Critical")
                        return
                    if self.machine_flow.gluing_y_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Y-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    try:
                        dataframe = openpyxl.load_workbook(r".\media\machine control bypass file.xlsx")
                        dataframe1 = dataframe.worksheets[0]
                        g = {'Gluing Z-actuator': [float(self.machine_flow.gd_z_axis_max_distance_lnedt.text()),
                                                   float(self.machine_flow.gd_z_axis_min_distance_lnedt.text())],
                             'Gluing X1-actuator': [float(self.machine_flow.gluing_x1_min_distance_lnedt.text()),
                                                    float(self.machine_flow.gluing_x1_max_distance_lnedt.text())],
                             'Gluing X2-actuator': [float(self.machine_flow.gluing_x2_min_distance_lnedt.text()),
                                                    float(self.machine_flow.gluing_x2_max_distance_lnedt.text())],
                             'Gluing Y-actuator': [float(self.machine_flow.gluing_y_min_distance_lnedt.text()),
                                                   float(self.machine_flow.gluing_y_max_distance_lnedt.text())]}
                        for i in range(2, 4):
                            for x, y in enumerate(g.values(), start=7):
                                dataframe1.cell(row=x, column=i).value = y[i - 2]

                        dataframe.save(r".\media\machine control bypass file.xlsx")
                        self.msg_box_call("Success",
                                          "Gluing station details saved successfully", "Information")

                    except PermissionError:
                        self.msg_box_call("Permission Denied!",
                                          "Unable to access the excel file \"machine control bypass file.xlsx\". "
                                          "Kindly close the file and "
                                          "continue with validation <br><br> <b>Note:</b> Hence validated data will "
                                          "not be saved properly", "Critical")
                        return

                elif text == 'curing z-axis up':
                    if self.machine_flow.uv_z_axis_move_position_lndt.text() != "" and \
                            (self.machine_flow.uv_z_axis_low_radioButton.isChecked() or
                             self.machine_flow.uv_z_axis_min_radioButton.isChecked() or
                             self.machine_flow.uv_z_axis_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.uv_z_axis_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Curing Z-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.uv_z_axis_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Curing Z-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.uv_z_axis_none_radioButton.isChecked() and
                            self.machine_flow.uv_z_axis_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning",
                                          "Please select a valid option or enter the value for curing z-axis",
                                          "Critical")
                        return
                    elif self.machine_flow.uv_z_axis_move_position_lndt.text() == "":
                        if self.machine_flow.uv_z_axis_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [5]
                        elif self.machine_flow.uv_z_axis_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [10]
                        elif self.machine_flow.uv_z_axis_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [20]
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'curing z-axis manual up'
                        self.value_to_move = [float(self.machine_flow.uv_z_axis_move_position_lndt.text())]

                    if self.machine_flow.uv_z_axis_speed_lnedt.text() == "":
                        self.value_to_move.append(2000)
                    else:
                        if float(self.machine_flow.uv_z_axis_speed_lnedt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed for z-axis movement is 2000.",
                                              "Critical")
                            return
                        self.value_to_move.append(int(self.machine_flow.uv_z_axis_speed_lnedt.text()))

                elif text == 'curing z-axis down':
                    if self.machine_flow.uv_z_axis_move_position_lndt.text() != "" and \
                            (self.machine_flow.uv_z_axis_low_radioButton.isChecked() or
                             self.machine_flow.uv_z_axis_min_radioButton.isChecked() or
                             self.machine_flow.uv_z_axis_max_radioButton.isChecked()):
                        self.msg_box_call("Warning", "clear the value in the textbox or select None for the radio button.",
                                          "Critical")
                        return
                    if self.machine_flow.uv_z_axis_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Curing Z-axis Min.distance value should not be empty",
                                          "Critical")
                        return

                    if self.machine_flow.uv_z_axis_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Curing Z-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if (self.machine_flow.uv_z_axis_none_radioButton.isChecked() and
                            self.machine_flow.uv_z_axis_move_position_lndt.text() == ""):
                        self.msg_box_call("Warning",
                                          "Please select a valid option or enter the value for curing z-axis",
                                          "Critical")
                        return
                    elif self.machine_flow.uv_z_axis_move_position_lndt.text() == "":
                        if self.machine_flow.uv_z_axis_low_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [5]
                        elif self.machine_flow.uv_z_axis_min_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [10]
                        elif self.machine_flow.uv_z_axis_max_radioButton.isChecked():
                            self.identify_btn = text
                            self.value_to_move = [20]
                        else:
                            self.msg_box_call("Warning", "Please select a radio button or enter a value.", "Critical")
                            return
                    else:
                        self.identify_btn = 'curing z-axis manual down'
                        self.value_to_move = float(self.machine_flow.uv_z_axis_move_position_lndt.text())

                    if self.machine_flow.uv_z_axis_speed_lnedt.text() == "":
                        self.value_to_move.append(2000)
                    else:
                        if float(self.machine_flow.uv_z_axis_speed_lnedt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed for z-axis movement is 2000.",
                                              "Critical")
                            return
                        self.value_to_move.append(int(self.machine_flow.uv_z_axis_speed_lnedt.text()))

                elif text == "Curing Z-axis homing diagnostic":
                    self.identify_btn = text
                    self.value_to_move = 0

                elif text == "curing door close diagnostic":
                    self.identify_btn = text
                    self.value_to_move = 0

                elif text == "curing door open diagnostic":
                    self.identify_btn = text
                    self.value_to_move = 0

                elif text == "Uv curing diagnostic":
                    if self.machine_flow.uv_curing_time_lndt.text() == "":
                        self.msg_box_call("Warning", "Curing time should not be empty", "Critical")
                        return
                    elif self.machine_flow.uv_curing_intensity_lndt.text() == "":
                        self.msg_box_call("Warning", "Curing intensity should not be empty", "Critical")
                        return
                    else:
                        self.identify_btn = text
                        self.value_to_move = [int(self.machine_flow.uv_curing_time_lndt.text()),
                                              int(self.machine_flow.uv_curing_intensity_lndt.text())]

                elif text == "curing save btn":
                    if self.machine_flow.uv_z_axis_max_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Z-axis Max.distance value should not be empty",
                                          "Critical")
                        return
                    if self.machine_flow.uv_z_axis_min_distance_lnedt.text() == "":
                        self.msg_box_call("Warning", "Z-axis Min.distance value should not be empty",
                                          "Critical")
                        return
                    try:
                        dataframe = openpyxl.load_workbook(r".\media\machine control bypass file.xlsx")
                        dataframe1 = dataframe.worksheets[0]
                        dataframe1.cell(row=11, column=2).value = float(
                            self.machine_flow.uv_z_axis_min_distance_lnedt.text())
                        dataframe1.cell(row=11, column=3).value = float(
                            self.machine_flow.uv_z_axis_max_distance_lnedt.text())

                        dataframe.save(r".\media\machine control bypass file.xlsx")
                        self.msg_box_call("Success",
                                          "Curing station details saved successfully", "Information")

                    except PermissionError:
                        self.msg_box_call("Permission Denied!",
                                          "Unable to access the excel file \"machine control bypass file.xlsx\". "
                                          "Kindly close the file and "
                                          "continue with validation <br><br> <b>Note:</b> Hence validated data will "
                                          "not be saved properly", "Critical")
                        return

                self.diagnostic_thread_new()

            else:
                self.msg_box_call("Alert", "Movement is in progress", "Critical")
                return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at check_diagnostic_control function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def spinbox_clicked(self, text):
        try:
            """
               This method is used to verify the negative cases and store the correct values for create and edit recipes.
               param lists: datatype is str and text is which button is pressed.
               return: None
            """
            if self.recipe_btn_type is None:
                if text == "front door open":
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == "front door close":
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == "part_loading out":
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == "part_loading in":
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == "loading_init":
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == "loading_overall_homing":
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'loading x_axis_homing btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'loading y_axis_homing btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'loading_x_axis_run_btn':
                    if self.loading_x_axis_mini_lndt.text() != "" and "".join(
                            list(str(self.loading_x_axis_mini_lndt.text()).split("."))).isdigit():
                        if float(self.loading_x_axis_mini_lndt.text()) > float(
                                self.stored_values_dict['X-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the X-actuator "
                                                         f"is {self.stored_values_dict['X-actuator'][1]}.", "Warning")
                            return
                        value_to_move = [float(self.loading_x_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter x-axis value", "Warning")
                        return

                    if self.loading_x_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.loading_x_axis_speed_lndt.text()).split("."))).isdigit():
                        if int(self.loading_x_axis_speed_lndt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed of the X-actuator is 2000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.loading_x_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(2000)

                elif text == 'loading_y_axis_run_btn':
                    if self.loading_y_axis_mini_lndt.text() != "" and "".join(list(
                            str(self.loading_y_axis_mini_lndt.text()).split("."))).isdigit():
                        if float(self.loading_y_axis_mini_lndt.text()) > float(
                                self.stored_values_dict['Y-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the Y-actuator "
                                                         f"is {self.stored_values_dict['Y-actuator'][1]}.", "Warning")
                            return
                        value_to_move = [float(self.loading_y_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter y-axis value", "Warning")
                        return

                    if self.loading_y_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.loading_y_axis_mini_lndt.text()).split("."))).isdigit():
                        if int(self.loading_y_axis_speed_lndt.text()) > 15000:
                            self.msg_box_call("Warning", "The maximum speed of the Y-actuator is 15000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.loading_y_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(15000)

                elif text == 'loading_slider_run_btn':
                    if self.loading_slider_mini_lndt.text() != "" and "".join(list(
                            str(self.loading_slider_mini_lndt.text()).split("."))).isdigit():
                        if float(self.loading_slider_mini_lndt.text()) > float(self.stored_values_dict['Slider'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the slider "
                                                         f"is {self.stored_values_dict['Slider'][1]}.", "Warning")
                            return
                        self.recipe_btn_type = text
                        value_to_move = float(self.loading_slider_mini_lndt.text())
                    else:
                        self.msg_box_call("Warning", "Please enter slider value", "Warning")
                        return

                elif text == 'loading slider_homing btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == "loading_gripper_run_btn":
                    if self.loading_gripper_mini_lndt.text() != "" and "".join(list(
                            str(self.loading_gripper_mini_lndt.text()).split("."))).isdigit():
                        if float(self.loading_gripper_mini_lndt.text()) > float(self.stored_values_dict['Gripper'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the gripper "
                                                         f"is {self.stored_values_dict['Gripper'][1]}.", "Warning")
                            return
                        self.recipe_btn_type = text
                        value_to_move = float(self.loading_gripper_mini_lndt.text())
                    else:
                        self.msg_box_call("Warning", "Please enter Gripper value", "Warning")
                        return

                elif text == 'loading gripper_homing btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'loading_clockwise':
                    if self.loading_rotation_stepvalue_lndt.text() != "" and "".join(list(
                            str(self.loading_rotation_stepvalue_lndt.text()).split("."))).isdigit():
                        self.recipe_btn_type = text
                        value_to_move = float(self.loading_rotation_stepvalue_lndt.text())
                    else:
                        self.msg_box_call("Warning", "Please enter step value", "Warning")
                        return

                elif text == 'loading_anti_clockwise':
                    if self.loading_rotation_stepvalue_lndt.text() != "" and "".join(list(
                            str(self.loading_rotation_stepvalue_lndt.text()).split("."))).isdigit():
                        self.recipe_btn_type = text
                        value_to_move = float(self.loading_rotation_stepvalue_lndt.text())
                    else:
                        self.msg_box_call("Warning", "Please enter step value", "Warning")
                        return

                elif text == 'lens_rotator_x_axis_homing_btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'lens_rotator_y_axis_homing_btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'lens_rotator_x_axis_run_btn':
                    if self.lens_rotator_x_axis_mini_lndt.text() != "" and "".join(list(
                            str(self.lens_rotator_x_axis_mini_lndt.text()).split("."))).isdigit():
                        if float(self.lens_rotator_x_axis_mini_lndt.text()) > float(
                                self.stored_values_dict['X-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the X-actuator "
                                                         f"is {self.stored_values_dict['X-actuator'][1]}.", "Warning")
                            return
                        value_to_move = [float(self.lens_rotator_x_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter x-axis value", "Warning")
                        return

                    if self.lens_rotator_x_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.lens_rotator_x_axis_speed_lndt.text()).split("."))).isdigit():
                        if int(self.lens_rotator_x_axis_speed_lndt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed of the X-actuator is 2000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.lens_rotator_x_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(2000)

                elif text == 'lens_rotator_y_axis_run_btn':
                    if self.lens_rotator_y_axis_mini_lndt.text() != "" and "".join(list(
                            str(self.lens_rotator_y_axis_mini_lndt.text()).split("."))).isdigit():
                        if float(self.lens_rotator_y_axis_mini_lndt.text()) > float(
                                self.stored_values_dict['Y-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the Y-actuator "
                                                         f"is {self.stored_values_dict['Y-actuator'][1]}.", "Warning")
                            return
                        value_to_move = [float(self.lens_rotator_y_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter y-axis value", "Warning")
                        return

                    if self.lens_rotator_y_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.lens_rotator_y_axis_speed_lndt.text()).split("."))).isdigit():
                        if int(self.lens_rotator_y_axis_speed_lndt.text()) > 15000:
                            self.msg_box_call("Warning", "The maximum speed of the Y-actuator is 15000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.lens_rotator_y_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(15000)

                elif text == 'lens_rotator_clockwise':
                    if self.lens_rotator_gripper_stepvalue_lndt.text() != "" and "".join(list(
                            str(self.lens_rotator_gripper_stepvalue_lndt.text()).split("."))).isdigit():
                        self.recipe_btn_type = text
                        value_to_move = float(self.lens_rotator_gripper_stepvalue_lndt.text())
                    else:
                        self.msg_box_call("Warning", "Please enter step value", "Warning")
                        return

                elif text == 'lens_rotator_anti_clockwise':
                    if self.lens_rotator_gripper_stepvalue_lndt.text() != "" and "".join(list(
                            str(self.lens_rotator_gripper_stepvalue_lndt.text()).split("."))).isdigit():
                        self.recipe_btn_type = text
                        value_to_move = float(self.lens_rotator_gripper_stepvalue_lndt.text())
                    else:
                        self.msg_box_call("Warning", "Please enter step value", "Warning")
                        return

                elif text == 'collimator_x_axis_run_btn':
                    if self.collimator_x_axis_mini_lndt.text() != "" and "".join(list(
                            str(self.collimator_x_axis_mini_lndt.text()).split("."))).isdigit():
                        if float(self.collimator_x_axis_mini_lndt.text()) > float(
                                self.stored_values_dict['X-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the X-actuator "
                                                         f"is {self.stored_values_dict['X-actuator'][1]}.", "Warning")
                            return
                        value_to_move = [float(self.collimator_x_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter x-axis value", "Warning")
                        return

                    if self.collimator_x_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.collimator_x_axis_speed_lndt.text()).split("."))).isdigit():
                        if int(self.collimator_x_axis_speed_lndt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed of the X-actuator is 2000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.collimator_x_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(2000)

                elif text == 'collimator_x_axis_homing_btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'collimator_y_axis_run_btn':
                    if self.collimator_y_axis_mini_lndt.text() != "" and "".join(list(
                            str(self.collimator_y_axis_mini_lndt.text()).split("."))).isdigit():
                        if float(self.collimator_y_axis_mini_lndt.text()) > float(
                                self.stored_values_dict['Y-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the Y-actuator "
                                                         f"is {self.stored_values_dict['Y-actuator'][1]}.", "Warning")
                            return
                        value_to_move = [float(self.collimator_y_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter y-axis value", "Warning")
                        return
                    if self.collimator_y_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.collimator_y_axis_speed_lndt.text()).split("."))).isdigit():
                        if int(self.collimator_y_axis_speed_lndt.text()) > 15000:
                            self.msg_box_call("Warning", "The maximum speed of the Y-actuator is 15000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.collimator_y_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(15000)

                elif text == 'collimator_y_axis_homing_btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'collimator_clockwise_btn':
                    if self.collimator_gripper_stepvalue_lndt.text() != "" and "".join(list(
                            str(self.collimator_gripper_stepvalue_lndt.text()).split("."))).isdigit():
                        self.recipe_btn_type = text
                        value_to_move = float(self.collimator_gripper_stepvalue_lndt.text())
                    else:
                        self.msg_box_call("Warning", "Please enter step value", "Warning")
                        return

                elif text == 'collimator_anti_clockwise_btn':
                    if self.collimator_gripper_stepvalue_lndt.text() != "" and "".join(list(
                            str(self.collimator_gripper_stepvalue_lndt.text()).split("."))).isdigit():
                        self.recipe_btn_type = text
                        value_to_move = float(self.collimator_gripper_stepvalue_lndt.text())
                    else:
                        self.msg_box_call("Warning", "Please enter step value", "Warning")
                        return

                elif text == "Collimator_chart_dst_lux_btn":
                    if self.collimator_chartdistance_lndt.text() == "":
                        self.msg_box_call("Alert", "Chart distance should not be none", "Critical")
                        return

                    elif self.collimator_tl_chartintensity_lndt.text() == "" or self.collimator_tr_chartintensity_lndt.text() == "" or \
                            self.collimator_c_chartintensity_lndt.text() == "" or self.collimator_bl_chartintensity_lndt.text() == "" or \
                            self.collimator_br_chartintensity_lndt.text() == "":
                        self.msg_box_call("Alert", "Chart Intensity should not be none", "Critical")
                        return

                    else:
                        self.recipe_btn_type = text
                        value_to_move = [int(self.collimator_chartdistance_lndt.text()),
                                         int(self.collimator_bl_chartintensity_lndt.text()),
                                         int(self.collimator_tl_chartintensity_lndt.text()),
                                         int(self.collimator_tr_chartintensity_lndt.text()),
                                         int(self.collimator_br_chartintensity_lndt.text()),
                                         int(self.collimator_c_chartintensity_lndt.text())]

                elif text == 'relay_x_axis_run_btn':
                    if self.relay_x_axis_mini_lndt.text() != "" and "".join(list(
                            str(self.relay_x_axis_mini_lndt.text()).split("."))).isdigit():
                        if float(self.relay_x_axis_mini_lndt.text()) > float(self.stored_values_dict['X-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the X-actuator "
                                                         f"is {self.stored_values_dict['X-actuator'][1]}.", "Warning")
                            return
                        value_to_move = [float(self.relay_x_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter x-axis value", "Warning")
                        return

                    if self.relay_x_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.relay_x_axis_speed_lndt.text()).split("."))).isdigit():
                        if int(self.relay_x_axis_speed_lndt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed of the X-actuator is 2000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.relay_x_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(2000)

                elif text == 'relay_x_axis_homing_btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'relay_y_axis_run_btn':
                    if self.relay_y_axis_mini_lndt.text() != "":
                        if float(self.relay_y_axis_mini_lndt.text()) > float(self.stored_values_dict['Y-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the Y-actuator "
                                                         f"is {self.stored_values_dict['X-actuator'][1]}.", "Warning")
                            return
                        value_to_move = [float(self.relay_y_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter y-axis value", "Warning")
                        return

                    if self.relay_y_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.relay_y_axis_speed_lndt.text()).split("."))).isdigit():
                        if int(self.loading_y_axis_speed_lndt.text()) > 15000:
                            self.msg_box_call("Warning", "The maximum speed of the Y-actuator is 15000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.relay_y_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(15000)

                elif text == 'relay_y_axis_homing_btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'relay_clockwise_btn':
                    if self.relay_gripper_stepvalue_lndt.text() != "" and "".join(list(
                            str(self.relay_gripper_stepvalue_lndt.text()).split("."))).isdigit():
                        self.recipe_btn_type = text
                        value_to_move = float(self.relay_gripper_stepvalue_lndt.text())
                    else:
                        self.msg_box_call("Warning", "Please enter step value", "Warning")
                        return

                elif text == 'relay_anti_clockwise_btn':
                    if self.relay_gripper_stepvalue_lndt.text() != "" and "".join(list(
                            str(self.relay_gripper_stepvalue_lndt.text()).split("."))).isdigit():
                        self.recipe_btn_type = text
                        value_to_move = float(self.relay_gripper_stepvalue_lndt.text())
                    else:
                        self.msg_box_call("Warning", "Please enter step value", "Warning")
                        return

                elif text == 'relay_light_panel_actuator_run_btn':
                    if self.relay_light_panel_actuator_mini_lndt.text() != "" and "".join(list(
                            str(self.relay_light_panel_actuator_mini_lndt.text()).split("."))).isdigit():
                        if float(self.relay_light_panel_actuator_mini_lndt.text()) > float(
                                self.stored_values_dict['Relay Z-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the light panel actuator "
                                                         f"is {float(self.stored_values_dict['Relay Z-actuator'][1])}.",
                                              "Warning")
                            return
                        value_to_move = [float(self.relay_light_panel_actuator_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter x-axis value", "Warning")
                        return

                    if self.relay_light_panel_actuator_speed_lndt.text() != "" and "".join(list(
                            str(self.relay_light_panel_actuator_speed_lndt.text()).split("."))).isdigit():
                        if int(self.relay_light_panel_actuator_speed_lndt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed of the light panel actuator is 2000.",
                                              "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.relay_light_panel_actuator_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(2000)

                elif text == 'relay_light_panel_actuator_homing_btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'relay_light_panel_intensity_btn':
                    if self.relay_light_panel_intensity_lndt.text() != "" and "".join(list(
                            str(self.relay_light_panel_intensity_lndt.text()).split("."))).isdigit():
                        if int(self.relay_light_panel_intensity_lndt.text()) > 1024:
                            self.msg_box_call("Warning", "The maximum lux value is 1024", "Warning")
                            return
                        self.recipe_btn_type = text
                        value_to_move = int(self.relay_light_panel_intensity_lndt.text())

                    else:
                        self.msg_box_call("Warning", "Please enter lux value", "Warning")
                        return

                elif text == 'Gluing init btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'gluing_ctrl_gluing_btn':
                    logger.info("Gluing apply btn is clicked")
                    if self.gluing_type_cmb.currentText() == "Continuous glue":
                        if self.gluing_detail_speed_lndt.text() != "" and self.gluing_detail_diameter_lndt.text() != '' and \
                                self.gluing_on_delay_Continuous_lndt.text() != "" and \
                                self.gluing_off_delay_Continuous_lndt.text() != "" and "".join(list(
                            str(self.gluing_off_delay_Continuous_lndt.text()).split("."))).isdigit() and "".join(list(
                            str(self.gluing_detail_diameter_lndt.text()).split("."))).isdigit() and "".join(list(
                            str(self.gluing_detail_speed_lndt.text()).split("."))).isdigit():
                            self.recipe_btn_type = "Gluing with both time_delay"
                            value_to_move = [float(self.gluing_detail_speed_lndt.text()),
                                             float(self.gluing_detail_diameter_lndt.text()),
                                             float(self.gluing_on_delay_Continuous_lndt.text()),
                                             float(self.gluing_off_delay_Continuous_lndt.text())]

                        elif self.gluing_detail_speed_lndt.text() != "" and self.gluing_detail_diameter_lndt.text() != '' and \
                                self.gluing_on_delay_Continuous_lndt.text() != "" and "".join(list(
                            str(self.gluing_on_delay_Continuous_lndt.text()).split("."))).isdigit() and "".join(list(
                            str(self.gluing_detail_diameter_lndt.text()).split("."))).isdigit() and "".join(list(
                            str(self.gluing_detail_speed_lndt.text()).split("."))).isdigit():
                            self.recipe_btn_type = "Gluing with on time_delay"
                            value_to_move = [float(self.gluing_detail_speed_lndt.text()),
                                             float(self.gluing_detail_diameter_lndt.text()),
                                             float(self.gluing_on_delay_Continuous_lndt.text())]

                        elif self.gluing_detail_speed_lndt.text() != "" and self.gluing_detail_diameter_lndt.text() != '' and \
                                self.gluing_off_delay_Continuous_lndt.text() != "" and "".join(list(
                            str(self.gluing_off_delay_Continuous_lndt.text()).split("."))).isdigit() and "".join(list(
                            str(self.gluing_detail_diameter_lndt.text()).split("."))).isdigit() and "".join(list(
                            str(self.gluing_detail_speed_lndt.text()).split("."))).isdigit():
                            self.recipe_btn_type = "Gluing with off time_delay"
                            value_to_move = [float(self.gluing_detail_speed_lndt.text()),
                                             float(self.gluing_detail_diameter_lndt.text()),
                                             float(self.gluing_off_delay_Continuous_lndt.text())]

                        else:
                            if self.gluing_detail_speed_lndt.text() != "" and self.gluing_detail_diameter_lndt.text() != '':
                                self.recipe_btn_type = "Gluing apply btn"
                                value_to_move = [self.gluing_type_cmb.currentText(),
                                                 float(self.gluing_detail_speed_lndt.text()),
                                                 float(self.gluing_detail_diameter_lndt.text())]

                            else:
                                if self.gluing_detail_speed_lndt.text() == "":
                                    self.msg_box_call("Alert", "Gluing speed should not be empty", "Critical")
                                    return

                                elif self.gluing_detail_diameter_lndt.text() == "":
                                    self.msg_box_call("Alert", "Gluing diameter should not be empty", "Critical")
                                    return

                    elif self.gluing_type_cmb.currentText() == "Dry run":
                        if self.gluing_detail_speed_lndt.text() == "":
                            self.msg_box_call("Alert", "Gluing speed should not be empty", "Critical")
                            return

                        elif self.gluing_detail_diameter_lndt.text() == "":
                            self.msg_box_call("Alert", "Gluing diameter should not be empty", "Critical")
                            return

                        else:
                            self.recipe_btn_type = "Gluing apply btn"
                            value_to_move = [self.gluing_type_cmb.currentText(),
                                             float(self.gluing_detail_speed_lndt.text()),
                                             float(self.gluing_detail_diameter_lndt.text())]

                elif text == 'gluing_dispenser_apply_btn':
                    if self.gluing_dispenser_type_cmb.currentText() == "Both Dispenser" and \
                            self.gluing_dispenser_timer_lndt.text() != "" and "".join(list(
                        str(self.gluing_dispenser_timer_lndt.text()).split("."))).isdigit():
                        self.recipe_btn_type = "spot gluing both dispenser"
                        value_to_move = float(self.gluing_dispenser_timer_lndt.text())

                    elif self.gluing_dispenser_type_cmb.currentText() == "1st Dispenser" and \
                            self.gluing_dispenser_timer_lndt.text() != "" and "".join(list(
                        str(self.gluing_dispenser_timer_lndt.text()).split("."))).isdigit():
                        self.recipe_btn_type = "spot gluing first dispenser"
                        value_to_move = float(self.gluing_dispenser_timer_lndt.text())

                    elif self.gluing_dispenser_type_cmb.currentText() == "2nd Dispenser" and \
                            self.gluing_dispenser_timer_lndt.text() != "" and "".join(list(
                        str(self.gluing_dispenser_timer_lndt.text()).split("."))).isdigit():
                        self.recipe_btn_type = "spot gluing second dispenser"
                        value_to_move = float(self.gluing_dispenser_timer_lndt.text())

                    else:
                        self.msg_box_call("Alert", "Gluing timer should not be empty", "Critical")
                        return

                elif text == 'gluing_dispenser_off_btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'gluing_x_axis_run_btn':
                    if self.gluing_x_axis_mini_lndt.text() != "" and "".join(list(
                            str(self.gluing_x_axis_mini_lndt.text()).split("."))).isdigit():
                        if float(self.gluing_x_axis_mini_lndt.text()) > float(self.stored_values_dict['X-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the X-actuator "
                                                         f"is {self.stored_values_dict['Relay Z-actuator'][1]}.",
                                              "Warning")
                            return
                        value_to_move = [float(self.gluing_x_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter x-axis value", "Warning")
                        return

                    if self.gluing_x_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.gluing_x_axis_speed_lndt.text()).split("."))).isdigit():
                        if int(self.gluing_x_axis_speed_lndt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed of the X-actuator is 2000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.gluing_x_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(2000)

                elif text == 'gluing_y_axis_run_btn':
                    if self.gluing_y_axis_mini_lndt.text() != "" and "".join(list(
                            str(self.gluing_y_axis_mini_lndt.text()).split("."))).isdigit():
                        if float(self.gluing_y_axis_mini_lndt.text()) > float(self.stored_values_dict['Y-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the Y-actuator "
                                                         f"is {self.stored_values_dict['Y-actuator'][1]}.", "Warning")
                            return
                        value_to_move = [float(self.gluing_y_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter y-axis value", "Warning")
                        return

                    if self.gluing_y_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.gluing_y_axis_speed_lndt.text()).split("."))).isdigit():
                        if int(self.gluing_y_axis_speed_lndt.text()) > 15000:
                            self.msg_box_call("Warning", "The maximum speed of the Y-actuator is 15000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.gluing_y_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(15000)

                elif text == 'gluing_z_axis_run_btn':
                    if self.gluing_z_axis_mini_lndt.text() != "" and "".join(list(
                            str(self.gluing_z_axis_mini_lndt.text()).split("."))).isdigit():
                        if float(self.gluing_z_axis_mini_lndt.text()) > float(
                                self.stored_values_dict['Gluing Z-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the Z-actuator "
                                                         f"is {self.stored_values_dict['Gluing Z-actuator'][1]}.",
                                              "Warning")
                            return
                        value_to_move = [float(self.gluing_z_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter y-axis value", "Warning")
                        return

                    if self.gluing_z_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.gluing_z_axis_speed_lndt.text()).split("."))).isdigit():
                        if int(self.gluing_z_axis_speed_lndt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed of the Z-actuator is 2000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.gluing_z_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(2000)

                elif text == 'gluing_z_axis_homing_btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == 'gluing_teaching_x1_run_btn':
                    if self.gluing_teaching_x1_mini_lndt.text() != "" and "".join(list(
                            str(self.gluing_teaching_x1_mini_lndt.text()).split("."))).isdigit():
                        if float(self.gluing_teaching_x1_mini_lndt.text()) > float(
                                self.stored_values_dict['Gluing X1-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the gluing X1-actuator "
                                                         f"is {self.stored_values_dict['Gluing X1-actuator'][1]}.",
                                              "Warning")
                            return
                        self.recipe_btn_type = text
                        value_to_move = float(self.gluing_teaching_x1_mini_lndt.text())
                    else:
                        self.msg_box_call("Warning", "Please enter y-axis value", "Warning")
                        return

                elif text == 'gluing_teaching_x2_run_btn':
                    if self.gluing_teaching_x2_mini_lndt.text() != "" and "".join(list(
                            str(self.gluing_teaching_x2_mini_lndt.text()).split("."))).isdigit():
                        if float(self.gluing_teaching_x2_mini_lndt.text()) > float(
                                self.stored_values_dict['Gluing X2-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the gluing X2-actuator "
                                                         f"is {self.stored_values_dict['Gluing X2-actuator'][1]}.",
                                              "Warning")
                            return
                        self.recipe_btn_type = text
                        value_to_move = float(self.gluing_teaching_x2_mini_lndt.text())
                    else:
                        self.msg_box_call("Warning", "Please enter y-axis value", "Warning")
                        return

                elif text == 'gluing_teaching_y_run_btn':
                    self.recipe_btn_type = text
                    value_to_move = 20

                elif text == 'curing_x_axis_run_btn':
                    if self.curing_x_axis_mini_lndt.text() != "" and "".join(list(
                            str(self.curing_x_axis_mini_lndt.text()).split("."))).isdigit():
                        if float(self.curing_x_axis_mini_lndt.text()) > float(self.stored_values_dict['X-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the X-actuator "
                                                         f"is {self.stored_values_dict['X-actuator'][1]}.", "Warning")
                            return
                        value_to_move = [float(self.curing_x_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter x-axis value", "Warning")
                        return

                    if self.curing_x_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.curing_x_axis_speed_lndt.text()).split("."))).isdigit():
                        if int(self.curing_x_axis_speed_lndt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed of the X-actuator is 2000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.curing_x_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(2000)

                elif text == 'curing_y_axis_run_btn':
                    if self.curing_y_axis_mini_lndt.text() != "" and "".join(list(
                            str(self.curing_y_axis_mini_lndt.text()).split("."))).isdigit():
                        if float(self.curing_y_axis_mini_lndt.text()) > float(self.stored_values_dict['Y-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the Y-actuator "
                                                         f"is {self.stored_values_dict['Y-actuator'][1]}.", "Warning")
                            return
                        value_to_move = [float(self.curing_y_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter y-axis value", "Warning")
                        return

                    if self.curing_y_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.curing_y_axis_speed_lndt.text()).split("."))).isdigit():
                        if int(self.curing_y_axis_speed_lndt.text()) > 15000:
                            self.msg_box_call("Warning", "The maximum speed of the Y-actuator is 15000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.curing_y_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(15000)

                elif text == 'curing_z_axis_run_btn':
                    if self.curing_z_axis_mini_lndt.text() != "" and "".join(list(
                            str(self.curing_z_axis_mini_lndt.text()).split("."))).isdigit():
                        if float(self.curing_z_axis_mini_lndt.text()) > float(
                                self.stored_values_dict['Curing Z-actuator'][1]):
                            self.msg_box_call("Warning", f"The maximum value of the Z-actuator "
                                                         f"is {self.stored_values_dict['Curing Z-actuator'][1]}.",
                                              "Warning")
                            return
                        value_to_move = [float(self.curing_z_axis_mini_lndt.text())]
                    else:
                        self.msg_box_call("Warning", "Please enter z-axis value", "Warning")
                        return

                    if self.curing_z_axis_speed_lndt.text() != "" and "".join(list(
                            str(self.curing_z_axis_speed_lndt.text()).split("."))).isdigit():
                        if int(self.curing_z_axis_speed_lndt.text()) > 2000:
                            self.msg_box_call("Warning", "The maximum speed of the Z-actuator is 2000.", "Warning")
                            return
                        else:
                            self.recipe_btn_type = text
                            value_to_move.append(int(self.curing_z_axis_speed_lndt.text()))
                    else:
                        self.recipe_btn_type = text
                        value_to_move.append(15000)

                elif text == 'curing_z_axis_homing_btn':
                    self.recipe_btn_type = text
                    value_to_move = 0

                elif text == "curing door open":
                    value_to_move = 0
                    self.recipe_btn_type = text

                elif text == "curing door close":
                    value_to_move = 0
                    self.recipe_btn_type = text

                elif text == "Curing_on":
                    if self.curing_uv_intensity_lndt.text() != "" and not "".join(list(
                            str(self.curing_uv_intensity_lndt.text()).split("."))).isdigit():
                        self.msg_box_call("Warning", "Please enter the UV-intensity", "Warning")
                        return
                    if self.curing_time_lndt.text() != "" and not "".join(list(
                            str(self.curing_time_lndt.text()).split("."))).isdigit():
                        self.msg_box_call("Warning", "Please enter the Curing time", "Warning")
                        return
                    if int(self.curing_uv_intensity_lndt.text()) > 100:
                        self.msg_box_call("Warning", "The maximum value of the UV-intensity is 100.", "Warning")
                        return
                    else:
                        self.recipe_btn_type = text
                        value_to_move = [int(self.curing_uv_intensity_lndt.text()),
                                         int(self.curing_time_lndt.text())]

                self.recipe_create_thread(self.recipe_btn_type, value_to_move)

            else:
                self.statusbar.setText("Movement is in progress")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at spinbox_clicked function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def db_btn(self):
        try:
            """
               This method is used to store the user details in db.
               param lists: None.
               return: None
            """
            emp_id = self.lnedt_emp_id.text()
            set_pwd = self.lnedt_set_password.text()
            confrm_pwd = self.lnedt_set_password_2.text()
            user_name = self.lnedt_name.text()
            user_permission = self.cmb_user_permission.currentText()
            if self.btn_user_create.sender().text() == 'Create':
                logger.info('clicked create button')
                if emp_id == "" or set_pwd == "" or confrm_pwd == "" or user_name == "":
                    if emp_id == "":
                        self.msg_box_call('Alert', 'Employee id should not be empty', 'Critical')
                        return

                    if user_name == "":
                        self.msg_box_call('Alert', 'User name should not be empty', 'Critical')
                        return

                    if set_pwd == "":
                        self.msg_box_call('Alert', 'Password should not be empty', 'Critical')
                        return

                    if confrm_pwd == "":
                        self.msg_box_call('Alert', 'Confirm password should not be empty', 'Critical')
                        return

                else:
                    cursor = self.db_connection_class.fetch_emp_id()
                    for x in cursor:
                        if x == int(emp_id):
                            logger.error("Duplicate entry in database")
                            self.lbl_warning_emp_id.setText("Employee id already exists")
                            self.lnedt_emp_id.setStyleSheet("border: 1px solid red;")
                            self.lbl_warning_emp_id.show()
                            self.lnedt_emp_id.clear()
                            return

                    if len(emp_id) < 9:
                        logger.error("Invalid Employee id : {}".format(len(self.lnedt_emp_id.text())))
                        self.lnedt_emp_id.setStyleSheet("border: 1px solid red;")
                        self.lbl_warning_emp_id.setText("9 digits are only allowed")
                        self.lbl_warning_emp_id.show()
                        self.lnedt_emp_id.clear()
                        return

                    else:
                        self.lnedt_emp_id.setStyleSheet("")
                        self.lbl_warning_emp_id.setText("")
                        self.lbl_warning_emp_id.hide()

                    if len(set_pwd) < 8:
                        self.lnedt_set_password.setStyleSheet("border: 1px solid red;")
                        self.lbl_warning_password.show()
                        self.lnedt_set_password_2.clear()
                        return

                    elif set_pwd == confrm_pwd:
                        self.lbl_warning_password.hide()
                        self.lbl_warning_password_2.hide()
                        self.lnedt_set_password.setStyleSheet("")
                        self.lnedt_set_password_2.setStyleSheet("")

                        if user_permission == "--Select--":
                            self.msg_box_call('Alert', 'Please select the User permission', 'Critical')
                            return

                        if self.cmb_user_privilege.currentText() == "No":
                            user_privilege = 0
                        else:
                            user_privilege = 1

                        if self.fingerprint_list is None:
                            self.msg_box_call('Alert', 'Fingerprint data not found', 'Critical')
                            return

                        return_value = self.db_connection_class.insert_query(name=self.lnedt_name.text(),
                                                                             emp_id=int(self.lnedt_emp_id.text()),
                                                                             role=self.cmb_user_permission.currentText(),
                                                                             biometric=str(self.fingerprint_list),
                                                                             password=self.lnedt_set_password.text(),
                                                                             previlege=user_privilege)

                        if return_value == "Query inserted":
                            self.evt_create_user(text='Create User')
                            logger.info('User Create successfully')
                            self.msg_box_call('Information', 'Your details Created successfully', 'Information')
                            return

                        else:
                            logger.error("error at db_insert {}".format(return_value))
                            return

                    else:
                        self.lnedt_set_password.setStyleSheet("")
                        self.lbl_warning_password.hide()
                        self.lnedt_set_password_2.setStyleSheet("border: 1px solid red;")
                        self.lbl_warning_password_2.show()
                        self.lnedt_set_password_2.clear()
                        return

            elif self.btn_user_create.sender().text() == 'Edit':
                logger.info('clicked Edit button')
                if user_name == "":
                    self.msg_box_call('Alert', 'User name should not be empty', 'Critical')
                    return
                elif set_pwd == "":
                    self.msg_box_call('Alert', 'Password should not be empty', 'Critical')
                    return

                elif len(set_pwd) < 8:
                    self.lbl_warning_password.setText("Minimum 8 characters are allowed")
                    self.lnedt_set_password.setStyleSheet("border: 1px solid red;")
                    self.lbl_warning_password.show()
                    self.lnedt_set_password_2.clear()
                    return

                elif set_pwd == confrm_pwd:
                    self.lbl_warning_password.hide()
                    self.lbl_warning_password_2.hide()
                    self.lnedt_set_password.setStyleSheet("")
                    self.lnedt_set_password_2.setStyleSheet("")
                    if self.cmb_user_privilege.currentText() == "No":
                        user_privilege = 0
                    else:
                        user_privilege = 1

                    if "*" in self.lnedt_set_password.text():
                        password = self.set_password
                    else:
                        password = self.lnedt_set_password.text()

                    return_value = self.db_connection_class.update_query(name=self.lnedt_name.text(),
                                                                         password=password,
                                                                         user_permission=
                                                                         self.cmb_user_permission.currentText(),
                                                                         user_privilege=user_privilege,
                                                                         emp_id=self.lnedt_emp_id.text())
                    if return_value == "Query inserted":
                        self.evt_create_user(text='Edit User')
                        logger.info('User Edit successfully')
                        self.msg_box_call('Information', 'Your details Updated successfully', 'Information')

                else:
                    self.lnedt_set_password.setStyleSheet("")
                    self.lbl_warning_password.hide()
                    self.lnedt_set_password_2.setStyleSheet("border: 1px solid red;")
                    self.lbl_warning_password_2.show()
                    self.lnedt_set_password_2.clear()
                    return

            elif self.btn_user_create.sender().text() == 'Delete':
                logger.info('clicked Delete button')
                return_value = self.db_connection_class.delete(emp_id=self.lnedt_emp_id.text())
                if return_value == "Query inserted":
                    self.evt_create_user(text='Delete User')
                    logger.info('User Delete successfully')
                    self.msg_box_call('Information', 'Your details deleted successfully', 'Information')

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at db_btn function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def on_collimator_changed(self):
        try:
            """
               This method is used to adjusts the collimator parameter positions in the UI.
               param lists: None.
               return: None
            """
            if self.collimator_type_cmb.currentText() == "Old Collimator":
                self.Collimator_details_groupbox.setMinimumSize(QtCore.QSize(0, 330))
                self.collimator_wd_cmb.hide()
                self.collimator_wd_lbl.hide()
                self.collimator_light_lbl.show()
                self.collimator_light_cmb.show()
                self.collimator_cct_lndt.hide()
                self.collimator_cct_lbl.hide()
                self.collimator_light_lbl.setGeometry(QtCore.QRect(20, 85, 90, 20))
                self.collimator_light_cmb.setGeometry(QtCore.QRect(150, 80, 150, 30))
                self.collimator_chartdistance_lbl.setGeometry(QtCore.QRect(20, 135, 90, 20))
                self.collimator_chartdistance_lndt.setGeometry(QtCore.QRect(150, 130, 150, 30))
                self.collimator_chartintensity_lbl.setGeometry(QtCore.QRect(20, 175, 100, 20))
                self.collimator_tl_chartintensity_lbl.setGeometry(QtCore.QRect(20, 220, 50, 20))
                self.collimator_tl_chartintensity_lndt.setGeometry(QtCore.QRect(55, 215, 70, 30))
                self.collimator_tr_chartintensity_lbl.setGeometry(QtCore.QRect(20, 275, 50, 20))
                self.collimator_tr_chartintensity_lndt.setGeometry(QtCore.QRect(55, 265, 70, 30))
                self.collimator_bl_chartintensity_lbl.setGeometry(QtCore.QRect(145, 220, 50, 20))
                self.collimator_bl_chartintensity_lndt.setGeometry(QtCore.QRect(180, 215, 70, 30))
                self.collimator_br_chartintensity_lbl.setGeometry(QtCore.QRect(145, 275, 50, 20))
                self.collimator_br_chartintensity_lndt.setGeometry(QtCore.QRect(180, 270, 70, 30))
                self.collimator_c_chartintensity_lbl.setGeometry(QtCore.QRect(265, 220, 50, 20))
                self.collimator_c_chartintensity_lndt.setGeometry(QtCore.QRect(300, 215, 70, 30))
                self.collimator_chart_detail_update_btn.setGeometry(QtCore.QRect(280, 270, 90, 40))

            elif self.collimator_type_cmb.currentText() == "New Collimator":
                self.Collimator_details_groupbox.setMinimumSize(QtCore.QSize(0, 450))
                self.collimator_wd_cmb.show()
                self.collimator_wd_lbl.show()
                self.collimator_light_lbl.show()
                self.collimator_light_cmb.show()
                self.collimator_cct_lndt.show()
                self.collimator_cct_lbl.show()
                self.collimator_wd_cmb.setGeometry(QtCore.QRect(150, 80, 150, 30))
                self.collimator_wd_lbl.setGeometry(QtCore.QRect(20, 85, 110, 40))
                self.collimator_light_lbl.setGeometry(QtCore.QRect(20, 135, 110, 40))
                self.collimator_light_cmb.setGeometry(QtCore.QRect(150, 130, 150, 30))
                self.collimator_cct_lndt.setGeometry(QtCore.QRect(150, 180, 150, 30))
                self.collimator_cct_lbl.setGeometry(QtCore.QRect(20, 185, 110, 20))
                self.collimator_chartdistance_lbl.setGeometry(QtCore.QRect(20, 235, 90, 20))
                self.collimator_chartdistance_lndt.setGeometry(QtCore.QRect(150, 230, 150, 30))
                self.collimator_chartintensity_lbl.setGeometry(QtCore.QRect(20, 285, 100, 20))
                self.collimator_tl_chartintensity_lbl.setGeometry(QtCore.QRect(20, 340, 50, 20))
                self.collimator_tl_chartintensity_lndt.setGeometry(QtCore.QRect(60, 335, 70, 30))
                self.collimator_tr_chartintensity_lbl.setGeometry(QtCore.QRect(20, 395, 50, 20))
                self.collimator_tr_chartintensity_lndt.setGeometry(QtCore.QRect(60, 390, 70, 30))
                self.collimator_bl_chartintensity_lbl.setGeometry(QtCore.QRect(145, 340, 50, 20))
                self.collimator_bl_chartintensity_lndt.setGeometry(QtCore.QRect(180, 335, 70, 30))
                self.collimator_br_chartintensity_lbl.setGeometry(QtCore.QRect(145, 395, 50, 20))
                self.collimator_br_chartintensity_lndt.setGeometry(QtCore.QRect(180, 390, 70, 30))
                self.collimator_c_chartintensity_lbl.setGeometry(QtCore.QRect(270, 340, 50, 20))
                self.collimator_c_chartintensity_lndt.setGeometry(QtCore.QRect(300, 335, 70, 30))
                self.collimator_chart_detail_update_btn.setGeometry(QtCore.QRect(280, 390, 90, 40))


        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at on_collimator_changed function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def on_checkbox_changed(self):
        try:
            """
               This method is used to display the serial number textbox and label based on which checkbox is True.
               param lists: None.
               return: None
            """
            if self.mod_board_check_box.isChecked():
                if "Mod-board" not in self.serial_no_options_in_recipe:
                    self.serial_no_options_in_recipe.append("Mod-board")
            try:
                if not self.mod_board_check_box.isChecked():
                    self.serial_no_options_in_recipe.remove("Mod-board")

            except Exception as e:
                pass
            if self.base_board_check_box.isChecked():
                if "Base-board" not in self.serial_no_options_in_recipe:
                    self.serial_no_options_in_recipe.append("Base-board")
            try:
                if not self.base_board_check_box.isChecked():
                    self.serial_no_options_in_recipe.remove("Base-board")
            except Exception as e:
                pass
            if self.product_board_check_box.isChecked():
                if "Product-board" not in self.serial_no_options_in_recipe:
                    self.serial_no_options_in_recipe.append("Product-board")
            try:
                if not self.product_board_check_box.isChecked():
                    self.serial_no_options_in_recipe.remove("Product-board")
            except Exception as e:
                pass

            if sorted(self.serial_no_options_in_recipe) == ["Base-board", "Mod-board", "Product-board"]:
                self.device_details_grpbox.setMinimumSize(QtCore.QSize(0, 600))
                self.product_sr_no_lbl.show()
                self.product_sr_no_box.show()
                self.mod_sr_no_lbl.show()
                self.mod_Serial_No_box.show()
                self.base_sr_no_lbl.show()
                self.base_Serial_No_box.show()
                self.base_sr_no_len_lbl.show()
                self.base_Serial_No_len_box.show()
                self.product_sr_no_len_lbl.show()
                self.product_sr_no_len_box.show()
                self.mod_sr_no_len_lbl.show()
                self.mod_Serial_No_len_box.show()
                self.product_sr_no_lbl.setGeometry(QtCore.QRect(10, 300, 200, 30))
                self.product_sr_no_box.setGeometry(QtCore.QRect(10, 325, 250, 30))
                self.mod_sr_no_lbl.setGeometry(QtCore.QRect(10, 360, 200, 30))
                self.mod_Serial_No_box.setGeometry(QtCore.QRect(10, 385, 250, 30))
                self.base_sr_no_lbl.setGeometry(QtCore.QRect(10, 420, 200, 30))
                self.base_Serial_No_box.setGeometry(QtCore.QRect(10, 445, 250, 30))
                self.base_sr_no_len_lbl.setGeometry(QtCore.QRect(270, 420, 100, 30))
                self.base_Serial_No_len_box.setGeometry(QtCore.QRect(270, 445, 100, 30))
                self.product_sr_no_len_lbl.setGeometry(QtCore.QRect(270, 300, 100, 30))
                self.product_sr_no_len_box.setGeometry(QtCore.QRect(270, 325, 100, 30))
                self.mod_sr_no_len_lbl.setGeometry(QtCore.QRect(270, 360, 100, 30))
                self.mod_Serial_No_len_box.setGeometry(QtCore.QRect(270, 385, 100, 30))
                self.product_name_lbl.setGeometry(QtCore.QRect(10, 480, 200, 30))
                self.product_name_box.setGeometry(QtCore.QRect(10, 505, 250, 30))

            elif self.serial_no_options_in_recipe == ["Product-board"]:
                self.mod_sr_no_lbl.hide()
                self.mod_Serial_No_box.hide()
                self.base_sr_no_lbl.hide()
                self.base_Serial_No_box.hide()
                self.base_sr_no_len_lbl.hide()
                self.base_Serial_No_len_box.hide()
                self.product_sr_no_len_lbl.show()
                self.product_sr_no_len_box.show()
                self.mod_sr_no_len_lbl.hide()
                self.mod_Serial_No_len_box.hide()
                self.product_sr_no_lbl.show()
                self.product_sr_no_box.show()
                self.device_details_grpbox.setMinimumSize(QtCore.QSize(0, 500))
                self.product_sr_no_lbl.setGeometry(QtCore.QRect(10, 300, 200, 30))
                self.product_sr_no_box.setGeometry(QtCore.QRect(10, 325, 250, 30))
                self.product_sr_no_len_lbl.setGeometry(QtCore.QRect(270, 300, 100, 30))
                self.product_sr_no_len_box.setGeometry(QtCore.QRect(270, 325, 100, 30))
                self.product_name_lbl.setGeometry(QtCore.QRect(10, 360, 200, 30))
                self.product_name_box.setGeometry(QtCore.QRect(10, 385, 280, 30))

            elif self.serial_no_options_in_recipe == ["Mod-board"]:
                self.mod_sr_no_lbl.show()
                self.mod_Serial_No_box.show()
                self.base_sr_no_len_lbl.hide()
                self.base_Serial_No_len_box.hide()
                self.product_sr_no_len_lbl.hide()
                self.product_sr_no_len_box.hide()
                self.mod_sr_no_len_lbl.show()
                self.mod_Serial_No_len_box.show()
                self.base_sr_no_lbl.hide()
                self.base_Serial_No_box.hide()
                self.product_sr_no_lbl.hide()
                self.product_sr_no_box.hide()
                self.device_details_grpbox.setMinimumSize(QtCore.QSize(0, 500))
                self.mod_sr_no_lbl.setGeometry(QtCore.QRect(10, 300, 200, 30))
                self.mod_Serial_No_box.setGeometry(QtCore.QRect(10, 325, 250, 30))
                self.mod_sr_no_len_lbl.setGeometry(QtCore.QRect(270, 300, 100, 30))
                self.mod_Serial_No_len_box.setGeometry(QtCore.QRect(270, 325, 100, 30))
                self.product_name_lbl.setGeometry(QtCore.QRect(10, 360, 200, 30))
                self.product_name_box.setGeometry(QtCore.QRect(10, 385, 280, 30))

            elif self.serial_no_options_in_recipe == ["Base-board"]:
                self.mod_sr_no_lbl.hide()
                self.mod_Serial_No_box.hide()
                self.base_sr_no_lbl.show()
                self.base_Serial_No_box.show()
                self.product_sr_no_lbl.hide()
                self.product_sr_no_box.hide()
                self.base_sr_no_len_lbl.show()
                self.base_Serial_No_len_box.show()
                self.product_sr_no_len_lbl.hide()
                self.product_sr_no_len_box.hide()
                self.mod_sr_no_len_lbl.hide()
                self.mod_Serial_No_len_box.hide()
                self.device_details_grpbox.setMinimumSize(QtCore.QSize(0, 500))
                self.base_sr_no_lbl.setGeometry(QtCore.QRect(10, 300, 200, 30))
                self.base_Serial_No_box.setGeometry(QtCore.QRect(10, 325, 250, 30))
                self.base_sr_no_len_lbl.setGeometry(QtCore.QRect(270, 300, 100, 30))
                self.base_Serial_No_len_box.setGeometry(QtCore.QRect(270, 325, 100, 30))
                self.product_name_lbl.setGeometry(QtCore.QRect(10, 360, 200, 30))
                self.product_name_box.setGeometry(QtCore.QRect(10, 385, 280, 30))

            elif sorted(self.serial_no_options_in_recipe) == ["Base-board", "Mod-board"]:
                self.device_details_grpbox.setMinimumSize(QtCore.QSize(0, 550))
                self.product_sr_no_lbl.hide()
                self.product_sr_no_box.hide()
                self.mod_sr_no_lbl.show()
                self.mod_Serial_No_box.show()
                self.base_sr_no_lbl.show()
                self.base_Serial_No_box.show()
                self.base_sr_no_len_lbl.show()
                self.base_Serial_No_len_box.show()
                self.product_sr_no_len_lbl.hide()
                self.product_sr_no_len_box.hide()
                self.mod_sr_no_len_lbl.show()
                self.mod_Serial_No_len_box.show()
                self.mod_sr_no_lbl.setGeometry(QtCore.QRect(10, 300, 200, 30))
                self.mod_Serial_No_box.setGeometry(QtCore.QRect(10, 325, 250, 30))
                self.base_sr_no_lbl.setGeometry(QtCore.QRect(10, 360, 200, 30))
                self.base_Serial_No_box.setGeometry(QtCore.QRect(10, 385, 250, 30))
                self.mod_sr_no_len_lbl.setGeometry(QtCore.QRect(270, 300, 100, 30))
                self.mod_Serial_No_len_box.setGeometry(QtCore.QRect(270, 325, 100, 30))
                self.base_sr_no_len_lbl.setGeometry(QtCore.QRect(270, 360, 100, 30))
                self.base_Serial_No_len_box.setGeometry(QtCore.QRect(270, 385, 100, 30))
                self.product_name_lbl.setGeometry(QtCore.QRect(10, 420, 200, 30))
                self.product_name_box.setGeometry(QtCore.QRect(10, 445, 280, 30))

            elif sorted(self.serial_no_options_in_recipe) == ["Mod-board", "Product-board"]:
                self.device_details_grpbox.setMinimumSize(QtCore.QSize(0, 550))
                self.product_sr_no_lbl.show()
                self.product_sr_no_box.show()
                self.mod_sr_no_lbl.show()
                self.mod_Serial_No_box.show()
                self.base_sr_no_lbl.hide()
                self.base_Serial_No_box.hide()
                self.base_sr_no_len_lbl.hide()
                self.base_Serial_No_len_box.hide()
                self.product_sr_no_len_lbl.show()
                self.product_sr_no_len_box.show()
                self.mod_sr_no_len_lbl.show()
                self.mod_Serial_No_len_box.show()
                self.product_sr_no_lbl.setGeometry(QtCore.QRect(10, 300, 200, 30))
                self.product_sr_no_box.setGeometry(QtCore.QRect(10, 325, 250, 30))
                self.mod_sr_no_lbl.setGeometry(QtCore.QRect(10, 360, 200, 30))
                self.mod_Serial_No_box.setGeometry(QtCore.QRect(10, 385, 250, 30))
                self.mod_sr_no_len_lbl.setGeometry(QtCore.QRect(270, 300, 100, 30))
                self.mod_Serial_No_len_box.setGeometry(QtCore.QRect(270, 325, 100, 30))
                self.product_sr_no_len_lbl.setGeometry(QtCore.QRect(270, 360, 100, 30))
                self.product_sr_no_len_box.setGeometry(QtCore.QRect(270, 385, 100, 30))
                self.product_name_lbl.setGeometry(QtCore.QRect(10, 420, 200, 30))
                self.product_name_box.setGeometry(QtCore.QRect(10, 445, 280, 30))

            elif sorted(self.serial_no_options_in_recipe) == ["Base-board", "Product-board"]:
                self.device_details_grpbox.setMinimumSize(QtCore.QSize(0, 550))
                self.product_sr_no_lbl.show()
                self.product_sr_no_box.show()
                self.mod_sr_no_lbl.hide()
                self.mod_Serial_No_box.hide()
                self.base_sr_no_lbl.show()
                self.base_Serial_No_box.show()
                self.base_sr_no_len_lbl.show()
                self.base_Serial_No_len_box.show()
                self.product_sr_no_len_lbl.show()
                self.product_sr_no_len_box.show()
                self.mod_sr_no_len_lbl.hide()
                self.mod_Serial_No_len_box.hide()
                self.product_sr_no_lbl.setGeometry(QtCore.QRect(10, 300, 200, 30))
                self.product_sr_no_box.setGeometry(QtCore.QRect(10, 325, 250, 30))
                self.base_sr_no_lbl.setGeometry(QtCore.QRect(10, 360, 200, 30))
                self.base_Serial_No_box.setGeometry(QtCore.QRect(10, 385, 250, 30))
                self.base_sr_no_len_lbl.setGeometry(QtCore.QRect(270, 300, 100, 30))
                self.base_Serial_No_len_box.setGeometry(QtCore.QRect(270, 325, 100, 30))
                self.product_sr_no_len_lbl.setGeometry(QtCore.QRect(270, 360, 100, 30))
                self.product_sr_no_len_box.setGeometry(QtCore.QRect(270, 385, 100, 30))
                self.product_name_lbl.setGeometry(QtCore.QRect(10, 420, 200, 30))
                self.product_name_box.setGeometry(QtCore.QRect(10, 445, 280, 30))

            else:
                self.mod_sr_no_lbl.hide()
                self.mod_Serial_No_box.hide()
                self.base_sr_no_lbl.hide()
                self.base_Serial_No_box.hide()
                self.product_sr_no_lbl.hide()
                self.product_sr_no_box.hide()
                self.base_sr_no_len_lbl.hide()
                self.base_Serial_No_len_box.hide()
                self.product_sr_no_len_lbl.hide()
                self.product_sr_no_len_box.hide()
                self.mod_sr_no_len_lbl.hide()
                self.mod_Serial_No_len_box.hide()
                self.device_details_grpbox.setMinimumSize(QtCore.QSize(0, 425))
                self.product_name_lbl.setGeometry(QtCore.QRect(10, 300, 200, 30))
                self.product_name_box.setGeometry(QtCore.QRect(10, 325, 280, 30))


        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at on_checkbox_changed function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def on_combobox_changed(self, value):
        try:
            """
               This method is used to display the chart parameters based on chart count.
               param lists: datatype is int and value is number of chart count.
               return: None
            """
            self.value = value
            logger.info('combo box value : {}'.format(self.value))
            if self.value == 0:
                self.azimuth_ang_lbl.show()
                self.azimuth_ang_txtbox.show()
                self.chart_position_lbl.show()
                self.chart_position_box.show()
                self.outer_radius_lbl.show()
                self.outer_radius_txtbox.show()
                self.width_lbl.show()
                self.width_txtbox.show()
                self.height_lbl.show()
                self.height_txtbox.show()
                self.inr_radius_lbl.hide()
                self.inr_radius_txtbox.hide()
                self.inr_azimuth_ang_lbl.hide()
                self.inr_azimuth_ang_txtbox.hide()
                self.deep_inr_radius_lbl.hide()
                self.deep_inr_radius_txtbox.hide()
                self.chart_position_box.clear()
                self.chart_position_box.addItem('C,TL,TR,BL,BR')

            elif self.value == 1:
                self.azimuth_ang_lbl.show()
                self.azimuth_ang_txtbox.show()
                self.chart_position_lbl.show()
                self.chart_position_box.show()
                self.height_lbl.show()
                self.height_txtbox.show()
                self.outer_radius_txtbox.show()
                self.outer_radius_lbl.show()
                self.outer_radius_txtbox.show()
                self.width_lbl.show()
                self.width_txtbox.show()
                self.inr_azimuth_ang_lbl.show()
                self.inr_azimuth_ang_txtbox.show()
                self.inr_radius_lbl.show()
                self.inr_radius_txtbox.show()
                self.deep_inr_radius_lbl.hide()
                self.deep_inr_radius_txtbox.hide()
                self.chart_position_box.clear()
                self.chart_position_box.addItem('ITL,ITR,IBL,IBR')
                self.chart_position_box.addItem('TC,BC,RC,LC')

            elif self.value == 'TC,BC,RC,LC':
                self.inr_azimuth_ang_lbl.hide()
                self.inr_azimuth_ang_txtbox.hide()
                self.deep_inr_radius_lbl.hide()
                self.deep_inr_radius_txtbox.hide()
                self.inr_radius_lbl.show()
                self.inr_radius_txtbox.show()

            elif self.value == 'ITL,ITR,IBL,IBR':
                self.inr_azimuth_ang_lbl.show()
                self.inr_azimuth_ang_txtbox.show()
                self.deep_inr_radius_lbl.hide()
                self.deep_inr_radius_txtbox.hide()

            elif self.value == 2:
                self.chart_position_box.clear()
                self.chart_position_box.addItem('ALL')
                self.width_lbl.show()
                self.width_txtbox.show()
                self.height_lbl.show()
                self.height_txtbox.show()
                self.azimuth_ang_lbl.show()
                self.azimuth_ang_txtbox.show()
                self.chart_position_lbl.show()
                self.chart_position_box.show()
                self.outer_radius_lbl.show()
                self.outer_radius_txtbox.show()
                self.chart_position_lbl.show()
                self.chart_position_box.show()
                self.inr_azimuth_ang_lbl.show()
                self.inr_azimuth_ang_txtbox.show()
                self.inr_radius_lbl.show()
                self.inr_radius_txtbox.show()
                self.deep_inr_radius_lbl.show()
                self.deep_inr_radius_txtbox.show()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at on_combobox_changed function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def log_out(self):
        """
           This method is used to logged out the UI from the main page.
           param lists: None.
           return: None
        """
        logger.info('logout button is clicked')
        try:
            if self.sender().text() == 'Log Out':
                logger.info(f"User Name: {self.user_name} logout time: {datetime.datetime.now().strftime('%H:%M:%S')}")
                self.login_setupUi(self)

            self.emp_id_txtbox.textChanged.connect(self.on_emp_changed_for_login)
            self.login_btn.clicked.connect(self.evt_login_btn)
            self.move_login_btn.clicked.connect(self.animate_password_box)
            self.pwd_txtbox.returnPressed.connect(self.evt_login_btn)
            self.emp_id_txtbox.returnPressed.connect(self.animate_password_box)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at log_out function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def slideToIndex(self, new_index):
        try:
            """Animate a sliding transition to the widget at new_index."""
            if int(new_index) == 2:
                self.stackedWidget_title_lbl.setText('Height Sensor')
                self.btn_prev.show()
                self.btn_next.show()
                self.btn_save_recipe.hide()
            elif int(new_index) == 3:
                self.stackedWidget_title_lbl.setText('Focusing Station(Collimator)')
                self.btn_save_recipe.hide()
                self.btn_prev.show()
                self.btn_next.show()
            elif int(new_index) == 4:
                self.stackedWidget_title_lbl.setText('Focusing Station(Relay)')
                self.btn_save_recipe.hide()
                self.btn_prev.show()
                self.btn_next.show()
            elif int(new_index) == 5:
                self.stackedWidget_title_lbl.setText('Gluing Setup')
                self.btn_prev.show()
                self.btn_next.show()
                self.btn_save_recipe.hide()
            elif int(new_index) == 6:
                self.stackedWidget_title_lbl.setText('Curing Setup')
                self.btn_prev.show()
                self.btn_save_recipe.show()
                self.btn_next.hide()
            else:
                self.stackedWidget_title_lbl.setText('Loading/Unloading')
                self.btn_prev.hide()
                self.btn_next.show()
                self.btn_save_recipe.hide()

            if new_index == int(self.stackedWidget.currentIndex()):
                return

            current_widget = self.stackedWidget.currentWidget()
            next_widget = self.stackedWidget.widget(new_index)

            width = self.stackedWidget.frameRect().width()
            height = self.stackedWidget.frameRect().height()

            if new_index > self.stackedWidget.currentIndex():
                offset = QPoint(width, 0)
            else:
                offset = QPoint(-width, 0)

            self.stackedWidget.setGeometry(self.stackedWidget.frameRect())
            self.stackedWidget.move(QtCore.QPoint(10, 50))
            self.stackedWidget.show()

            animation_group = QParallelAnimationGroup(self)

            anim_current = QPropertyAnimation(current_widget, b"pos")
            anim_current.setDuration(400)
            anim_current.setStartValue(self.stackedWidget.pos())
            anim_current.setEndValue(self.stackedWidget.pos() - offset)
            anim_current.setEasingCurve(QEasingCurve.InOutQuad)
            animation_group.addAnimation(anim_current)

            anim_next = QPropertyAnimation(next_widget, b"pos")
            anim_next.setDuration(400)
            anim_next.setStartValue(self.stackedWidget.pos())
            anim_next.setEndValue(self.stackedWidget.frameRect().topLeft())
            anim_next.setEasingCurve(QEasingCurve.InOutQuad)
            animation_group.addAnimation(anim_next)

            def on_animation_finished():
                try:
                    self.stackedWidget.setCurrentIndex(new_index)
                    current_widget.move(self.stackedWidget.frameRect().topLeft())

                except Exception as e:
                    logger.error("on_animation_finished", e)

            animation_group.finished.connect(on_animation_finished)
            animation_group.start()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at log_out function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def animate_password_box(self):
        try:
            """
            Animate the password box from off-screen (right) to center.
            """
            if self.emp_id_txtbox.text() == "":
                self.msg_box_call("Empty textbox", "Please enter the Emp Id", "Critical")
                return

            elif len(self.emp_id_txtbox.text()) == 9:
                self.mycursor = self.db_connection_class.select_query(emp_id=int(self.emp_id_txtbox.text()))
                if not self.mycursor:
                    self.msg_box_call("Invalid User", "User not found in database", "Critical")
                    return
                else:
                    if self.mycursor[1] == 1 and self.mycursor[4] == 1:
                        self.fingerprint_lbl.hide()
                        self.pwd = self.mycursor[2]
                        self.user_name = self.mycursor[5]
                        self.user_text = self.mycursor[0]
                        self.animation = QPropertyAnimation(self.pwd_txtbox, b"xPos")
                        self.animation.setDuration(1000)
                        self.animation.setStartValue(800)
                        self.animation.setEndValue(600)
                        self.animation.setEasingCurve(QEasingCurve.OutCubic)
                        self.animation.start()

                        self.animation_1 = QPropertyAnimation(self.login_btn, b"xPos")
                        self.animation_1.setDuration(1000)
                        self.animation_1.setStartValue(800)
                        self.animation_1.setEndValue(600)
                        self.animation_1.setEasingCurve(QEasingCurve.OutCubic)
                        self.animation_1.start()

                        self.pwd_txtbox.show()
                        self.pwd_txtbox.setFocus()
                        self.login_btn.show()
                        self.move_login_btn.hide()

                    elif self.mycursor[1] == 0 and self.mycursor[4] == 1:
                        self.fingerprint_lbl.show()
                        self.move_login_btn.hide()
                        self.user_name = self.mycursor[5]
                        self.biometric = self.db_connection_class.fetch_biometric(emp_id=int(self.emp_id_txtbox.text()))
                        self.fingerprint_thread()

                    else:
                        self.fingerprint_lbl.hide()
                        self.pwd_txtbox.hide()
                        self.login_btn.hide()
                        self.move_login_btn.show()
                        self.msg_box_call("Alert", "User not found in the database", "Critical")
                        self.emp_id_txtbox.clear()
                        return
            else:
                self.msg_box_call("Invalid User", "Please enter the valid Emp Id", "Critical")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at animate_password_box function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def remove_textboxes(self):
        try:
            """
               This method is used to clear the labels and textbox values in recipe creation page.
               param lists: None.
               return: None
            """
            text_boxes = [self.path_txt_box, self.product_sr_no_box,
                          self.mod_Serial_No_box, self.base_Serial_No_box, self.product_name_box,
                          self.loading_x_axis_mini_lndt, self.loading_x_axis_speed_lndt,
                          self.loading_y_axis_mini_lndt, self.loading_y_axis_speed_lndt,
                          self.loading_slider_mini_lndt,
                          self.loading_gripper_mini_lndt,
                          self.lens_rotator_x_axis_mini_lndt, self.lens_rotator_x_axis_speed_lndt,
                          self.lens_rotator_y_axis_mini_lndt, self.lens_rotator_y_axis_speed_lndt,
                          self.lens_rotator_gripper_stepvalue_lndt,
                          self.collimator_x_axis_mini_lndt, self.collimator_x_axis_speed_lndt,
                          self.collimator_y_axis_mini_lndt, self.collimator_y_axis_speed_lndt,
                          self.collimator_chartdistance_lndt, self.collimator_tl_chartintensity_lndt,
                          self.collimator_tr_chartintensity_lndt,
                          self.collimator_bl_chartintensity_lndt, self.collimator_br_chartintensity_lndt,
                          self.collimator_c_chartintensity_lndt,
                          self.collimator_azimuth_lndt, self.collimator_radius_lndt, self.collimator_width_lndt,
                          self.collimator_height_lndt,
                          self.relay_x_axis_mini_lndt, self.relay_x_axis_speed_lndt,
                          self.relay_y_axis_mini_lndt, self.relay_y_axis_speed_lndt,
                          self.relay_light_panel_actuator_mini_lndt, self.relay_light_panel_actuator_speed_lndt,
                          self.relay_light_panel_intensity_lndt,
                          self.outer_radius_txtbox, self.azimuth_ang_txtbox, self.width_txtbox, self.height_txtbox,
                          self.inr_azimuth_ang_txtbox, self.inr_radius_txtbox,
                          self.gluing_x_axis_mini_lndt, self.gluing_x_axis_speed_lndt,
                          self.gluing_y_axis_mini_lndt, self.gluing_y_axis_speed_lndt,
                          self.gluing_teaching_x1_mini_lndt, self.gluing_teaching_x2_mini_lndt,
                          self.curing_x_axis_mini_lndt, self.curing_x_axis_speed_lndt,
                          self.curing_y_axis_mini_lndt, self.curing_y_axis_speed_lndt,
                          self.curing_time_lndt, self.curing_uv_intensity_lndt]

            actual_value = [self.loading_x_axis_current_position_value, self.loading_y_axis_current_position_value,
                            self.loading_slider_current_position_value, self.loading_gripper_current_position_value,
                            self.lens_rotator_x_axis_current_position_value,
                            self.lens_rotator_y_axis_current_position_value,
                            self.collimator_x_axis_current_position_value,
                            self.collimator_y_axis_current_position_value,
                            self.relay_x_axis_current_position_value, self.relay_y_axis_current_position_value,
                            self.relay_light_panel_actuator_current_position_value,
                            self.gluing_x_axis_current_position_value, self.gluing_y_axis_current_position_value,
                            self.gluing_z_axis_current_position_value,
                            self.gluing_teaching_x1_current_position_value,
                            self.gluing_teaching_x2_current_position_value,
                            self.curing_x_axis_current_position_value,
                            self.curing_y_axis_current_position_value, self.curing_z_axis_current_position_value]

            self.no_of_ROI_txtbox.setCurrentText("5")
            self.gluing_type_cmb.setCurrentText("Dry run")
            for y in actual_value:
                y.setText('0.0')
            logger.info('Default Actual values is set for all actual values')
            for x in text_boxes:
                x.setText('')
            logger.info('All Text boxes is clear')

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at remove textboxes function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def cancel(self):
        try:
            """
               This method is used to exit from the recipe creation page when user clicked abort button.
               param lists: None.
               return: None
            """
            logger.info('cancel button clicked')
            if self.recipe_btn_type is None:
                var = QMessageBox.question(self, 'Question', "Are you sure to cancel the recipe?",
                                           QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

                if var == QMessageBox.Yes:
                    logger.info('User clicked yes option')
                    self.abort_clicked = True
                    self.camera_connect = False
                    self.machine_movement_clicked = False
                    self.user_setting.setEnabled(True)
                    if self.stackedWidget.currentIndex() == 6:
                        self.btn_next.show()
                    self.btn_prev.hide()
                    self.btn_save_recipe.hide()
                    self.product_name_box.setReadOnly(False)
                    self.no_of_ROI_txtbox.setDisabled(False)
                    self.chart_position_box.setDisabled(False)
                    if os.path.isfile(
                            '{}\\Config_{}.csv'.format(self.path_txt_box.text(), self.product_name_box.text())):
                        try:
                            logger.info('Config file was found')
                            os.remove(
                                '{}\\Config_{}.csv'.format(self.path_txt_box.text(), self.product_name_box.text()))
                        except PermissionError:
                            logger.error('CSV file is opened')

                            self.msg_box_call('Alert', 'The CSV file is Opened, Please close it', 'Critical')
                        self.remove_textboxes()
                        self.evt_btn_mode(texts=self.user_text)

                    else:
                        logger.debug("No path in directory")
                        self.remove_textboxes()
                        time.sleep(1)
                        self.evt_btn_mode(texts=self.user_text)
                        return
                else:
                    logger.info("user clicked No option")
                    return
            else:
                self.msg_box_call("Information", "Movement is in progress", "Warning")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at cancel function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def evt_create_recipe(self):
        try:
            """
               This method is used to initialize the create recipe page.
               param lists: None.
               return: None
            """
            logger.info('evt_create_recipe is clicked')
            self.stackedWidget.setCurrentIndex(1)
            self.stackedWidget_1.setCurrentIndex(0)
            self.btn_next.show()
            self.stackedWidget_main_title_lbl.show()
            self.stackedWidget_main_title_lbl.setText("Recipe Creation Page")
            self.btn_save.show()
            self.lens_rotator_enable_lbl.show()
            self.collimator_enable_lbl.show()
            self.relay_enable_lbl.show()
            self.curing_enable_lbl.show()
            self.gluing_enable_lbl.show()
            self.lens_rotator_toggle.show()
            self.collimator_toggle.show()
            self.relay_toggle.show()
            self.gluing_toggle.show()
            self.curing_toggle.show()
            self.btn_cancel.show()
            self.btn_save_recipe.hide()
            self.btn_prev.hide()
            self.stackedWidget_title_lbl.setText('Loading/Unloading')
            self.user_setting.setEnabled(False)
            self.action_1 = 'Create Recipe'
            self.lens_rotator_toggle.setChecked(True)
            self.collimator_toggle.setChecked(True)
            self.relay_toggle.setChecked(True)
            self.gluing_toggle.setChecked(True)
            self.curing_toggle.setChecked(True)
            self.serial_no_options_in_recipe = []

            self.data = {"Product details": {}, "Loading station": {}, "Displacement sensor": {},
                         "Collimator station": {}, "Relay station": {}, "Gluing station": {}, "Curing station": {}}
            if self.ready_port:
                x_axis = [self.loading_x_axis_current_position_value, self.lens_rotator_x_axis_current_position_value,
                          self.collimator_x_axis_current_position_value, self.relay_x_axis_current_position_value,
                          self.gluing_x_axis_current_position_value, self.curing_x_axis_current_position_value]
                y_axis = [self.loading_y_axis_current_position_value, self.lens_rotator_y_axis_current_position_value,
                          self.collimator_y_axis_current_position_value, self.relay_y_axis_current_position_value,
                          self.gluing_y_axis_current_position_value, self.curing_y_axis_current_position_value]

                for x in range(1, 6):
                    read_actuator = ui_plc_communication.modbus_class.read_actuator_current_position(slave_id=x)
                    if x == 1:
                        if read_actuator != "Unable to read actuator":
                            self.y_act_current_value = read_actuator
                            for y in y_axis:
                                y.setText(f"{read_actuator}")
                        else:
                            logger.error("Unable to read actuator")
                            self.msg_box_call("Alert", "Unable to read actuator", "Warning")
                            return
                    elif x == 2:
                        if read_actuator != "Unable to read actuator":
                            self.relay_z_act_current_value = read_actuator
                            self.relay_light_panel_actuator_current_position_value.setText(f"{read_actuator}")
                        else:
                            logger.error("Unable to read actuator")
                            self.msg_box_call("Alert", "Unable to read actuator", "Warning")
                            return
                    elif x == 3:
                        if read_actuator != "Unable to read actuator":
                            self.gluing_z_act_current_value = read_actuator
                            self.gluing_z_axis_current_position_value.setText(f"{read_actuator}")
                        else:
                            logger.error("Unable to read actuator")
                            self.msg_box_call("Alert", "Unable to read actuator", "Warning")
                            return
                    elif x == 4:
                        if read_actuator != "Unable to read actuator":
                            self.curing_z_act_current_value = read_actuator
                            self.curing_z_axis_current_position_value.setText(f"{read_actuator}")
                        else:
                            logger.error("Unable to read actuator")
                            self.msg_box_call("Alert", "Unable to read actuator", "Warning")
                            return

                    elif x == 5:
                        if read_actuator != "Unable to read actuator":
                            for y in x_axis:
                                self.x_act_current_value = read_actuator
                                y.setText(f"{read_actuator}")
                        else:
                            logger.error("Unable to read actuator")
                            self.msg_box_call("Alert", "Unable to read actuator", "Warning")
                            return

                count = 0
                while count < 3:
                    ip_check = ui_plc_communication.plc_control_class.check_input_status()
                    if ip_check == "Status updated":
                        value = ui_plc_communication.plc_control_class.input_status
                        logger.info("IP status: {}".format(value))
                        logger.info(
                            "Part loading sensor status before enter recipe creation: {}".format(
                                value["Product loading Cyl In"]))
                        logger.info(
                            "Uv door & cylinder sensor status before enter recipe creation: {}".format(
                                value["UV Protection Door Open Sensor"]))
                        if value["Product loading Cyl In"]:
                            self.part_loading_act_in = True
                        else:
                            self.part_loading_act_in = False

                        if value["UV Protection Door Open Sensor"]:
                            self.uv_door_act_open = True
                        else:
                            self.uv_door_act_open = False

                        break
                    else:
                        logger.error("Error to read input status")
                        time.sleep(1)
                        count += 1

                self.gluing_x1_act_current_value = 0.0
                self.gluing_teaching_x1_current_position_value.setText(str(self.gluing_x1_act_current_value))
                self.gluing_x2_act_current_value = 0.0
                self.gluing_teaching_x2_current_position_value.setText(str(self.gluing_x2_act_current_value))
                self.gluing_y_act_current_value = 0.0
                self.slider_act_current_value = 0.0
                self.loading_slider_current_position_value.setText(str(self.slider_act_current_value))
                self.gripper_act_current_value = 40.0
                self.loading_gripper_current_position_value.setText(str(self.gripper_act_current_value))
            else:
                self.statusbar.setText("Ports are not connected.")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at evt_create_recipe function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def evt_edit_recipe(self):
        try:
            """
               This method is used to initialize the edit recipe page.
               param lists: None.
               return: None
            """
            logger.info('evt_edit_recipe is clicked')
            self.path_txt_box.clear()
            self.stackedWidget.setCurrentIndex(1)
            self.stackedWidget_1.setCurrentIndex(0)
            self.stackedWidget_main_title_lbl.show()
            self.stackedWidget_main_title_lbl.setText("Edit Recipe Page")
            self.action_1 = "Edit Recipe"
            self.btn_next.show()
            self.btn_save.show()
            self.btn_cancel.show()
            self.stackedWidget_title_lbl.setText('Edit Recipe')
            self.serial_no_options_in_recipe = []
            if self.ready_port:
                x_axis = [self.loading_x_axis_current_position_value, self.lens_rotator_x_axis_current_position_value,
                          self.collimator_x_axis_current_position_value, self.relay_x_axis_current_position_value,
                          self.gluing_x_axis_current_position_value, self.curing_x_axis_current_position_value]
                y_axis = [self.loading_y_axis_current_position_value, self.lens_rotator_y_axis_current_position_value,
                          self.collimator_y_axis_current_position_value, self.relay_y_axis_current_position_value,
                          self.gluing_y_axis_current_position_value, self.curing_y_axis_current_position_value]

                for x in range(1, 6):
                    read_actuator = ui_plc_communication.modbus_class.read_actuator_current_position(slave_id=x)
                    if x == 1:
                        if read_actuator != "Unable to read actuator":
                            self.y_act_current_value = read_actuator
                            for y in y_axis:
                                y.setText(f"{read_actuator}")
                        else:
                            logger.error("Unable to read actuator")
                            self.msg_box_call("Alert", "Unable to read actuator", "Warning")
                            return
                    elif x == 2:
                        if read_actuator != "Unable to read actuator":
                            self.relay_z_act_current_value = read_actuator
                            self.relay_light_panel_actuator_current_position_value.setText(f"{read_actuator}")
                        else:
                            logger.error("Unable to read actuator")
                            self.msg_box_call("Alert", "Unable to read actuator", "Warning")
                            return
                    elif x == 3:
                        if read_actuator != "Unable to read actuator":
                            self.gluing_z_act_current_value = read_actuator
                            self.gluing_z_axis_current_position_value.setText(f"{read_actuator}")
                        else:
                            logger.error("Unable to read actuator")
                            self.msg_box_call("Alert", "Unable to read actuator", "Warning")
                            return
                    elif x == 4:
                        if read_actuator != "Unable to read actuator":
                            self.curing_z_act_current_value = read_actuator
                            self.curing_z_axis_current_position_value.setText(f"{read_actuator}")
                        else:
                            logger.error("Unable to read actuator")
                            self.msg_box_call("Alert", "Unable to read actuator", "Warning")
                            return

                    elif x == 5:
                        if read_actuator != "Unable to read actuator":
                            for y in x_axis:
                                self.x_act_current_value = read_actuator
                                y.setText(f"{read_actuator}")
                        else:
                            logger.error("Unable to read actuator")
                            self.msg_box_call("Alert", "Unable to read actuator", "Warning")
                            return

                count = 0
                while count < 3:
                    ip_check = ui_plc_communication.plc_control_class.check_input_status()
                    if ip_check == "Status updated":
                        value = ui_plc_communication.plc_control_class.input_status
                        logger.info("IP status: {}".format(value))
                        logger.info(
                            "Part loading sensor status before enter recipe creation: {}".format(
                                value["Product loading Cyl In"]))
                        logger.info(
                            "Uv door & cylinder sensor status before enter recipe creation: {}".format(
                                value["UV Protection Door Open Sensor"]))
                        if value["Product loading Cyl In"]:
                            self.part_loading_act_in = True
                        else:
                            self.part_loading_act_in = False

                        if value["UV Protection Door Open Sensor"]:
                            self.uv_door_act_open = True
                        else:
                            self.uv_door_act_open = False
                        break
                    else:
                        logger.error("Error to read input status")
                        time.sleep(1)
                        count += 1

                self.gluing_x1_act_current_value = 0.0
                self.gluing_teaching_x1_current_position_value.setText(str(self.gluing_x1_act_current_value))
                self.gluing_x2_act_current_value = 0.0
                self.gluing_teaching_x2_current_position_value.setText(str(self.gluing_x2_act_current_value))
                self.gluing_y_act_current_value = 0.0
                self.slider_act_current_value = 0.0
                self.loading_slider_current_position_value.setText(str(self.slider_act_current_value))
                self.gripper_act_current_value = 40.0
                self.loading_gripper_current_position_value.setText(str(self.gripper_act_current_value))
            else:
                self.statusbar.setText("Ports are not connected.")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at evt_edit_recipe function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def change_button_name(self, dialog):
        for btn in dialog.findChildren(QtWidgets.QPushButton):
            if btn.text() == self.tr("&Open"):
                QtCore.QTimer.singleShot(0, lambda btn=btn: btn.setText("Remove"))

    def evt_create_user(self, text):
        try:
            """
               This method is used to initialize the create, edit and delete user page.
               param lists: None.
               return: None
            """
            logger.info("evt_create_user is clicked")
            self.btn_next.hide()
            self.btn_prev.hide()
            self.btn_save.hide()
            self.btn_save_recipe.hide()
            self.sender_create = text
            logger.info("User Clicked : {}".format(self.sender_create))
            if text == 'Create User' or text == 'Edit User' or text == 'Delete User':
                self.stackedWidget_main_title_lbl.hide()
                if text == 'Create User':
                    self.stackedWidget_title_lbl.setText('Create User')
                    self.lnedt_emp_id.setText('')
                    self.lnedt_name.setText('')
                    self.lnedt_set_password.setText('')
                    self.lnedt_set_password_2.setText('')
                    self.cmb_user_permission.setCurrentText("--Select--")
                    self.btn_user_create.setText('Create')
                    self.lnedt_emp_id.setStyleSheet("")
                    self.lbl_warning_emp_id.hide()
                    self.lnedt_set_password_2.setStyleSheet("")
                    self.lbl_warning_password_2.hide()
                    self.lbl_warning_password.hide()
                    self.btn_cancel.hide()
                    self.cmb_user_permission.clear()
                    self.cmb_user_permission.addItems(["--Select--", "OPERATOR", "SUPERVISOR", "ADMIN", "SUPERUSER"])
                    self.lnedt_emp_id.setReadOnly(False)
                    self.lnedt_name.setReadOnly(False)
                    self.lnedt_set_password_2.setReadOnly(False)
                    self.lnedt_set_password.setReadOnly(False)
                    self.cmb_user_privilege.setDisabled(False)
                    self.cmb_user_permission.setDisabled(False)
                    self.close_fingerprint_thread = False

                elif text == 'Edit User':
                    self.stackedWidget_title_lbl.setText('Edit User')
                    self.lnedt_emp_id.setText('')
                    self.lnedt_name.setText('')
                    self.lnedt_set_password.setText('')
                    self.lnedt_set_password_2.setText('')
                    self.cmb_user_permission.clear()
                    self.cmb_user_permission.addItems(["--Select--", "OPERATOR", "SUPERVISOR", "ADMIN", "SUPERUSER"])
                    self.cmb_user_privilege.setCurrentText("No")
                    self.lnedt_set_password_2.setStyleSheet("")
                    self.lnedt_emp_id.setStyleSheet("")
                    self.lbl_warning_password.hide()
                    self.lbl_warning_password_2.hide()
                    self.lnedt_set_password.setStyleSheet("")
                    self.lnedt_set_password_2.setStyleSheet("")
                    self.lbl_warning_emp_id.hide()
                    self.btn_user_create.setText('Edit')
                    self.btn_cancel.hide()
                    self.lnedt_emp_id.setReadOnly(True)
                    self.lnedt_name.setReadOnly(False)
                    self.lnedt_set_password_2.setReadOnly(False)
                    self.lnedt_set_password.setReadOnly(False)
                    self.cmb_user_privilege.setDisabled(False)
                    self.cmb_user_permission.setDisabled(False)
                    self.btn_fingerprint_create.setDisabled(True)

                elif text == 'Delete User':
                    self.lnedt_emp_id.setReadOnly(True)
                    self.lnedt_name.setReadOnly(True)
                    self.lnedt_set_password_2.setReadOnly(True)
                    self.lnedt_set_password.setReadOnly(True)
                    self.cmb_user_privilege.setDisabled(True)
                    self.cmb_user_permission.setDisabled(True)
                    self.btn_fingerprint_create.setDisabled(True)
                    self.stackedWidget_title_lbl.setText('Delete User')
                    self.lnedt_emp_id.setText('')
                    self.lnedt_name.setText('')
                    self.lnedt_set_password.setText('')
                    self.lnedt_set_password_2.setText('')
                    self.cmb_user_permission.clear()
                    self.cmb_user_permission.addItems(["--Select--", "OPERATOR", "SUPERVISOR", "ADMIN", "SUPERUSER"])
                    self.btn_user_create.setText('Delete')
                    self.lnedt_emp_id.setStyleSheet("")
                    self.lbl_warning_password.hide()
                    self.lbl_warning_password_2.hide()
                    self.lnedt_set_password.setStyleSheet("")
                    self.lnedt_set_password_2.setStyleSheet("")
                    self.lbl_warning_emp_id.hide()
                    self.btn_cancel.hide()

                self.edit_user_table.clearContents()
                for row in reversed(range(self.edit_user_table.rowCount())):
                    widget = self.edit_user_table.cellWidget(row, 1)
                    if widget is None:
                        self.edit_user_table.removeRow(row)
                self.edit_user_table.setWindowFlags(
                    QtCore.Qt.WindowCloseButtonHint | QtCore.Qt.WindowMaximizeButtonHint)
                self.edit_user_table.setStyleSheet(
                    "QTableWidget::item:selected {""color: black;""background-color: lightblue;""}")
                fetch_all = self.db_connection_class.select_all()
                self.edit_user_table.verticalHeader().setVisible(False)
                self.edit_user_table.setColumnCount(12)
                self.edit_user_table.setHorizontalHeaderLabels(
                    ['SI.No', 'NAME', 'PASSWORD', 'EMP ID', 'BIOMETRIC', 'ROLE', 'Active User', 'PRIVILEGE',
                     'created_at', 'updated_at', 'created_by', 'updated_by'])
                stylesheet = "::section{Background-color:rgb(255,255,51)}" \
                             "border: 1px solid red;"
                self.edit_user_table.horizontalHeader().setStyleSheet(stylesheet)
                self.edit_user_table.setColumnWidth(1, 450)
                self.edit_user_table.setColumnWidth(2, 250)
                self.edit_user_table.setColumnWidth(3, 200)
                self.edit_user_table.setColumnWidth(4, 250)
                self.edit_user_table.setColumnWidth(5, 300)
                self.edit_user_table.setColumnWidth(6, 100)
                self.edit_user_table.setColumnWidth(7, 170)
                self.edit_user_table.setColumnWidth(8, 250)
                self.edit_user_table.setColumnWidth(9, 100)
                self.edit_user_table.setColumnWidth(10, 200)
                self.edit_user_table.setColumnWidth(11, 100)
                self.edit_user_table.setColumnWidth(12, 100)

                active_users = []
                for x, y in enumerate(fetch_all):
                    li = list(y)
                    if li[6] != 0:
                        active_users.append(li)

                for row_number, row_data in enumerate(active_users):
                    row_data[0] = row_number + 1
                    self.edit_user_table.insertRow(row_number)
                    for column_number, data in enumerate(row_data):
                        item = QtWidgets.QTableWidgetItem(str(data))
                        item.setTextAlignment(Qt.AlignCenter)
                        self.edit_user_table.setItem(row_number, column_number, item)
                self.edit_user_table.setColumnHidden(4, True)
                self.edit_user_table.setColumnHidden(2, True)
                self.edit_user_table.setColumnHidden(6, True)
                self.edit_user_table.setColumnHidden(8, True)
                self.edit_user_table.setColumnHidden(9, True)
                self.edit_user_table.setColumnHidden(11, True)
                self.edit_user_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
                self.stackedWidget_1.addWidget(self.edit_user_table)
                self.stackedWidget_1.setCurrentIndex(1)
            self.stackedWidget.setCurrentIndex(0)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at evt_create_user function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def get_cell_value(self):
        try:
            """
               This method is used to write the user detail on respective textbox when user clicked on existing user table.
               param lists: None.
               return: None
            """
            if self.stackedWidget_title_lbl.text() == "Create User":
                return
            if self.sender_create == 'Create User':
                return

            self.lbl_warning_password.hide()
            self.lbl_warning_password_2.hide()
            self.lnedt_set_password.setStyleSheet("")
            self.lnedt_set_password_2.setStyleSheet("")
            select = self.edit_user_table.currentRow()
            values = []
            for column in range(self.edit_user_table.columnCount()):
                item = self.edit_user_table.item(select, column)
                if item is not None:
                    values.append(item.text())

            self.lnedt_emp_id.setText(values[3])
            self.lnedt_name.setText(values[1])
            self.set_password = values[2]
            self.confirm_password = values[2]
            self.lnedt_set_password.setText("*" * len(values[2]))
            self.lnedt_set_password_2.setText("*" * len(values[2]))

            if values[7] == '1':
                self.cmb_user_privilege.clear()
                self.cmb_user_privilege.addItems(["Yes", "No"])
            else:
                self.cmb_user_privilege.clear()
                self.cmb_user_privilege.addItems(["No", "Yes"])

            if values[5] == "OPERATOR":
                self.cmb_user_permission.clear()
                self.cmb_user_permission.addItems(["OPERATOR", "SUPERVISOR", "ADMIN", "SUPERUSER"])
            elif values[5] == "SUPERVISOR":
                self.cmb_user_permission.clear()
                self.cmb_user_permission.addItems(["SUPERVISOR", "ADMIN", "OPERATOR", "SUPERUSER"])
            elif values[5] == "ADMIN":
                self.cmb_user_permission.clear()
                self.cmb_user_permission.addItems(["ADMIN", "SUPERVISOR", "OPERATOR", "SUPERUSER"])
            elif values[5] == "SUPERUSER":
                self.cmb_user_permission.addItems(["SUPERUSER", "ADMIN", "SUPERVISOR", "OPERATOR"])

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at get cell value function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def closeEvent(self, event):
        try:
            """
               This method is used close the application when user clicked X on the application UI.
               param lists: None.
               return: None
            """
            logger.info("The close event is clicked")
            confirmation = QMessageBox.question(self, "Confirmation", "Do you want to close the application?",
                                                QMessageBox.Yes | QMessageBox.No)
            if confirmation == QMessageBox.Yes:
                logger.info("User clicked Yes in close event")
                try:
                    self.cap.release()
                except:
                    pass
                for x in range(3):
                    for process in psutil.process_iter(['pid', 'name']):
                        if process.info['name'] == "e-ZeeFocus_App.exe" or process.info['name'] == "e-ZeeFocus_App" or \
                                process.info['name'] == "python.exe":
                            pid = process.info['pid']
                            p = psutil.Process(pid)
                            logger.info("Application closed successfully")
                            p.terminate()
                            return

                    result = os.system("taskkill /f /im e-ZeeFocus_App.exe")
                    if result == 0:
                        logger.info("Application closed successfully")
                    else:
                        for process in psutil.process_iter(['pid', 'name']):
                            if process.info['name'] == "e-ZeeFocus_App.exe":
                                process.terminate()
                                logger.info("Application closed successfully")
                event.accept()
            else:
                logger.info("User clicked No in close event")
                event.ignore()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at closeEvent function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def dialog_execute(self):
        try:
            """
               This method is used to display the port connection dialog box.
               param lists: None.
               return: None
            """
            if self.app_opened_now and self.ready_port:
                self.app_opened_now = False
                self.homing_dialog_box.exec_()
            else:
                self.homing_dialog_box.exec()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at dialog_execute function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                 exc_tb.tb_lineno, e))

    def dialog_close(self):
        try:
            """
               This method is used to close the port connection dialog box.
               param lists: None.
               return: None
            """
            self.homing_dialog_box.dialog_close()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at dialog_box_close function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                   exc_tb.tb_lineno, e))

    def update_station_position(self, station=7):
        try:
            """
               This method is used to highlight the station.
               param lists: datatype is int and station is which station number.
               return: None
            """
            if self.load_frame.styleSheet() != "":
                self.load_frame.setStyleSheet("")
            if self.h_sensor_frame.styleSheet() != "":
                self.h_sensor_frame.setStyleSheet("")
            if self.collimator_frame.styleSheet() != "":
                self.collimator_frame.setStyleSheet("")
            if self.relay_frame.styleSheet() != "":
                self.relay_frame.setStyleSheet("")
            if self.gluing_frame.styleSheet() != "":
                self.gluing_frame.setStyleSheet("")
            if self.curing_frame.styleSheet() != "":
                self.curing_frame.setStyleSheet("")

            if station == 1:
                self.load_frame.setStyleSheet("border: 2px solid red;")

            elif station == 2:
                self.h_sensor_frame.setStyleSheet("border: 2px solid red;")

            elif station == 3:
                self.collimator_frame.setStyleSheet("border: 2px solid red;")

            elif station == 4:
                self.relay_frame.setStyleSheet("border: 2px solid red;")

            elif station == 5:
                self.gluing_frame.setStyleSheet("border: 2px solid red;")

            elif station == 6:
                self.curing_frame.setStyleSheet("border: 2px solid red;")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at update_station_position function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def close_msg(self):
        try:
            """
               This method is used to close the popup.
               param lists: None.
               return: None
            """
            self.msg.accept()
            self.error_msg_response = False

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at close_msg function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def msg_box_call(self, title, body, Wintype):
        try:
            """
               This method is used to show the popup.
               param lists: None.
               return: None
            """
            self.msg = QMessageBox()
            if Wintype == "Critical_finger" or Wintype == "Information_finger":
                if Wintype == "Critical_finger":
                    self.msg.setIcon(QMessageBox.Critical)
                else:
                    self.msg.setIcon(QMessageBox.Information)
                self.msg.setWindowTitle(title)
                self.msg.setText(body)
                self.msg.setStandardButtons(QMessageBox.Ok)
                self.msg.setDefaultButton(QMessageBox.Ok)
                choice = self.msg.exec_()
                if choice == self.msg.Ok:
                    self.ok_pressed = True

            elif Wintype == "Critical":
                self.msg.setIcon(QMessageBox.Critical)
                self.msg.setWindowTitle(title)
                self.msg.setText(body)
                self.msg.setStandardButtons(QMessageBox.Ok)
                self.msg.setDefaultButton(QMessageBox.Ok)
                self.msg.exec_()

            elif Wintype == "Warning":
                self.msg.setIcon(QMessageBox.Warning)
                self.msg.setWindowTitle(title)
                self.msg.setText(body)
                self.msg.setStandardButtons(QMessageBox.Ok)
                self.msg.setDefaultButton(QMessageBox.Ok)
                self.msg.exec_()

            elif Wintype == "Warning_msg":
                self.msg.setIcon(QMessageBox.Warning)
                self.msg.setWindowTitle(title)
                self.msg.setText(body)
                self.msg.setStandardButtons(QMessageBox.Ok)
                self.msg.setDefaultButton(QMessageBox.Ok)
                return_value = self.msg.exec_()
                if return_value == self.msg.Ok:
                    self.wait_user_response = True

            elif Wintype == "Auto_sequence":
                self.msg.setIcon(QMessageBox.Critical)
                self.msg.setWindowTitle(title)
                self.msg.setText(body)
                self.msg.setStandardButtons(QMessageBox.Ok)
                self.msg.setDefaultButton(QMessageBox.Ok)
                return_value = self.msg.exec_()
                if return_value == self.msg.Ok:
                    self.error_msg_response = False

            elif Wintype == "Information":
                self.msg.setIcon(QMessageBox.Information)
                self.msg.setWindowTitle(title)
                self.msg.setText(body)
                self.msg.setStandardButtons(QMessageBox.Ok)
                self.msg.setDefaultButton(QMessageBox.Ok)
                return_value = self.msg.exec_()
                if return_value == self.msg.Ok:
                    self.wait_user_response = True

            elif Wintype == "Critical_peak":
                self.msg.setIcon(QMessageBox.Information)
                self.msg.setWindowTitle(title)
                self.msg.setText(body)
                self.msg.setStandardButtons(QMessageBox.Ok)
                self.msg.setDefaultButton(QMessageBox.Ok)
                QTimer.singleShot(5000, self.msg.accept)
                self.msg.exec_()

            elif Wintype == "Question":
                self.msg.setIcon(QMessageBox.Information)
                self.msg.setWindowTitle(title)
                self.msg.setText(body)
                self.msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                self.msg.setDefaultButton(QMessageBox.Ok)
                return_value = self.msg.exec_()
                if return_value == self.msg.Yes:
                    self.user_call_init_yes = True
                else:
                    self.user_call_init_no = True

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at msg_box_call function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def abort_auto_sequence(self):
        """
           This method is used to change the flag status when user clicked abort button.
           param lists: None.
           return: None
        """
        logger.info("User clicked the abort button.")
        self.main_page_abort_btn.setEnabled(False)
        self.abort_auto_sequence_clicked = True

    def recipe_select(self):
        try:
            """
               This method is used to open the filedialog box to load the config file.
               param lists: None.
               return: None
            """
            logger.info('select recipe clicked')
            if self.sender().text() == 'Select Recipe':
                self.recipe_path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'Select file', './',
                                                                            'Excel Files (*xlsx)')
                if self.recipe_path != "":
                    get_config_file = os.path.basename(self.recipe_path)
                    check_path = get_config_file.split("_")
                    if check_path[0] == 'Config':
                        config_name = str(os.path.basename(self.recipe_path)).split(".")
                        self.config_name_lbl.setText("Config Name: {}".format(config_name[0]))

                        item = QtWidgets.QTableWidgetItem(str("0"))  # Overall running
                        item.setTextAlignment(Qt.AlignCenter)
                        item.setForeground(QColor(0, 100, 255))
                        self.tableWidget.setItem(0, 1, item)

                        item = QtWidgets.QTableWidgetItem(str("0"))  # Passed count
                        item.setTextAlignment(Qt.AlignCenter)
                        item.setForeground(QColor(0, 153, 76))
                        self.tableWidget.setItem(1, 1, item)

                        item = QtWidgets.QTableWidgetItem(str("0"))  # Failed count
                        item.setTextAlignment(Qt.AlignCenter)
                        item.setForeground(QColor(255, 0, 0))
                        self.tableWidget.setItem(2, 1, item)

                        self.load_config(path=self.recipe_path)
                        self.mod_serial_lnedt.setReadOnly(False)
                        self.base_serial_lnedt.setReadOnly(False)
                        self.product_serial_lnedt.setReadOnly(False)

                    else:
                        self.msg_box_call("Warning", "Incorrect config file", "Critical")
                else:
                    self.msg_box_call("Warning", "No file is selected", "Critical")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at recipe_select function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def recipe_path_btn(self):
        try:
            """
               This method is used to open the filedialog box to load the existing config file.
               param lists: None.
               return: None
            """
            if self.action_1 == 'Create Recipe':
                self.path_txt_box.clear()
                self.path = QtWidgets.QFileDialog.getExistingDirectory(self, caption='select a Folder')
                self.path_txt_box.setText(self.path)

            elif self.action_1 == "Edit Recipe":
                self.path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'Select file', './',
                                                                     'xl Files (*.xlsx)')
                if self.path:
                    if os.path.basename(self.path).startswith('Config'):
                        self.path_txt_box.setText(str(self.path))

                        v = openpyxl.load_workbook(str(self.path))
                        sheet = v.active
                        col = sheet.max_row

                        self.data = {}
                        for i in range(1, col + 1):
                            cell_obj = sheet.cell(row=1, column=i)
                            if cell_obj.value is not None:
                                self.data[cell_obj.value] = {}

                        c = 1
                        for y in self.data.keys():
                            for i in range(2, col + 1):
                                cell_obj = sheet.cell(row=i, column=c)
                                if cell_obj.value is not None:
                                    self.data[y][cell_obj.value] = ""

                            for j, k in zip(range(2, col + 1), self.data[y].keys()):
                                cell_obj = sheet.cell(row=j, column=c + 1)
                                if cell_obj.value is not None:
                                    self.data[y][k] = cell_obj.value
                            c += 3

                        if "Product details" in self.data:
                            self.base_board_check_box.setChecked(True)
                            self.mod_board_check_box.setChecked(True)
                            self.product_board_check_box.setChecked(True)
                            self.product_name_box.setText(str(self.data["Product details"]["Product name"]))
                            self.device_name_box.setText(str(self.data["Product details"]["Camera name"]))
                            self.firmware_value_lbl.setText(str(self.data["Product details"]["Firmware Version"]))
                            if not self.update:
                                self.resolution_box.addItem(str(self.data["Product details"]["Resolution"]))
                                self.exposure_box.addItem(str(self.data["Product details"]["Exposure"]))
                            self.product_sr_no_box.setText(str(self.data["Product details"]["Product Serial No."]))
                            self.mod_Serial_No_box.show()
                            self.base_Serial_No_box.show()
                            self.mod_Serial_No_box.setText(str(self.data["Product details"]["Module Serial No."]))
                            self.base_Serial_No_box.setText(str(self.data["Product details"]["Base Serial No."]))
                            self.base_Serial_No_len_box.setText(str(self.data["Product details"]["Base Serial len"]))
                            self.mod_Serial_No_len_box.setText(str(self.data["Product details"]["Module Serial len"]))
                            self.product_sr_no_len_box.setText(str(self.data["Product details"]["Product Serial len"]))

                        time.sleep(0.5)
                        if "Loading station" in self.data:
                            self.loading_x_axis_current_position_value.setText(
                                str(self.data["Loading station"]["X-Actuator Loading"]))
                            self.loading_y_axis_current_position_value.setText(
                                str(self.data["Loading station"]["Y-Actuator Loading"]))
                            self.loading_slider_current_position_value.setText(
                                str(self.data["Loading station"]["Slider"]))
                            self.loading_gripper_current_position_value.setText(
                                str(self.data["Loading station"]["Gripper"]))

                        time.sleep(0.5)
                        if "Displacement sensor" in self.data:
                            if bool(self.data["Displacement sensor"]["Displacement Status"]):
                                self.lens_rotator_toggle.setChecked(
                                    bool(self.data["Displacement sensor"]["Displacement Status"]))
                                self.lens_rotator_x_axis_current_position_value.setText(
                                    str(self.data["Displacement sensor"]["X-Actuator"]))
                                self.lens_rotator_y_axis_current_position_value.setText(
                                    str(self.data["Displacement sensor"]["Y-Actuator"]))
                                self.lens_rotator_sensor_value.setText(
                                    str(self.data["Displacement sensor"]["Height value"]))
                            else:
                                self.lens_rotator_toggle.setChecked(False)
                                self.lens_rotator_x_axis_current_position_value.setText("0.00")
                                self.lens_rotator_y_axis_current_position_value.setText("0.00")
                                self.lens_rotator_sensor_value.setText("NA")

                        time.sleep(0.5)
                        if "Collimator station" in self.data:
                            if bool(self.data["Collimator station"]["Collimator Status"]):
                                self.collimator_toggle.setChecked(
                                    bool(self.data["Collimator station"]["Collimator Status"]))
                                self.collimator_x_axis_current_position_value.setText(
                                    str(self.data["Collimator station"]["X-Actuator Collimator"]))
                                self.collimator_y_axis_current_position_value.setText(
                                    str(self.data["Collimator station"]["Y-Actuator Collimator"]))
                                self.collimator_tl_chartintensity_lndt.setText(
                                    str(self.data["Collimator station"]["Collimator TL intensity"]))
                                self.collimator_tr_chartintensity_lndt.setText(
                                    str(self.data["Collimator station"]["Collimator TR intensity"]))
                                self.collimator_bl_chartintensity_lndt.setText(
                                    str(self.data["Collimator station"]["Collimator BL intensity"]))
                                self.collimator_br_chartintensity_lndt.setText(
                                    str(self.data["Collimator station"]["Collimator BR intensity"]))
                                self.collimator_c_chartintensity_lndt.setText(
                                    str(self.data["Collimator station"]["Collimator C intensity"]))
                                self.collimator_chartdistance_lndt.setText(
                                    str(self.data["Collimator station"]["Collimator chart distance"]))
                                self.collimator_azimuth_lndt.setText(
                                    str(self.data["Collimator station"]["Outer Azimuth angle"]))
                                self.collimator_radius_lndt.setText(
                                    str(self.data["Collimator station"]["Outer Radius"]))
                                self.collimator_width_lndt.setText(
                                    str(self.data["Collimator station"]["width"]))
                                self.collimator_height_lndt.setText(
                                    str(self.data["Collimator station"]["height"]))
                                if str(self.data["Collimator station"]["Collimator type"]) == "New Collimator":
                                    self.collimator_wd_cmb.setText(
                                        str(self.data["Collimator station"]["Collimator WD"]))
                                    self.collimator_cct_lndt.setText(
                                        str(self.data["Collimator station"]["Color Temperature"]))

                                self.collimator_type_cmb.setCurrentText(
                                    str(self.data["Collimator station"]["Collimator type"]))
                                self.collimator_light_cmb.setCurrentText(
                                    str(self.data["Collimator station"]["Collimator light type"]))
                            else:
                                self.collimator_toggle.setChecked(False)
                                self.collimator_after_curing_focus_cmb.setCurrentText("No")
                                self.collimator_after_gluing_focus_cmb.setCurrentText("No")
                                self.collimator_raw_save_option_cmb.setCurrentText("No")
                                self.img_frmt_box.addItem("Monochrome")
                                self.collimator_type_cmb.setCurrentText("Old Collimator")
                                self.collimator_light_cmb.setCurrentText("Visible")
                                self.collimator_x_axis_current_position_value.setText("0.00")
                                self.collimator_y_axis_current_position_value.setText("0.00")

                        time.sleep(0.5)
                        if "Relay station" in self.data:
                            if bool(self.data["Relay station"]["Relay Status"]):
                                self.relay_toggle.setChecked(bool(self.data["Relay station"]["Relay Status"]))
                                self.relay_x_axis_current_position_value.setText(
                                    str(self.data["Relay station"]["X-Actuator Relay"]))
                                self.relay_y_axis_current_position_value.setText(
                                    str(self.data["Relay station"]["Y-Actuator Relay"]))
                                self.relay_light_panel_actuator_current_position_value.setText(
                                    str(self.data["Relay station"]["Z-Actuator Relay"]))
                                self.relay_light_panel_intensity_lndt.setText(
                                    str(self.data["Relay station"]["Light panel intensity"]))
                                self.relay_chart_orientation_cmb.setCurrentText(
                                    str(self.data["Relay station"]["Chart orientation"]))

                                self.no_of_ROI_txtbox.setCurrentText(
                                    str(self.data["Relay station"]["SFR chart count"]))
                                self.chart_position_box.setCurrentText(
                                    str(self.data["Relay station"]["Chart Position"]))
                                self.azimuth_ang_txtbox.setText(
                                    str(self.data["Relay station"]["Outer Azimuth angle"]))
                                self.outer_radius_txtbox.setText(
                                    str(self.data["Relay station"]["Outer Radius"]))
                                self.width_txtbox.setText(str(self.data["Relay station"]["width"]))
                                self.height_txtbox.setText(str(self.data["Relay station"]["height"]))

                            else:
                                self.relay_toggle.setChecked(False)
                                self.relay_x_axis_current_position_value.setText("0.00")
                                self.relay_y_axis_current_position_value.setText("0.00")
                                self.relay_light_panel_actuator_current_position_value.setText("0.00")
                                self.relay_light_panel_intensity_lndt.setText("")
                                self.relay_chart_orientation_cmb.setCurrentText("--Select--")

                        time.sleep(0.5)
                        if "Gluing station" in self.data:
                            if bool(self.data["Gluing station"]["Gluing Status"]):
                                self.gluing_toggle.setChecked(bool(self.data["Gluing station"]["Gluing Status"]))
                                self.gluing_x_axis_current_position_value.setText(
                                    str(self.data["Gluing station"]["X-Actuator Gluing"]))
                                self.gluing_y_axis_current_position_value.setText(
                                    str(self.data["Gluing station"]["Y-Actuator Gluing"]))
                                self.gluing_z_axis_current_position_value.setText(
                                    str(self.data["Gluing station"]["Z-Actuator Gluing"]))
                                self.gluing_teaching_x1_current_position_value.setText(
                                    str(self.data["Gluing station"]["Gluing x1"]))
                                self.gluing_teaching_x2_current_position_value.setText(
                                    str(self.data["Gluing station"]["Gluing x2"]))
                                self.gluing_type_cmb.setCurrentText(str(self.data["Gluing station"]["Glue Type"]))

                                if self.data["Gluing station"]["Glue Type"] == "Continuous glue":
                                    self.gluing_detail_diameter_lndt.setText(
                                        str(self.data["Gluing station"]["Glue Diameter"]))
                                    self.gluing_detail_diameter_lndt.setText(
                                        str(self.data["Gluing station"]["Glue speed"]))
                                    self.gluing_on_delay_Continuous_lndt.setText(
                                        str(self.data["Gluing station"]["Glue on time_delay"]))
                                    self.gluing_off_delay_Continuous_lndt.setText(
                                        str(self.data["Gluing station"]["Glue off time_delay"]))
                                else:
                                    self.gluing_dispenser_timer_lndt.setText(
                                        str(self.data["Gluing station"]["Glue time"]))
                            else:
                                self.gluing_toggle.setChecked(False)
                                self.gluing_x_axis_current_position_value.setText("0.00")
                                self.gluing_y_axis_current_position_value.setText("0.00")
                                self.gluing_z_axis_current_position_value.setText("0.00")
                                self.gluing_teaching_x1_current_position_value.setText("0.00")
                                self.gluing_teaching_x2_current_position_value.setText("0.00")
                                self.gluing_type_cmb.setCurrentText("Dry run")

                        time.sleep(0.5)
                        if "Curing station" in self.data:
                            if bool(self.data["Curing station"]["Curing Status"]):
                                self.curing_toggle.setChecked(bool(self.data["Curing station"]["Curing Status"]))
                                self.curing_x_axis_current_position_value.setText(
                                    str(self.data["Curing station"]["X-Actuator Curing"]))
                                self.curing_y_axis_current_position_value.setText(
                                    str(self.data["Curing station"]["Y-Actuator Curing"]))
                                self.curing_z_axis_current_position_value.setText(
                                    str(self.data["Curing station"]["Z-Actuator Curing"]))
                                self.curing_time_lndt.setText(str(self.data["Curing station"]["Curing Time"]))
                                self.curing_uv_intensity_lndt.text(str(self.data["Curing station"]["UV intensity"]))
                            else:
                                self.curing_toggle.setChecked(False)
                                self.curing_x_axis_current_position_value.setText("0.00")
                                self.curing_y_axis_current_position_value.setText("0.00")
                                self.curing_z_axis_current_position_value.setText("0.00")
                                self.curing_time_lndt.setText("")
                                self.curing_uv_intensity_lndt.setText("")
                    else:
                        self.msg_box_call("Alert", "You selected wrong CSV file", "Critical")
                        logger.error('User not selected the valid csv file')
                        self.user_setting.setDisabled(False)
                        return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at recipe_path_btn function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def reports(self):
        try:
            """
               This method is used to show the summary reports.
               param lists: None.
               return: None
            """
            mouse_pos = self.mapFromGlobal(self.cursor().pos())
            logger.info('report btn clicked {}'.format(mouse_pos.x()))
            self.table_widget = QTableWidget()
            self.table_widget.setWindowFlags(QtCore.Qt.WindowCloseButtonHint | QtCore.Qt.WindowMaximizeButtonHint)
            self.table_widget.setWindowTitle('Summary Reports')
            self.table_widget.setStyleSheet(
                "QTableWidget::item:selected {""color: black;""background-color: lightblue;""}")
            self.path = os.path.abspath(".") + '\\'
            now = datetime.datetime.now()
            self.excel_date = now.strftime("%Y_%m_%d")
            start_now = datetime.datetime.today().strftime("%Y-%m-%d")
            path = fr"D:\e-con Systems\e-ZeeFocus Application\{self.product_name}\{start_now}\MTF_Validation_Report.xlsx"
            wb = openpyxl.load_workbook(path)
            sheet = wb.active
            li = list(sheet.values)
            self.table_widget.setRowCount(sheet.max_row)
            self.table_widget.setColumnCount(sheet.max_column)
            row_index = 0
            for x in li:
                col_index = 0
                for y in x:
                    item = QTableWidgetItem(str(y))
                    item.setTextAlignment(Qt.AlignCenter)
                    self.table_widget.setItem(row_index, col_index, item)
                    if col_index == 0:
                        self.table_widget.setColumnWidth(col_index, 30)
                    else:
                        self.table_widget.setColumnWidth(col_index, 180)
                    col_index += 1
                row_index += 1

            for row in range(2):
                for col in range(self.table_widget.columnCount()):
                    item = self.table_widget.item(row, col)
                    item.setBackground(QColor(Qt.lightGray))
                    font = QFont()
                    font.setBold(True)
                    item.setFont(font)

                for row in range(self.table_widget.rowCount()):
                    for col in range(self.table_widget.columnCount()):
                        item = self.table_widget.item(row, self.table_widget.columnCount() - 1)
                        if item.text() == "Failed":
                            self.table_widget.item(row, col).setBackground(QColor(Qt.red))

            self.table_widget.verticalHeader().setVisible(False)
            self.table_widget.horizontalHeader().setVisible(False)
            self.table_widget.setSpan(0, 15, 1, 25)
            self.table_widget.setSpan(0, 42, 1, 25)
            self.table_widget.setSpan(0, 69, 1, 25)
            header = self.table_widget.horizontalHeader()
            header.setLineWidth(0)
            header.setFixedHeight(40)
            header.setSectionResizeMode(0, QHeaderView.Stretch)
            header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
            header.setSectionResizeMode(2, QHeaderView.ResizeToContents)
            self.table_widget.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
            self.table_widget.showMaximized()

        except FileNotFoundError:
            self.msg_box_call("Warning", "No excel file at the current directory", "Warning")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at reports function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def save_excel(self):
        try:
            """
               This method is used to save the station details in create and edit recipe page.
               param lists: None.
               return: None
            """
            logger.info('save button clicked')
            logger.info("user Option: {}".format(self.action_1))
            if self.action_1 == "Create Recipe" or self.action_1 == "Edit Recipe":
                if self.action_1 == "Edit Recipe":
                    self.loading_saved = True
                    if "Displacement sensor" not in self.data:
                        self.data["Displacement sensor"] = {}
                    if "Collimator station" not in self.data:
                        self.data["Collimator station"] = {}
                    if "Relay station" not in self.data:
                        self.data["Relay station"] = {}
                    if "Gluing station" not in self.data:
                        self.data["Gluing station"] = {}
                    if "Curing station" not in self.data:
                        self.data["Curing station"] = {}
                if self.stackedWidget.currentIndex() == 1:
                    if self.path_txt_box.text() != '':
                        if self.device_name_box.text() == "No Devices":
                            self.msg_box_call('Alert', 'Camera is not connected', 'Critical')
                            return
                        elif self.resolution_box.currentText() == "":
                            self.msg_box_call('Alert', 'Resolution box is empty', 'Critical')
                            return
                        elif self.exposure_box.currentText() == "":
                            self.msg_box_call('Alert', 'Exposure box is empty', 'Critical')
                            return
                        else:
                            self.data["Product details"]["Camera name"] = self.device_name_box.text()
                            get_resolution = self.resolution_box.currentText()
                            try:
                                tuple_resolution = ast.literal_eval(get_resolution)
                                if isinstance(tuple_resolution, tuple):
                                    self.get_resolution_tuple = tuple_resolution
                                else:
                                    logger.error("resolution is not tuple")

                            except (SyntaxError, ValueError):
                                logger.error("invalid input")

                            add_resolution = []
                            for x in self.get_resolution_tuple:
                                y = str(x)
                                if len(y) >= 3 and y.isdigit():
                                    add_resolution.append(y)
                            self.res = "x".join(add_resolution)
                        self.data["Product details"]["Resolution"] = self.res
                        self.data["Product details"]["Exposure"] = self.exposure_box.currentText()

                        if self.mod_board_check_box.isChecked() and self.base_board_check_box.isChecked() and \
                                self.product_board_check_box.isChecked():
                            if self.product_sr_no_box.text() == '':
                                self.msg_box_call('Alert', 'Product serial should not be empty', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Product Serial No."] = self.product_sr_no_box.text()

                            if self.product_sr_no_len_box.text() == '':
                                self.msg_box_call('Alert', 'Please enter the product serial number length', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Product Serial len"] = self.product_sr_no_len_box.text()

                            if self.mod_Serial_No_box.text() == '':
                                self.msg_box_call('Alert', 'Mod board serial should not be empty', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Module Serial No."] = self.mod_Serial_No_box.text()

                            if self.mod_Serial_No_len_box.text() == '':
                                self.msg_box_call('Alert', 'Please enter the Module serial number length', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Module Serial len"] = self.mod_Serial_No_len_box.text()

                            if self.base_Serial_No_box.text() == '':
                                self.msg_box_call('Alert', 'Base board serial should not be empty', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Base Serial No."] = self.base_Serial_No_box.text()

                            if self.base_Serial_No_len_box.text() == '':
                                self.msg_box_call('Alert', 'Please enter the Base serial number length', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Base Serial len"] = self.base_Serial_No_len_box.text()

                        elif self.mod_board_check_box.isChecked() and self.base_board_check_box.isChecked():
                            if self.mod_Serial_No_box.text() == '':
                                self.msg_box_call('Alert', 'Mod board serial should not be empty', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Module Serial No."] = self.mod_Serial_No_box.text()

                            if self.mod_Serial_No_len_box.text() == '':
                                self.msg_box_call('Alert', 'Please enter the Module serial number length', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Module Serial len"] = self.mod_Serial_No_len_box.text()

                            if self.base_Serial_No_box.text() == '':
                                self.msg_box_call('Alert', 'Base board serial should not be empty', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Base Serial No."] = self.base_Serial_No_box.text()

                            if self.base_Serial_No_len_box.text() == '':
                                self.msg_box_call('Alert', 'Please enter the Base serial number length', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Base Serial len"] = self.base_Serial_No_len_box.text()

                            self.data["Product details"]["Product Serial No."] = "NA"
                            self.data["Product details"]["Product Serial len"] = "0"

                        elif self.mod_board_check_box.isChecked() and self.product_board_check_box.isChecked():
                            if self.mod_Serial_No_box.text() == '':
                                self.msg_box_call('Alert', 'Mod board serial should not be empty', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Module Serial No."] = self.mod_Serial_No_box.text()

                            if self.mod_Serial_No_len_box.text() == '':
                                self.msg_box_call('Alert', 'Please enter the Module serial number length', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Module Serial len"] = self.mod_Serial_No_len_box.text()

                            if self.product_sr_no_box.text() == '':
                                self.msg_box_call('Alert', 'Product serial should not be empty', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Product Serial No."] = self.product_sr_no_box.text()

                            if self.product_sr_no_len_box.text() == '':
                                self.msg_box_call('Alert', 'Please enter the product serial number length', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Product Serial len"] = self.product_sr_no_len_box.text()

                            self.data["Product details"]["Base Serial No."] = "NA"
                            self.data["Product details"]["Base Serial len"] = "0"

                        elif self.base_board_check_box.isChecked() and self.product_board_check_box.isChecked():
                            if self.base_Serial_No_box.text() == '':
                                self.msg_box_call('Alert', 'Base board serial should not be empty', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Base Serial No."] = self.base_Serial_No_box.text()

                            if self.base_Serial_No_len_box.text() == '':
                                self.msg_box_call('Alert', 'Please enter the Base serial number length', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Base Serial len"] = self.base_Serial_No_len_box.text()

                            if self.product_sr_no_box.text() == '':
                                self.msg_box_call('Alert', 'Product serial should not be empty', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Product Serial No."] = self.product_sr_no_box.text()

                            if self.product_sr_no_len_box.text() == '':
                                self.msg_box_call('Alert', 'Please enter the product serial number length', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Product Serial len"] = self.product_sr_no_len_box.text()
                            self.data["Product details"]["Module Serial No."] = "NA"
                            self.data["Product details"]["Module Serial len"] = "0"

                        elif self.product_board_check_box.isChecked():
                            if self.product_sr_no_box.text() == '':
                                self.msg_box_call('Alert', 'Product serial should not be empty', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Product Serial No."] = self.product_sr_no_box.text()
                                self.data["Product details"]["Base Serial No."] = "NA"
                                self.data["Product details"]["Module Serial No."] = "NA"
                                self.data["Product details"]["Module Serial len"] = "0"
                                self.data["Product details"]["Base Serial len"] = "0"

                            if self.product_sr_no_len_box.text() == '':
                                self.msg_box_call('Alert', 'Please enter the product serial number length', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Product Serial len"] = self.product_sr_no_len_box.text()

                        elif self.mod_board_check_box.isChecked():
                            if self.mod_Serial_No_box.text() == '':
                                self.msg_box_call('Alert', 'Mod board serial should not be empty', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Module Serial No."] = self.mod_Serial_No_box.text()
                                self.data["Product details"]["Base Serial No."] = "NA"
                                self.data["Product details"]["Product Serial No."] = "NA"
                                self.data["Product details"]["Base Serial len"] = "0"
                                self.data["Product details"]["Product Serial len"] = "0"

                            if self.mod_Serial_No_len_box.text() == '':
                                self.msg_box_call('Alert', 'Please enter the Module serial number length', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Module Serial len"] = self.mod_Serial_No_len_box.text()

                        elif self.base_board_check_box.isChecked():
                            if self.base_Serial_No_box.text() == '':
                                self.msg_box_call('Alert', 'Base board serial should not be empty', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Base Serial No."] = self.base_Serial_No_box.text()
                                self.data["Product details"]["Module Serial No."] = "NA"
                                self.data["Product details"]["Product Serial No."] = "NA"
                                self.data["Product details"]["Module Serial len"] = "0"
                                self.data["Product details"]["Product Serial len"] = "0"

                            if self.base_Serial_No_len_box.text() == '':
                                self.msg_box_call('Alert', 'Please enter the Base serial number length', 'Critical')
                                return
                            else:
                                self.data["Product details"]["Base Serial len"] = self.base_Serial_No_len_box.text()

                        else:
                            self.msg_box_call('Alert', 'Please select the serial number type', 'Critical')
                            return

                        if self.product_name_box.text() == '':
                            self.msg_box_call('Alert', 'Product name should not be empty', 'Critical')
                            return
                        else:
                            self.data["Product details"]["Product name"] = self.product_name_box.text()

                        if self.loading_x_axis_current_position_value.text() != '0.0':
                            self.data["Loading station"][
                                "X-Actuator Loading"] = float(self.loading_x_axis_current_position_value.text())
                        else:
                            self.data["Loading station"]["X-Actuator"] = 10.0

                        if self.loading_y_axis_current_position_value.text() != '0.00':
                            self.data["Loading station"][
                                "Y-Actuator Loading"] = float(self.loading_y_axis_current_position_value.text())
                        else:
                            self.data["Loading station"]["Y-Actuator"] = 5.0

                        if self.loading_slider_current_position_value.text() == '0.00':
                            self.msg_box_call('Alert', 'Slider value should not be zero', 'Critical')
                            return
                        else:
                            self.data["Loading station"]["Slider"] = \
                                float(self.loading_slider_current_position_value.text())

                        if self.loading_gripper_current_position_value.text() == '0.00':
                            self.msg_box_call('Alert', 'Gripper value should not be Zero', 'Critical')
                            return
                        else:
                            self.data["Loading station"]["Gripper"] = \
                                float(self.loading_gripper_current_position_value.text())

                        self.data["Product details"]["Firmware Version"] = self.firmware_value_lbl.text()
                        self.loading_saved = True
                        self.msg_box_call('Information', 'loading station details saved successfully',
                                          'Information')
                    else:
                        self.msg_box_call('Alert', 'Please choose a path to save the file', 'Critical')
                        return

                elif self.stackedWidget.currentIndex() == 2:
                    if not self.lens_rotator_toggle.isChecked():
                        self.data["Displacement sensor"]["Displacement Status"] = False
                        self.height_sensor_saved = True
                        self.msg_box_call('Information', 'Displacement sensor disabled saved successfully',
                                          'Information')
                        return

                    else:
                        self.data["Displacement sensor"]["Displacement Status"] = True
                        if self.lens_rotator_x_axis_current_position_value.text() == "0.00":
                            self.msg_box_call('Alert', 'X-axis value should not be zero', 'Critical')
                            return

                        elif self.lens_rotator_y_axis_current_position_value.text() == "0.00":
                            self.msg_box_call('Alert', 'Y-axis value should not be zero', 'Critical')
                            return

                        elif self.lens_rotator_sensor_value.text() == "None":
                            self.msg_box_call('Alert', 'Height value should not be None', 'Critical')
                            return

                        self.data["Displacement sensor"]["X-Actuator Displacement"] = \
                            float(self.lens_rotator_x_axis_current_position_value.text())
                        self.data["Displacement sensor"]["Y-Actuator Displacement"] = \
                            float(self.lens_rotator_y_axis_current_position_value.text())
                        self.data["Displacement sensor"]["Height value"] = self.lens_rotator_sensor_value.text()
                        self.height_sensor_saved = True
                        self.msg_box_call('Information', 'Displacement sensor station details saved successfully',
                                          'Information')

                elif self.stackedWidget.currentIndex() == 3 or self.stackedWidget.currentIndex() == 4:
                    if self.stackedWidget.currentIndex() == 3:
                        if not self.collimator_toggle.isChecked():
                            self.data["Collimator station"]["Collimator Status"] = False
                            self.collimator_saved = True
                            self.msg_box_call('Information', 'Collimator station disabled successfully',
                                              'Information')
                            return
                        else:
                            if self.collimator_x_axis_current_position_value.text() == "0.00":
                                self.msg_box_call('Alert', 'X-axis values should not be zero', 'Critical')
                                return
                            elif self.collimator_y_axis_current_position_value.text() == "0.00":
                                self.msg_box_call('Alert', 'Y-axis values should not be zero', 'Critical')
                                return

                            elif self.collimator_azimuth_lndt.text() == '':
                                self.msg_box_call('Alert', 'Azimuth angle textbox should not be empty', 'Critical')
                                return
                            elif self.collimator_radius_lndt.text() == '':
                                self.msg_box_call('Alert', 'Radius textbox should not be empty', 'Critical')
                                return
                            elif self.collimator_width_lndt.text() == '':
                                self.msg_box_call('Alert', 'Width textbox should not be empty', 'Critical')
                                return
                            elif self.collimator_height_lndt.text() == "":
                                self.msg_box_call('Alert', 'Height textbox should not be empty', 'Critical')
                                return

                            elif self.collimator_chartdistance_lndt.text() == '':
                                self.msg_box_call('Alert', 'collimator chart-distance should not be empty', 'Critical')
                                return

                            elif self.collimator_tl_chartintensity_lndt.text() == '':
                                self.msg_box_call('Alert', 'collimator TL chart intensity should not be empty',
                                                  'Critical')
                                return
                            elif self.collimator_tr_chartintensity_lndt.text() == '':
                                self.msg_box_call('Alert', 'collimator TR chart intensity should not be empty',
                                                  'Critical')
                                return
                            elif self.collimator_bl_chartintensity_lndt.text() == '':
                                self.msg_box_call('Alert', 'collimator BL chart intensity should not be empty',
                                                  'Critical')
                                return
                            elif self.collimator_br_chartintensity_lndt.text() == '':
                                self.msg_box_call('Alert', 'collimator BR chart intensity should not be empty',
                                                  'Critical')
                                return
                            elif self.collimator_c_chartintensity_lndt.text() == '':
                                self.msg_box_call('Alert', 'collimator C chart intensity should not be empty',
                                                  'Critical')
                                return

                            else:
                                self.data["Collimator station"]["Collimator Status"] = True
                                self.data["Collimator station"]["X-Actuator Collimator"] = \
                                    self.collimator_x_axis_current_position_value.text()
                                self.data["Collimator station"]["Y-Actuator Collimator"] = \
                                    self.collimator_y_axis_current_position_value.text()

                                if self.collimator_after_curing_focus_cmb.currentText() == "Yes":
                                    self.data["Collimator station"]["After cure focus"] = True
                                else:
                                    self.data["Collimator station"]["After cure focus"] = False

                                if self.collimator_after_gluing_focus_cmb.currentText() == "Yes":
                                    self.data["Collimator station"]["After glue focus"] = True
                                else:
                                    self.data["Collimator station"]["After glue focus"] = False

                                if self.collimator_raw_save_option_cmb.currentText() == "Yes":
                                    self.data["Collimator station"]["Raw image"] = True
                                else:
                                    self.data["Collimator station"]["Raw image"] = False

                                self.data["Collimator station"][
                                    "Collimator TL intensity"] = self.collimator_tl_chartintensity_lndt.text()
                                self.data["Collimator station"][
                                    "Collimator TR intensity"] = self.collimator_tr_chartintensity_lndt.text()
                                self.data["Collimator station"][
                                    "Collimator BL intensity"] = self.collimator_bl_chartintensity_lndt.text()
                                self.data["Collimator station"][
                                    "Collimator BR intensity"] = self.collimator_br_chartintensity_lndt.text()
                                self.data["Collimator station"][
                                    "Collimator C intensity"] = self.collimator_c_chartintensity_lndt.text()
                                self.data["Collimator station"][
                                    "Collimator chart distance"] = self.collimator_chartdistance_lndt.text()
                                self.data["Collimator station"][
                                    "Collimator type"] = self.collimator_type_cmb.currentText()
                                self.data["Collimator station"][
                                    "Collimator light type"] = self.collimator_light_cmb.currentText()
                                if self.collimator_type_cmb.currentText() == "New Collimator":
                                    self.data["Collimator station"][
                                        "Collimator WD"] = self.collimator_wd_cmb.currentText()
                                    self.data["Collimator station"]["Color Temperature"] = str(
                                        self.collimator_cct_lndt.text())

                                self.data["Collimator station"][
                                    "Outer Azimuth angle"] = self.collimator_azimuth_lndt.text()
                                self.data["Collimator station"]["Outer Radius"] = self.collimator_radius_lndt.text()
                                self.data["Collimator station"]["width"] = self.collimator_width_lndt.text()
                                self.data["Collimator station"]["height"] = self.collimator_height_lndt.text()
                                self.data["Collimator station"]["Chart Position"] = "C,TL,TR,BL,BR"
                                self.data["Collimator station"]["SFRreg count"] = "5"
                                self.data["Collimator station"]["Fixture offset"] = False
                                self.collimator_saved = True
                                self.msg_box_call('Information', 'Collimator station details saved successfully',
                                                  'Information')
                    else:
                        if not self.relay_toggle.isChecked():
                            self.data["Relay station"]["Relay Status"] = False
                            self.relay_saved = True
                            self.msg_box_call('Information', 'Relay station disabled successfully',
                                              'Information')
                            return

                        else:
                            self.data["Relay station"]["Relay Status"] = True
                            if self.relay_x_axis_current_position_value.text() == '0.00':
                                self.msg_box_call('Alert', 'X-axis value should not be zero', 'Critical')
                                return

                            elif self.relay_y_axis_current_position_value.text() == '0.00':
                                self.msg_box_call('Alert', 'Y-axis value should not be zero', 'Critical')
                                return

                            elif self.relay_light_panel_actuator_current_position_value.text() == '0.00':
                                self.msg_box_call('Alert', 'Z-axis actuator should not be zero', 'Critical')
                                return

                            elif self.relay_light_panel_intensity_lndt.text() == '' or \
                                    self.relay_light_panel_intensity_lndt.text() == "0":
                                self.msg_box_call('Alert', 'lux value should not be empty', 'Critical')
                                return

                            elif self.relay_chart_orientation_cmb.currentText() == "--Select--":
                                self.msg_box_call('Alert', 'Please select the Chart orientation', 'Critical')
                                return

                            else:
                                self.data["Relay station"][
                                    "X-Actuator Relay"] = self.relay_x_axis_current_position_value.text()
                                self.data["Relay station"][
                                    "Y-Actuator Relay"] = self.relay_y_axis_current_position_value.text()
                                self.data["Relay station"][
                                    "Z-Actuator Relay"] = self.relay_light_panel_actuator_current_position_value.text()
                                self.data["Relay station"][
                                    "Z-Actuator reverse Relay"] = self.relay_light_panel_actuator_current_position_value.text()
                                self.data["Relay station"][
                                    "Chart orientation"] = self.relay_chart_orientation_cmb.currentText()
                                self.data["Relay station"][
                                    "Light panel intensity"] = self.relay_light_panel_intensity_lndt.text()

                                if self.relay_after_curing_focus_cmb.currentText() == "Yes":
                                    self.data["Relay station"]["After cure focus"] = True
                                else:
                                    self.data["Relay station"]["After cure focus"] = False

                                if self.relay_after_gluing_focus_cmb.currentText() == "Yes":
                                    self.data["Relay station"]["After glue focus"] = True
                                else:
                                    self.data["Relay station"]["After glue focus"] = False

                                if self.relay_raw_save_option_cmb.currentText() == "Yes":
                                    self.data["Relay station"]["Raw image"] = True
                                else:
                                    self.data["Relay station"]["Raw image"] = False

                                if self.relay_offset_cmb.currentText() == "No":
                                    if self.relay_fixture_offset_cmb.currentText() == "Yes":
                                        self.data["Relay station"]["Fixture offset"] = True
                                    else:
                                        self.data["Relay station"]["Fixture offset"] = False

                                    if self.relay_dx_offset_tolerence_lndt.text() == "":
                                        self.msg_box_call('Alert', 'Please enter the dx offset tolerance', 'Critical')
                                        return
                                    else:
                                        self.data["Relay station"]["dx tolerance"] = float(
                                            self.relay_dx_offset_tolerence_lndt.text())

                                    if self.relay_dy_offset_tolerence_lndt.text() == "":
                                        self.msg_box_call('Alert', 'Please enter the dy offset tolerance', 'Critical')
                                        return
                                    else:
                                        self.data["Relay station"]["dy tolerance"] = float(
                                            self.relay_dy_offset_tolerence_lndt.text())

                                    if self.pixel_in_mm_lndt.text() == "":
                                        self.msg_box_call('Alert', 'Please enter the No.of pixels', 'Critical')
                                        return
                                    else:
                                        self.data["Relay station"]["Pixel in mm"] = float(
                                            self.pixel_in_mm_lndt.text())
                                else:
                                    self.data["Relay station"]["Fixture offset"] = False

                            if self.no_of_ROI_txtbox.currentText() == '5':
                                if self.azimuth_ang_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Azimuth angle textbox should not be empty',
                                                      'Critical')
                                    return
                                elif self.outer_radius_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Outer radius textbox should not be empty',
                                                      'Critical')
                                    return
                                elif self.width_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Width textbox should not be empty',
                                                      'Critical')
                                    return
                                elif self.height_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Height should not be empty', 'Critical')
                                    return

                                else:
                                    self.data["Relay station"]["SFR chart count"] = self.no_of_ROI_txtbox.currentText()
                                    self.data["Relay station"]["Chart Position"] = self.chart_position_box.currentText()
                                    self.data["Relay station"]["Outer Azimuth angle"] = self.azimuth_ang_txtbox.text()
                                    self.data["Relay station"]["Outer Radius"] = self.outer_radius_txtbox.text()
                                    self.data["Relay station"]["width"] = self.width_txtbox.text()
                                    self.data["Relay station"]["height"] = self.height_txtbox.text()
                                    self.relay_saved = True
                                    self.msg_box_call('Information', 'Relay station details saved successfully',
                                                      'Information')

                            elif self.no_of_ROI_txtbox.currentText() == '9' and self.chart_position_box.currentText() == 'ITL, ITR, IBL, IBR':
                                if self.azimuth_ang_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Azimuth angle textbox should not be empty',
                                                      'Critical')
                                    return
                                elif self.outer_radius_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Outer radius textbox should not be empty',
                                                      'Critical')
                                    return
                                elif self.width_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Width textbox should not be empty',
                                                      'Critical')
                                    return
                                elif self.height_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Height textbox should not be empty',
                                                      'Critical')
                                    return
                                elif self.inr_azimuth_ang_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Inner azimuth angle textbox should not be empty',
                                                      'Critical')
                                    return

                                elif self.inr_radius_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Inner radius textbox should not be empty',
                                                      'Critical')
                                    return

                                else:
                                    self.data["Relay station"]["SFR chart count"] = self.no_of_ROI_txtbox.currentText()
                                    self.data["Relay station"]["Chart Position"] = self.chart_position_box.currentText()
                                    self.data["Relay station"]["Outer Azimuth angle"] = self.azimuth_ang_txtbox.text()
                                    self.data["Relay station"]["Outer Radius"] = self.outer_radius_txtbox.text()
                                    self.data["Relay station"]["width"] = self.width_txtbox.text()
                                    self.data["Relay station"]["height"] = self.height_txtbox.text()
                                    self.data["Relay station"][
                                        "Inner Azimuth angle"] = self.inr_azimuth_ang_txtbox.text()
                                    self.data["Relay station"]["Inner Radius"] = self.inr_radius_txtbox.text()
                                    self.relay_saved = True
                                    self.msg_box_call('Information', 'Relay station details saved successfully',
                                                      'Information')

                            elif self.no_of_ROI_txtbox.currentText() == '9' and self.chart_position_box.currentText() == 'TC, BC, RC, LC':
                                if self.azimuth_ang_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Azimuth angle textbox should not be empty', 'Critical')
                                    return
                                elif self.outer_radius_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Outer radius textbox should not be empty', 'Critical')
                                    return
                                elif self.width_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Width textbox should not be empty', 'Critical')
                                    return
                                elif self.height_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Height textbox should not be empty',
                                                      'Critical')
                                    return
                                elif self.inr_radius_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Inner radius textbox should not be empty', 'Critical')
                                    return

                                else:
                                    self.data["Relay station"]["SFR chart count"] = self.no_of_ROI_txtbox.currentText()
                                    self.data["Relay station"]["Chart Position"] = self.chart_position_box.currentText()
                                    self.data["Relay station"]["Outer Azimuth angle"] = self.azimuth_ang_txtbox.text()
                                    self.data["Relay station"]["Outer Radius"] = self.outer_radius_txtbox.text()
                                    self.data["Relay station"]["width"] = self.width_txtbox.text()
                                    self.data["Relay station"]["height"] = self.height_txtbox.text()
                                    self.data["Relay station"]["Inner Radius"] = self.inr_radius_txtbox.text()
                                    self.relay_saved = True
                                    self.msg_box_call('Information', 'Relay station details saved successfully',
                                                      'Information')

                            elif self.no_of_ROI_txtbox.currentText() == '13':
                                if self.azimuth_ang_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Azimuth angle textbox should not be empty', 'Critical')
                                    return
                                elif self.outer_radius_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Outer radius textbox should not be empty', 'Critical')
                                    return
                                elif self.width_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Width textbox should not be empty', 'Critical')
                                    return
                                elif self.height_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Height textbox should not be empty', 'Critical')
                                    return
                                elif self.inr_radius_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Inner radius textbox should not be empty', 'Critical')
                                    return
                                elif self.inr_azimuth_ang_txtbox.text() == '':
                                    self.msg_box_call('Alert', 'Inner azimuth angle textbox should not be empty',
                                                      'Critical')
                                    return

                                else:
                                    self.data["Relay station"]["SFR chart count"] = self.no_of_ROI_txtbox.currentText()
                                    self.data["Relay station"]["Chart Position"] = self.chart_position_box.currentText()
                                    self.data["Relay station"]["Outer Azimuth angle"] = self.azimuth_ang_txtbox.text()
                                    self.data["Relay station"]["Outer Radius"] = self.outer_radius_txtbox.text()
                                    self.data["Relay station"]["width"] = self.width_txtbox.text()
                                    self.data["Relay station"]["height"] = self.height_txtbox.text()
                                    self.data["Relay station"][
                                        "Inner Azimuth angle"] = self.inr_azimuth_ang_txtbox.text()
                                    self.data["Relay station"]["Inner Radius"] = self.inr_radius_txtbox.text()
                                    self.relay_saved = True
                                    self.msg_box_call('Information', 'Relay station details saved successfully',
                                                      'Information')

                elif self.stackedWidget.currentIndex() == 5:
                    if not self.gluing_toggle.isChecked():
                        self.data["Gluing station"]["Gluing Status"] = False
                        self.gluing_saved = True
                        self.msg_box_call('Information', 'Gluing station disabled successfully',
                                          'Information')
                        return

                    else:
                        self.data["Gluing station"]["Gluing Status"] = True
                        if self.gluing_x_axis_current_position_value.text() == '0.00':
                            self.msg_box_call('Alert', 'X-axis value should not be empty', 'Critical')
                            return

                        elif self.gluing_y_axis_current_position_value.text() == '0.00':
                            self.msg_box_call('Alert', 'Y-axis value should not be empty', 'Critical')
                            return

                        elif self.gluing_z_axis_current_position_value.text() == "0.00":
                            self.msg_box_call('Alert', 'Z-axis should not be empty', 'Critical')
                            return

                        elif self.gluing_type_cmb.currentText() == "Dry run":
                            self.msg_box_call('Alert', 'Gluing type should not be Dry run', 'Critical')
                            return

                        elif self.gluing_teaching_x1_current_position_value.text() == "0.013":
                            self.msg_box_call('Alert', 'Gluing x1 value should not be empty', 'Critical')
                            return

                        elif self.gluing_teaching_x2_current_position_value.text() == "0.013":
                            self.msg_box_call('Alert', 'Gluing x2 value should not be empty', 'Critical')
                            return

                        else:
                            if self.gluing_type_cmb.currentText() == "Continuous glue":
                                if self.gluing_detail_diameter_lndt.text() == "":
                                    self.msg_box_call('Alert', 'Gluing diameter should not be empty', 'Critical')
                                    return
                                elif self.gluing_detail_speed_lndt.text() == "":
                                    self.msg_box_call('Alert', 'Gluing speed should not be empty', 'Critical')
                                    return
                                else:
                                    self.data["Gluing station"][
                                        "Glue Diameter"] = self.gluing_detail_diameter_lndt.text()
                                    self.data["Gluing station"]["Glue speed"] = self.gluing_detail_speed_lndt.text()

                                    if self.gluing_on_delay_Continuous_lndt.text() == "":
                                        self.msg_box_call('Alert', 'Gluing on time delay should not be empty\n'
                                                                   'If you need not please enter as 0', 'Critical')
                                        return
                                    else:
                                        self.data["Gluing station"][
                                            "Glue on time_delay"] = self.gluing_on_delay_Continuous_lndt.text()

                                    if self.gluing_off_delay_Continuous_lndt.text() == "":
                                        self.msg_box_call('Alert', 'Gluing off time delay should not be empty\n'
                                                                   'If you need not please enter as 0', 'Critical')
                                        return
                                    else:
                                        self.data["Gluing station"][
                                            "Glue off time_delay"] = self.gluing_off_delay_Continuous_lndt.text()

                                    self.msg_box_call('Confirmation', "Ensure that the gluing points at x1 "
                                                                      "and x2 represent the meeting point of the "
                                                                      "two needles, as you are selecting a "
                                                                      "continuous glue type.",
                                                      'Question')
                                    if self.user_call_init_yes:
                                        self.data["Gluing station"][
                                            "Gluing x1"] = self.gluing_teaching_x1_current_position_value.text()
                                        self.data["Gluing station"][
                                            "Gluing x2"] = self.gluing_teaching_x2_current_position_value.text()

                            else:
                                if self.gluing_dispenser_timer_lndt.text() == "":
                                    self.msg_box_call('Alert', 'Gluing timer should not be empty', 'Critical')
                                    return

                                self.data["Gluing station"]["Glue time"] = self.gluing_dispenser_timer_lndt.text()

                            self.data["Gluing station"][
                                "X-Actuator Gluing"] = self.gluing_x_axis_current_position_value.text()
                            self.data["Gluing station"][
                                "Y-Actuator Gluing"] = self.gluing_y_axis_current_position_value.text()
                            self.data["Gluing station"][
                                "Z-Actuator Gluing"] = self.gluing_z_axis_current_position_value.text()
                            self.data["Gluing station"][
                                "Z-Actuator reverse Gluing"] = self.gluing_z_axis_current_position_value.text()
                            self.data["Gluing station"][
                                "Gluing x1"] = self.gluing_teaching_x1_current_position_value.text()
                            self.data["Gluing station"][
                                "Gluing x2"] = self.gluing_teaching_x2_current_position_value.text()
                            self.data["Gluing station"]["Glue Type"] = self.gluing_type_cmb.currentText()
                            self.gluing_saved = True
                            self.msg_box_call('Information', 'Gluing station details saved successfully',
                                              'Information')

                elif self.stackedWidget.currentIndex() == 6:
                    if not self.curing_toggle.isChecked():
                        self.data["Curing station"]["Curing Status"] = False
                        self.msg_box_call('Information', 'Curing station disabled successfully',
                                          'Information')
                        self.curing_saved = True
                        return

                    if self.curing_x_axis_current_position_value.text() == '0.00':
                        self.msg_box_call('Alert', 'X-axis value should not be empty', 'Critical')
                        return

                    elif self.curing_y_axis_current_position_value.text() == '0.00':
                        self.msg_box_call('Alert', 'Y-axis value should not be empty', 'Critical')
                        return

                    elif self.curing_z_axis_current_position_value.text() == '0.00':
                        self.msg_box_call('Alert', 'Z-axis value should not be empty', 'Critical')
                        return

                    elif self.curing_time_lndt.text() == '':
                        self.msg_box_call('Alert', 'Curing time should not be empty', 'Critical')
                        return

                    elif self.curing_uv_intensity_lndt.text() == '':
                        self.msg_box_call('Alert', 'Curing intensity should not be empty', 'Critical')
                        return

                    else:
                        self.data["Curing station"]["Curing Status"] = True
                        self.data["Curing station"][
                            "X-Actuator Curing"] = self.curing_x_axis_current_position_value.text()
                        self.data["Curing station"][
                            "Y-Actuator Curing"] = self.curing_y_axis_current_position_value.text()
                        self.data["Curing station"][
                            "Z-Actuator Curing"] = self.curing_z_axis_current_position_value.text()
                        self.data["Curing station"][
                            "Z-Actuator reverse Curing"] = self.curing_z_axis_current_position_value.text()
                        self.data["Curing station"]["Curing Time"] = self.curing_time_lndt.text()
                        self.data["Curing station"]["UV intensity"] = self.curing_uv_intensity_lndt.text()
                        self.curing_saved = True
                        self.msg_box_call('Information', 'Curing station details saved successfully',
                                          'Information')

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at save_excel function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def save_recipe(self):
        try:
            """
               This method is used to show the table with saved details in create and edit recipe page.
               param lists: None.
               return: None
            """
            if self.action_1 == "Create Recipe" or self.action_1 == "Edit Recipe":
                if not self.loading_saved:
                    self.msg_box_call('Alert', 'Please complete loading stations details', 'Warning')
                    return

                elif self.collimator_toggle.isChecked() and self.relay_toggle.isChecked():
                    self.msg_box_call('Alert', 'Please choose any one focus station (Relay or Collimator) details',
                                      'Warning')
                    return

                elif not self.collimator_toggle.isChecked() and not self.relay_toggle.isChecked():
                    self.msg_box_call('Alert', 'Please choose any one focus station (Relay or Collimator) details',
                                      'Warning')
                    return

                elif not self.collimator_toggle.isChecked() and not self.collimator_saved:
                    self.msg_box_call('Alert', "You have deactivated the collimator station "
                                               "but it's not saved. Kindly save it.", 'Warning')
                    return

                elif not self.relay_toggle.isChecked() and not self.relay_saved:
                    self.msg_box_call('Alert', "You have deactivated the relay station "
                                               "but it's not saved. Kindly save it.", 'Warning')
                    return

                elif not self.collimator_saved:
                    self.msg_box_call('Alert', 'Kindly save the collimator station.', 'Warning')
                    return

                elif not self.relay_saved:
                    self.msg_box_call('Alert', 'Kindly save the relay station.', 'Warning')
                    return

                try:
                    self.summary_table = QTableWidget(self.central_widget)
                    self.summary_table.setFixedSize(self.window_width, self.window_height)
                    self.save_recipe_btn_save = QPushButton(self.summary_table)
                    self.save_recipe_btn_save.setGeometry(QtCore.QRect(750, 900, 150, 40))
                    self.save_recipe_btn_save.setStyleSheet("QPushButton:enabled{\n"
                                                            "background-color:rgb(92, 98, 224);\n"
                                                            "color:rgb(255, 255, 255);\n"
                                                            "border-radius: 10px;\n"
                                                            "font: 75 14pt \"MS Shell Dlg 2\";\n"
                                                            "}"
                                                            "QPushButton:Pressed{\n"
                                                            "background-color: #1a5276;\n"
                                                            "}"
                                                            "QPushButton:disabled"
                                                            "{"
                                                            "background-color:#95a5a6;"
                                                            "}"
                                                            )
                    self.save_recipe_btn_save.setObjectName("self.save_recipe_btn_save")
                    self.save_recipe_btn_save.clicked.connect(self.recipe_file_saved)
                    self.save_recipe_btn_save.setText("Save")

                    self.save_recipe_btn_cancel = QPushButton(self.summary_table)
                    self.save_recipe_btn_cancel.setGeometry(QtCore.QRect(1050, 900, 150, 40))
                    self.save_recipe_btn_cancel.setStyleSheet("QPushButton:enabled{\n"
                                                              "background-color:rgb(92, 98, 224);\n"
                                                              "color:rgb(255, 255, 255);\n"
                                                              "border-radius: 10px;\n"
                                                              "font: 75 14pt \"MS Shell Dlg 2\";\n"
                                                              "}"
                                                              "QPushButton:Pressed{\n"
                                                              "background-color: #1a5276;\n"
                                                              "}"
                                                              "QPushButton:disabled"
                                                              "{"
                                                              "background-color:#95a5a6;"
                                                              "}"
                                                              )
                    self.save_recipe_btn_cancel.setObjectName("self.save_recipe_btn_cancel")
                    self.save_recipe_btn_cancel.setText("Cancel")
                    self.save_recipe_btn_cancel.clicked.connect(self.table_close)
                    self.summary_table.setWindowTitle('Merged Table Widget Example')
                    self.summary_table.verticalHeader().setVisible(False)
                    self.summary_table.horizontalHeader().setVisible(False)
                    self.summary_table.setRowCount(15)
                    for x, y in list(self.data.items()):
                        if y == {}:
                            del self.data[x]
                    self.summary_table.setColumnCount(len(self.data.keys()) * 2)
                    for x in range(len(self.data.keys()) * 2):
                        self.summary_table.setColumnWidth(x, 180)
                    column = 0
                    for col in self.data.keys():
                        item = QTableWidgetItem(col)
                        item.setTextAlignment(Qt.AlignCenter)
                        item.setBackground(QColor(255, 255, 90))
                        item.setForeground(QColor(255, 0, 0))
                        font = QFont()
                        font.setBold(True)
                        item.setFont(font)
                        self.summary_table.setItem(0, column, item)
                        self.summary_table.setSpan(0, column, 1, 2)
                        for row_number, row_data in enumerate(self.data[col], start=1):
                            item = QTableWidgetItem(str(row_data))
                            item.setTextAlignment(Qt.AlignCenter)
                            item_1 = QTableWidgetItem(str(self.data[col][row_data]))
                            item_1.setTextAlignment(Qt.AlignCenter)
                            self.summary_table.setItem(row_number, column, item)
                            self.summary_table.setItem(row_number, column + 1, item_1)
                        column += 2
                    self.summary_table.setEditTriggers(QTableWidget.NoEditTriggers)
                    self.summary_table.showMaximized()

                except Exception as e:
                    exc_type, exc_obj, exc_tb = sys.exc_info()
                    fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
                    logger.error(
                        "Error at save recipe function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at save recipe function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def table_close(self):
        """
           This method is used to close the table with recipe details in create and edit recipe page.
           param lists: None.
           return: None
        """
        self.summary_table.close()
        if "Displacement sensor" not in self.data:
            self.data["Displacement sensor"] = {}
        if "Collimator station" not in self.data:
            self.data["Collimator station"] = {}
        if "Relay station" not in self.data:
            self.data["Relay station"] = {}
        if "Gluing station" not in self.data:
            self.data["Gluing station"] = {}
        if "Curing station" not in self.data:
            self.data["Curing station"] = {}

    def recipe_file_saved(self):
        try:
            """
               This method is used to save the config file.
               param lists: None.
               return: None
            """
            if self.action_1 == "Create Recipe":
                try:
                    if not bool(self.data['Collimator station']["Collimator Status"]):
                        del self.data['Collimator station']
                        self.data['Collimator station'] = {}
                        self.data['Collimator station']["Collimator Status"] = False

                    if not bool(self.data['Relay station']['Relay Status']):
                        del self.data['Relay station']
                        self.data["Relay station"] = {}
                        self.data["Relay station"]["Relay Status"] = False

                    for x, y in list(self.data.items()):
                        if y == {}:
                            del self.data[x]
                    wb = openpyxl.Workbook()
                    sheet = wb.active
                    sheet.protection.password = 'sms'
                    sheet.protection.sheet = True
                    sheet.protection.enable()
                    col_idx = 1
                    for i, p in self.data.items():
                        for idx, j in enumerate(p.items(), start=2):
                            c1 = sheet.cell(row=idx, column=col_idx)
                            c1.font = Font(bold=True)
                            c2 = sheet.cell(row=idx, column=col_idx + 1)
                            c1.value = j[0]
                            c2.value = j[1]
                            c1.alignment = Alignment(horizontal='center', vertical='center')
                            thin_border = Border(
                                left=Side(style='thin'),
                                right=Side(style='thin'),
                                top=Side(style='thin'),
                                bottom=Side(style='thin'))
                            c1.border = thin_border
                            column_letter = get_column_letter(c1.column)
                            sheet.merge_cells(start_row=1, start_column=col_idx, end_row=1,
                                              end_column=col_idx + 1)
                            cell = sheet.cell(row=1, column=col_idx)
                            cell.value = i
                            cell.font = Font(bold=True)
                            cell.border = thin_border
                            cell.alignment = Alignment(horizontal='center', vertical='center')
                            sheet.column_dimensions[column_letter].width = 30

                            c2.alignment = Alignment(horizontal='center', vertical='center')
                            thin_border = Border(
                                left=Side(style='thin'),
                                right=Side(style='thin'),
                                top=Side(style='thin'),
                                bottom=Side(style='thin'))
                            c2.border = thin_border
                            column_letter_1 = get_column_letter(c2.column)
                            if column_letter_1 == "B":
                                sheet.column_dimensions[column_letter_1].width = 40
                            else:
                                sheet.column_dimensions[column_letter_1].width = 20
                        col_idx += 3
                    wb.save('{}\\Config_{}.xlsx'.format(self.path_txt_box.text(), self.product_name_box.text()))
                    time.sleep(0.5)
                    excel = openpyxl.load_workbook(
                        r'{}\\Config_{}.xlsx'.format(self.path_txt_box.text(), self.product_name_box.text()))
                    sheet = excel.active
                    if len(sheet["B2"].value) > 48:
                        sheet["B2"].alignment = Alignment(wrap_text=True, vertical='center')
                    if len(sheet["B8"].value) > 38:
                        sheet["B8"].alignment = Alignment(wrap_text=True, vertical='center')
                    wb.save('{}\\Config_{}.xlsx'.format(self.path_txt_box.text(), self.product_name_box.text()))
                    self.summary_table.close()
                    logger.info('xl file created successfully')
                    self.abort_clicked = True
                    self.loading_saved = False
                    self.height_sensor_saved = False
                    self.relay_saved = False
                    self.curing_saved = False
                    self.collimator_saved = False
                    self.gluing_saved = False
                    self.user_setting.setEnabled(True)
                    self.remove_textboxes()
                    self.No_preview_window_found_recipe_page()
                    self.evt_btn_mode(texts=self.user_text)
                    self.msg_box_call('Information', 'Details saved successfully', 'Information')

                except PermissionError:
                    logger.error('CSV file is opened')
                    self.msg_box_call('Alert', 'The CSV file is Opened, Please close it', 'Critical')

            elif self.action_1 == "Edit Recipe":
                try:
                    for x, y in list(self.data.items()):
                        if y == {}:
                            del self.data[x]

                    wb = openpyxl.Workbook()
                    sheet = wb.active
                    sheet.protection.password = 'sms'
                    sheet.protection.sheet = True
                    sheet.protection.enable()
                    col_idx = 1
                    for i, p in self.data.items():
                        for idx, j in enumerate(p.items(), start=2):
                            c1 = sheet.cell(row=idx, column=col_idx)
                            c1.font = Font(bold=True)
                            c2 = sheet.cell(row=idx, column=col_idx + 1)
                            c1.value = j[0]
                            c2.value = j[1]
                            c1.alignment = Alignment(horizontal='center', vertical='center')
                            thin_border = Border(
                                left=Side(style='thin'),
                                right=Side(style='thin'),
                                top=Side(style='thin'),
                                bottom=Side(style='thin'))
                            c1.border = thin_border
                            column_letter = get_column_letter(c1.column)
                            sheet.merge_cells(start_row=1, start_column=col_idx, end_row=1,
                                              end_column=col_idx + 1)
                            cell = sheet.cell(row=1, column=col_idx)
                            cell.value = i
                            cell.font = Font(bold=True)
                            cell.border = thin_border
                            cell.alignment = Alignment(horizontal='center', vertical='center')
                            sheet.column_dimensions[column_letter].width = 30

                            c2.alignment = Alignment(horizontal='center', vertical='center')
                            thin_border = Border(
                                left=Side(style='thin'),
                                right=Side(style='thin'),
                                top=Side(style='thin'),
                                bottom=Side(style='thin'))
                            c2.border = thin_border
                            column_letter_1 = get_column_letter(c2.column)
                            sheet.column_dimensions[column_letter_1].width = 20

                        col_idx += 3

                    wb.save('{}'.format(self.path_txt_box.text()))
                    logger.info('Edit recipe saved successfully')
                    self.remove_textboxes()
                    self.loading_saved = False
                    self.height_sensor_saved = False
                    self.relay_saved = False
                    self.curing_saved = False
                    self.collimator_saved = False
                    self.gluing_saved = False
                    self.abort_clicked = True
                    self.evt_btn_mode(texts=self.user_text)
                    self.user_setting.setEnabled(True)
                    self.msg_box_call('Information', 'Details saved successfully', 'Information')

                except PermissionError:
                    logger.error('CSV file is Opened')
                    self.msg_box_call('Alert',
                                      'Existing config file is opened, Please close the config file', 'Critical')

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at recipe file saved function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def No_preview_found(self, time_start=""):
        try:
            """
               This method is used to clear the preview label.
               param lists: None.
               return: None
            """
            self.msg_box_call("", "", "")
            self.push_button_timer.timeout.connect(self.check_two_hand_button_press)
            self.image_preview.setAlignment(Qt.AlignCenter)
            self.image_preview.setPixmap(QtGui.QPixmap(r".\media\No-Preview-Available.jpg"))
            self.figure.clear()
            try:
                self.mtf_graph_verticalLayout.removeWidget(self.canvas)
            except Exception as e:
                logger.error("unable to remove mtf graph preview label")

            self.figure = plt.figure()
            self.canvas = FigureCanvas(self.figure)
            self.ax = self.figure.add_subplot(111)

            image_path = r".\media\plot_graph.png"
            preview = imread(image_path)
            self.ax.imshow(preview)
            self.ax.set_title('MTF graph')
            self.ax.axis('off')
            self.mtf_graph_verticalLayout.addWidget(self.canvas)
            self.mtf_grpah_widget.setLayout(self.mtf_graph_verticalLayout)
            self.base_serial_lnedt.clear()
            self.mod_serial_lnedt.clear()
            self.product_serial_lnedt.clear()
            self.init_btn.setEnabled(True)
            self.select_recipe_btn.setEnabled(True)
            self.btn_start.setEnabled(True)
            self.step_run_btn.setEnabled(True)
            self.machine_cntrl_btn.setEnabled(True)
            self.machine_cntrl_btn.machine_menu.setEnabled(True)
            self.user_setting.setEnabled(True)
            self.glue_teach_btn.setEnabled(True)
            self.main_page_abort_btn.setEnabled(False)
            self.logout_btn.setEnabled(True)
            self.init_btn.setEnabled(True)
            self.mod_serial_lnedt.setReadOnly(False)
            self.base_serial_lnedt.setReadOnly(False)
            self.product_serial_lnedt.setReadOnly(False)
            self.timer = False
            self.abort_auto_sequence_clicked = False
            self.update_yield()
            self.update_station_position(7)
            self.progress_bar.setValue(0)
            if time_start == "":
                if self.is_config_loaded and self.ready_port and not self.push_button_timer.isActive() and \
                        self.is_all_homing:
                    self.push_button_timer.start()
            if self.is_config_loaded:
                line_edit_list = ["Module Serial No.", "Base Serial No.", "Product Serial No."]
                find_item = []
                for x in line_edit_list:
                    if not pd.isna(self.excel[x]["Product details"]):
                        find_item.append(x)
                found_line_edit = self.findChild(QLineEdit, find_item[0])
                found_line_edit.setFocus()
            ui.first_start_btn_clicked = False
            logger.info("Reset preview - Successfully!")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at No_preview_found function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                   exc_tb.tb_lineno, e))

    def No_preview_window_found_recipe_page(self):
        try:
            """
               This method is used to clear the preview label in recipe creation page.
               param lists: None.
               return: None
            """
            self.image_preview_1.setAlignment(Qt.AlignCenter)
            self.image_preview_1.setPixmap(QtGui.QPixmap(r".\media\No-Preview-Available.jpg"))

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at No_preview_window_recipe_page function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                                exc_tb.tb_lineno, e))

    @staticmethod
    def stop_duplicate_window():
        try:
            """
               This method is used to stop the duplicate application open.
               param lists: None.
               return: None
            """
            now = datetime.datetime.now()
            curdate = now.strftime("%Y%m%d%H%M%S%f")
            base_dir = os.getenv('LOCALAPPDATA').replace("\\", "/")
            if os.path.exists(base_dir):
                task_path = '{}/{}'.format(base_dir, curdate)
                duplicate_window_counter = 0
                os.system('tasklist > ' + "\"" + task_path + '.txt' + "\"")
                with open(task_path + '.txt', 'r') as Activetaskslist:
                    for line in Activetaskslist:
                        if line.startswith('e-ZeeFocus_') or line.startswith('e-ZeeFocus_App'):
                            duplicate_window_counter += 1

                        elif duplicate_window_counter >= 2:
                            logger.debug("duplicate_window_counter: {}".format(duplicate_window_counter))
                            logger.info("Windows opened more than one")
                            duplicate_window_counter = 0
                            Activetaskslist.close()
                            os.remove(task_path + '.txt')
                            sys.exit()
                    else:
                        Activetaskslist.close()
                        os.remove(task_path + '.txt')
            else:
                logger.error("The base directory path is not exist to find stop_duplicate_window: {}".format(base_dir))

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at stop_duplicate_window function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def update_imageToLbl(self, q_img):
        try:
            """
               This method is used to show the updated mtf calculation frame.
               param lists: q_img is object datatype.
               return: None
            """
            self.image_preview.setAlignment(Qt.AlignCenter)
            self.image_preview.setPixmap(QPixmap.fromImage(q_img))

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at update_imageToLbl function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                    exc_tb.tb_lineno, e))

    def fingerprint_update_lbl(self, q_img):
        try:
            """
               This method is used to show the updated fingerprint scanner video.
               param lists: q_img is object datatype.
               return: None
            """
            self.scanning_lbl.setAlignment(Qt.AlignCenter)
            self.scanning_lbl.setPixmap(q_img)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at fingerprint_update_lbl function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                         exc_tb.tb_lineno, e))

    def update_imageToLbl_1(self, q_img):
        try:
            """
               This method is used to display the frame in recipe creation page.
               param lists: q_img is object datatype.
               return: None
            """
            self.image_preview_1.setAlignment(Qt.AlignCenter)
            self.image_preview_1.setPixmap(QPixmap.fromImage(q_img))

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at update_imageToLbl_1 function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                      exc_tb.tb_lineno, e))

    def check_two_hand_button_press(self):
        try:
            """
               This method is used to get the two hand push button command or start button clicked event.
               param lists: None.
               return: None
            """
            status = ui_plc_communication.plc_control_class.serial_port.read(
                ui_plc_communication.plc_control_class.serial_port.inWaiting()).decode('utf-8', 'ignore')

            if 'K:STS\r\n' in status or self.start_button_clicked:
                if 'K:STS\r\n' in status:
                    logger.info("Two hand push button pressed: {}".format(status))
                else:
                    logger.info("User clicked start button")

                return_value = self.start_btn_streaming()
                if return_value:
                    self.push_button_timer.stop()
                    if pd.isna(self.excel["Module Serial No."]['Product details']):
                        self.mod_serial = "NA"
                    else:
                        self.mod_serial = self.mod_serial_lnedt.text()
                        logger.info("Mod board Serial No {}".format(self.mod_serial))

                    if pd.isna(self.excel["Base Serial No."]['Product details']):
                        self.base_serial = "NA"
                    else:
                        self.base_serial = self.base_serial_lnedt.text()
                        logger.info("Base board Serial No {}".format(self.base_serial))

                    if pd.isna(self.excel["Product Serial No."]['Product details']):
                        self.product_serial = "NA"
                    else:
                        self.product_serial = self.product_serial_lnedt.text()
                        logger.info("Base board Serial No {}".format(self.product_serial))
                    self.start_button_clicked = False
                    self.push_button_timer.stop()
                    self.progress_bar.setValue(0)
                    self.select_recipe_btn.setEnabled(False)
                    self.btn_start.setEnabled(False)
                    self.step_run_btn.setEnabled(False)
                    self.machine_cntrl_btn.setEnabled(False)
                    self.user_setting.setEnabled(False)
                    self.glue_teach_btn.setEnabled(False)
                    self.main_page_abort_btn.setEnabled(True)
                    self.init_btn.setEnabled(False)
                    self.logout_btn.setEnabled(False)
                    self.mod_serial_lnedt.setReadOnly(True)
                    self.base_serial_lnedt.setReadOnly(True)
                    self.product_serial_lnedt.setReadOnly(True)
                    item = QtWidgets.QTableWidgetItem(str("In progress"))
                    item.setTextAlignment(Qt.AlignCenter)
                    item.setForeground(QColor(245, 100, 20))
                    self.tableWidget.setItem(3, 1, item)
                    self.run_thread()

                else:
                    self.start_button_clicked = False

            if self.timer:
                if self.push_button_timer.isActive():
                    self.push_button_timer.stop()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at check_two_hand_button_press function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                              exc_tb.tb_lineno, e))

    def create_folder_structure(self, camera_name):
        try:
            """
               This method is used to create folder structure for reports.
               param lists: None.
               return: None
            """
            is_check_d_colon = os.path.exists("D" + ':\\')
            if is_check_d_colon:
                d_drive_path = "D:\\e-con Systems\\e-ZeeFocus Application"
                e_con_sys = os.path.isdir(d_drive_path)
                if not e_con_sys:
                    os.makedirs(d_drive_path)
                part_directory = os.path.isdir(f"{d_drive_path}\\{camera_name}")
                if not part_directory:
                    os.makedirs(f"{d_drive_path}\\{camera_name}")
                current_date = datetime.date.today()
                check_current_date = os.path.isdir(
                    f"{d_drive_path}\\{camera_name}\\{current_date}")
                if not check_current_date:
                    os.makedirs(f"{d_drive_path}\\{camera_name}\\{current_date}")
                if not os.path.exists(f"{d_drive_path}\\{camera_name}\\{current_date}\\Passed"):
                    os.makedirs(f"{d_drive_path}\\{camera_name}\\{current_date}\\Passed")
                if not os.path.exists(f"{d_drive_path}\\{camera_name}\\{current_date}\\Failed"):
                    os.makedirs(f"{d_drive_path}\\{camera_name}\\{current_date}\\Failed")
                if not os.path.exists(f"{d_drive_path}\\{camera_name}\\{current_date}\\Intermediate"):
                    os.makedirs(f"{d_drive_path}\\{camera_name}\\{current_date}\\Intermediate")
                if not os.path.exists(f"{d_drive_path}\\{camera_name}\\{current_date}\\Images"):
                    os.makedirs(f"{d_drive_path}\\{camera_name}\\{current_date}\\Images")
                return f"{d_drive_path}\\{camera_name}\\{current_date}\\Images"

            else:
                c_drive_path = "C:\\Documents\\e-con Systems\\e-ZeeFocus Application"
                e_con_sys = os.path.isdir(c_drive_path)
                if not e_con_sys:
                    os.makedirs(c_drive_path)
                part_directory = os.path.isdir(f"{c_drive_path}\\{camera_name}")
                if not part_directory:
                    os.makedirs(f"{c_drive_path}\\{camera_name}")
                current_date = datetime.date.today()
                check_current_date = os.path.isdir(f"{c_drive_path}\\{camera_name}\\{current_date}")
                if not check_current_date:
                    os.makedirs(f"{c_drive_path}\\{camera_name}\\{current_date}")
                if not os.path.exists(f"{c_drive_path}\\{camera_name}\\{current_date}\\Passed"):
                    os.makedirs(f"{c_drive_path}\\{camera_name}\\{current_date}\\Passed")
                if not os.path.exists(f"{c_drive_path}\\{camera_name}\\{current_date}\\Failed"):
                    os.makedirs(f"{c_drive_path}\\{camera_name}\\{current_date}\\Failed")
                if not os.path.exists(f"{c_drive_path}\\{camera_name}\\{current_date}\\Intermediate"):
                    os.makedirs(f"{c_drive_path}\\{camera_name}\\{current_date}\\Intermediate")
                if not os.path.exists(f"{c_drive_path}\\{camera_name}\\{current_date}\\Images"):
                    os.makedirs(f"{c_drive_path}\\{camera_name}\\{current_date}\\Images")
                return f"{c_drive_path}\\{camera_name}\\{current_date}\\Images"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at create folder structure function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                          exc_tb.tb_lineno, e))

    def update_excel(self, result_list, end_time, overall_result_dict, validation_status):
        try:
            """
               This method is used to append the results to the excel.
               param lists: result_list datatype is list, end_time datatype is datetime, 
               overall_result_dict datatype is dict, validation_status datatype is object.
               return: None
            """
            now = datetime.datetime.now()
            val_date = now.strftime("%Y-%m-%d")
            result_list = list(chain(*result_list))
            addition_info = None

            if len(result_list) != 18:  # with regions 78 column without regions 18
                for x in range(abs(len(result_list) - 18)):
                    result_list.append("NA")

            for x in overall_result_dict.values():
                result_list.append(x)

            addition_info = [self.app_version, val_date, self.product_name,
                             self.excel["Firmware Version"]["Product details"],
                             self.excel["Resolution"]["Product details"], self.setup_type]

            if not pd.isna(self.excel["Product Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Module Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Base Serial No."]["Product details"]):
                mtf_data = [self.start_val_time, end_time, self.user_name, self.mod_serial, self.base_serial,
                            self.product_serial]

                """if Mod board and Base board is True"""
            elif pd.isna(self.excel["Product Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Module Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Base Serial No."]["Product details"]):
                mtf_data = [self.start_val_time, end_time, self.user_name, self.mod_serial, self.base_serial, "NA"]

                """if mod board and Product serial is True"""
            elif not pd.isna(self.excel["Product Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Module Serial No."]["Product details"]) and \
                    pd.isna(self.excel["Base Serial No."]["Product details"]):
                mtf_data = [self.start_val_time, end_time, self.user_name, self.mod_serial, "NA", self.product_serial]

                """if base board and Product serial is True"""
            elif not pd.isna(self.excel["Product Serial No."]["Product details"]) and \
                    pd.isna(self.excel["Module Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Base Serial No."]["Product details"]):
                mtf_data = [self.start_val_time, end_time, self.user_name, "NA", self.base_serial, self.product_serial]

                """if only Mod board is True"""
            elif pd.isna(self.excel["Product Serial No."]["Product details"]) and \
                    pd.isna(self.excel["Base Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Module Serial No."]["Product details"]):
                mtf_data = [self.start_val_time, end_time, self.user_name, self.mod_serial, "NA", "NA"]

                """if only Base board is True"""
            elif pd.isna(self.excel["Product Serial No."]["Product details"]) and \
                    pd.isna(self.excel["Module Serial No."]["Product details"]) and not \
                    pd.isna(self.excel["Base Serial No."]["Product details"]):
                mtf_data = [self.start_val_time, end_time, self.user_name, "NA", self.base_serial, "NA"]

                """if only product serial is True"""
            elif not pd.isna(self.excel["Product Serial No."]["Product details"]) and \
                    pd.isna(self.excel["Module Serial No."]["Product details"]) and \
                    pd.isna(self.excel["Base Serial No."]["Product details"]):
                mtf_data = [self.start_val_time, end_time, self.user_name, "NA", "NA", self.product_serial]

            for i in result_list:
                mtf_data.append(i)

            if validation_status == "Failed":
                if self.failed_excel_obj.isFileOpened():
                    self.excel_closed = False
                    self.msg_box_call("Permission Denied!",
                                      "Unable to access the excel file \"MTF_Validation.xlsx\". Kindly close the file "
                                      "and continue with validation <br><br> <b>Note:</b> Hence validated "
                                      "data will not be saved properly", "Critical")
                else:
                    self.failed_excel_obj.write_data(basic_details=addition_info, mtf_data=mtf_data)

            elif validation_status:
                if self.passed_excel_obj.isFileOpened():
                    self.excel_closed = False
                    self.msg_box_call("Permission Denied!",
                                      "Unable to access the excel file \"MTF_Validation.xlsx\". Kindly close the file "
                                      "and continue with validation <br><br> <b>Note:</b> Hence validated "
                                      "data will not be saved properly", "Critical")
                else:
                    self.passed_excel_obj.write_data(basic_details=addition_info, mtf_data=mtf_data)

            elif not validation_status:
                if self.intermediate_excel_obj.isFileOpened():
                    self.excel_closed = False
                    self.msg_box_call("Permission Denied!",
                                      "Unable to access the excel file \"MTF_Validation.xlsx\". Kindly close the file "
                                      "and continue with validation <br><br> <b>Note:</b> Hence validated "
                                      "data will not be saved properly", "Critical")
                else:
                    self.intermediate_excel_obj.write_data(basic_details=addition_info, mtf_data=mtf_data)

            else:
                logger.debug("Couldn't find the excel object.")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at update_excel function : {}|{}|{}|{}".format(exc_type, fname,
                                                                               exc_tb.tb_lineno, e))

    def update_result(self, org_image, mtf_result_img, glue_time, withoutdb_8bit):
        try:
            """
               This method is used to save the results and original images.
               param lists: org_image datatype is object, mtf_result_img datatype is object, 
               glue_time datatype is str, withoutdb_8bit datatype is object.
               return: None
            """
            now = datetime.datetime.now()
            """Mod board, Base board, Product serial is True"""
            if self.is_config_loaded and not pd.isna(self.excel["Product Serial No."]['Product details']) and not \
                    pd.isna(self.excel["Module Serial No."]['Product details']) and not \
                    pd.isna(self.excel["Base Serial No."]['Product details']):
                result_name = "{}_{}".format(self.mod_serial, now.strftime("%H%M%S"))

                """if Mod board and Base board is True"""
            elif self.is_config_loaded and pd.isna(self.excel["Product Serial No."]['Product details']) and not \
                    pd.isna(self.excel["Module Serial No."]['Product details']) and not \
                    pd.isna(self.excel["Base Serial No."]['Product details']):
                result_name = "{}_{}".format(self.mod_serial, now.strftime("%H%M%S"))

                """if Mod board is True"""
            elif pd.isna(self.excel["Product Serial No."]['Product details']) and \
                    pd.isna(self.excel["Base Serial No."]['Product details']) and not \
                    pd.isna(self.excel["Module Serial No."]['Product details']):
                result_name = "{}_{}".format(self.mod_serial, now.strftime("%H%M%S"))

                """if Base board is True"""
            elif pd.isna(self.excel["Product Serial No."]['Product details']) and \
                    pd.isna(self.excel["Module Serial No."]['Product details']) and not \
                    pd.isna(self.excel["Base Serial No."]['Product details']):
                result_name = "{}_{}".format(self.base_serial, now.strftime("%H%M%S"))

                """if only product serial is True"""
            elif not pd.isna(self.excel["Product Serial No."]['Product details']) and \
                    pd.isna(self.excel["Module Serial No."]['Product details']) and \
                    pd.isna(self.excel["Base Serial No."]['Product details']):
                result_name = "{}_{}".format(self.product_serial, now.strftime("%H%M%S"))

                """if base board and Product serial is True"""
            elif not pd.isna(self.excel["Product Serial No."]['Product details']) and \
                    pd.isna(self.excel["Module Serial No."]['Product details']) and not \
                    pd.isna(self.excel["Base Serial No."]['Product details']):
                result_name = "{}_{}".format(self.base_serial, now.strftime("%H%M%S"))

                """if mod board and Product serial is True"""
            elif not pd.isna(self.excel["Product Serial No."]['Product details']) and not \
                    pd.isna(self.excel["Module Serial No."]['Product details']) and \
                    pd.isna(self.excel["Base Serial No."]['Product details']):
                result_name = "{}_{}".format(self.mod_serial, now.strftime("%H%M%S"))

            if not cv2.imwrite("{}\\{}_MTF_{}_result.bmp".format(self.folder_path, result_name, glue_time),
                               mtf_result_img):
                logger.debug('Result image not saved')
            if self.mtf_excel["Raw FW"].split(",")[0] == "CN":
                org_image = cv2.cvtColor(withoutdb_8bit, cv2.COLOR_GRAY2BGR)

            if not cv2.imwrite("{}\\{}_{}.bmp".format(self.folder_path, result_name, glue_time), org_image):
                logger.debug('Original image not saved')

            if self.excel["Raw image"][self.setup_type]:
                if glue_time == "before_glue":
                    f = open("{}\\{}_{}.raw".format(self.folder_path, result_name, glue_time), "wb+")
                    f.write(withoutdb_8bit)
                    f.close()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at update_result function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def load_config(self, path=''):
        try:
            """
              This method is used to verify the loaded config file.
              param lists: path datatype is str
              return: None
            """
            if path != "":
                excel = pd.read_excel(path)
                v = excel.to_dict()
                excel = {}
                for x in v.keys():
                    if not x.startswith("Un"):
                        excel[x] = {}
                p = []
                for x in v.keys():
                    if x.startswith("Un"):
                        p.append(list(v[x].values()))

                for i in excel:
                    for x in v[i].values():
                        if not pd.isna(x):
                            excel[i][x] = None

                cleaned_data = []
                count = 0
                for sublist in p:
                    if any(pd.notna(item) for item in sublist):
                        cleaned_sublist = []
                        for item in sublist:
                            if count == 0:
                                cleaned_sublist.extend(sublist[:15])
                                count += 1
                                break
                            elif pd.notna(item):
                                cleaned_sublist.append(item)
                        cleaned_data.append(cleaned_sublist)

                count = 0
                for x in excel.keys():
                    keys = excel[x].keys()
                    for key, value in zip(keys, cleaned_data[count]):
                        excel[x][key] = value
                    count += 1

                self.excel = {}
                for i in excel:
                    for x in excel[i]:
                        self.excel[x] = {i: excel[i][x]}

                if os.path.isfile(r".\media\MTF Rotation config file.xlsx"):
                    excel = pd.read_excel(r".\media\MTF Rotation config file.xlsx", sheet_name=0)
                    v = excel.to_dict()
                    self.rotation_excel = dict()
                    for x in v.values():
                        for i in x.values():
                            self.rotation_excel[i] = ""
                        break
                    for x, y in zip(self.rotation_excel, v["Values"].values()):
                        self.rotation_excel[x] = y

                    excel = pd.read_excel(r".\media\MTF Rotation config file.xlsx", sheet_name=1)
                    v = excel.to_dict()
                    self.mtf_excel = dict()
                    for x in v.values():
                        for i in x.values():
                            self.mtf_excel[i] = ""
                        break
                    for x, y in zip(self.mtf_excel, v["Values"].values()):
                        self.mtf_excel[x] = y

                    self.mtf_excel = {key: self.convert_to_bool_or_original(value) for key, value in
                                      self.mtf_excel.items()}
                else:
                    logger.error("Rotation config file is not exist in the path.")
                    self.msg_box_call("Permission Denied!",
                                      "Rotation config file is not exist in the path.", "Critical")
                    return

                try:
                    self.resolution = self.excel["Resolution"]["Product details"].split("x")
                    if self.resolution[0].isdigit() and self.resolution[1].isdigit():
                        self.centre = [int(self.resolution[0]) // 2, int(self.resolution[1]) // 2]
                    else:
                        logger.error('Resolution is incorrect.')
                        self.msg_box_call("Permission Denied!", "Resolution is incorrect.", "Critical")
                        self.is_config_loaded = False
                        return

                    rgb_values = self.mtf_excel["RGB values"].replace(" ", "")
                    self.rgb_values = rgb_values.split(",")  # Another config
                    if self.rgb_values[0].isdigit() and self.rgb_values[1].isdigit() and self.rgb_values[2].isdigit():
                        logger.error('RGB values are correct')
                    else:
                        logger.error('RGB values are incorrect.')
                        self.msg_box_call("Permission Denied!", "RGB values is incorrect.", "Critical")
                        self.is_config_loaded = False
                        return

                    self.camera_name = self.excel["Camera name"]["Product details"]
                    if self.camera_name == "" or self.camera_name is None:
                        logger.error('Camera name is not found')
                        self.msg_box_call("Permission Denied!", "Camera name is not found.", "Critical")
                        self.is_config_loaded = False
                        return

                    self.expo = self.excel["Exposure"]["Product details"]
                    if self.expo == "" or self.expo is None:
                        logger.error('Exposure is not found')
                        self.msg_box_call("Permission Denied!", "Exposure is not found.", "Critical")
                        self.is_config_loaded = False

                    if bool(self.excel["Relay Status"]["Relay station"]) and \
                            bool(self.excel["Collimator Status"]["Collimator station"]):
                        logger.error("Both focus stations are enabled in config file")
                        self.msg_box_call("Permission Denied!", "Both focus stations are enabled in config file",
                                          "Critical")
                        self.is_config_loaded = False
                        return

                    elif not bool(self.excel["Relay Status"]["Relay station"]) and \
                            not bool(self.excel["Collimator Status"]["Collimator station"]):
                        logger.error("Both focus stations are disabled in config file")
                        self.msg_box_call("Permission Denied!", "Both focus stations are disabled in config file",
                                          "Critical")
                        self.is_config_loaded = False
                        return

                    # Another config
                    elif bool(self.mtf_excel["Center avg only"]) and \
                            bool(self.mtf_excel["Corners all region avg"]) and \
                            bool(self.mtf_excel["Center avg and Corners all region avg"]) and \
                            bool(self.mtf_excel["Corners each region avg"]) and \
                            bool(self.mtf_excel["Center and Corners each region avg"]) and \
                            bool(self.mtf_excel["Overall avg"]):
                        logger.error("All criteria cases are enable")
                        self.msg_box_call("Permission Denied!", "Choose anyone Pass/Fail criteria",
                                          "Critical")
                        self.is_config_loaded = False
                        return

                    elif not bool(self.mtf_excel["Center avg only"]) and not \
                            bool(self.mtf_excel["Corners all region avg"]) and not \
                            bool(self.mtf_excel["Center avg and Corners all region avg"]) and not \
                            bool(self.mtf_excel["Corners each region avg"]) and not \
                            bool(self.mtf_excel["Center and Corners each region avg"]) and not \
                            bool(self.mtf_excel["Overall avg"]):
                        logger.error("All criteria cases are disable")
                        self.msg_box_call("Permission Denied!", "Please enable anyone Pass/Fail criteria",
                                          "Critical")
                        self.is_config_loaded = False
                        return

                    elif bool(self.excel["Relay Status"]["Relay station"]):
                        self.setup_type = "Relay station"
                        if "".join(list(str(self.mtf_excel["MTF threshold value"]).split(
                                "."))).isdigit():  # Another config
                            self.c_mtf_threshold = float(self.mtf_excel["MTF threshold value"])
                        else:
                            logger.error("MTF threshold value is incorrect in config file")
                            self.msg_box_call("Permission Denied!", "MTF threshold value is incorrect in config file",
                                              "Critical")
                            self.is_config_loaded = False
                            return

                        # Another config
                        if "".join(list(str(self.mtf_excel["Center avg criteria"]).split("."))).isdigit():
                            self.center_criteria_mtf_threshold = float(self.mtf_excel["Center avg criteria"])

                        else:
                            logger.error("Center avg criteria is incorrect in config file")
                            self.msg_box_call("Permission Denied!",
                                              "Center avg criteria is incorrect in config file",
                                              "Critical")
                            self.is_config_loaded = False
                            return

                        if "".join(list(str(self.mtf_excel["TL avg criteria"]).split("."))).isdigit():
                            self.tl_mtf_threshold = float(self.mtf_excel["TL avg criteria"])

                        else:
                            logger.error("Tl avg criteria is incorrect in config file")
                            self.msg_box_call("Permission Denied!",
                                              "TL avg criteria is incorrect in config file",
                                              "Critical")
                            self.is_config_loaded = False
                            return

                        if "".join(list(str(self.mtf_excel["TR avg criteria"]).split("."))).isdigit():
                            self.tr_mtf_threshold = float(self.mtf_excel["TR avg criteria"])
                        else:
                            logger.error("TR avg criteria is incorrect in config file")
                            self.msg_box_call("Permission Denied!",
                                              "TR avg criteria is incorrect in config file",
                                              "Critical")
                            self.is_config_loaded = False
                            return

                        if "".join(list(str(self.mtf_excel["BL avg criteria"]).split("."))).isdigit():
                            self.bl_mtf_threshold = float(self.mtf_excel["BL avg criteria"])
                        else:
                            logger.error("BL avg criteria is incorrect in config file")
                            self.msg_box_call("Permission Denied!",
                                              "BL avg criteria is incorrect in config file",
                                              "Critical")
                            self.is_config_loaded = False
                            return

                        if "".join(list(str(self.mtf_excel["BR avg criteria"]).split("."))).isdigit():
                            self.br_mtf_threshold = float(self.mtf_excel["BR avg criteria"])
                        else:
                            logger.error("BR avg criteria is incorrect in config file")
                            self.msg_box_call("Permission Denied!",
                                              "BR avg criteria is incorrect in config file",
                                              "Critical")
                            self.is_config_loaded = False
                            return

                        self.focus_station_y_value = float(self.excel["Y-Actuator Relay"]["Relay station"])
                        self.focus_station_x_value = float(self.excel["X-Actuator Relay"]["Relay station"])

                    else:
                        self.setup_type = "Collimator station"
                        logger.info("Focus stations is Collimator in config file")
                        if "".join(list(str(self.mtf_excel["MTF threshold value"]).split(
                                "."))).isdigit():  # Another config
                            self.c_mtf_threshold = float(self.mtf_excel["MTF threshold value"])
                        else:
                            logger.error("MTF threshold value is incorrect in config file")
                            self.msg_box_call("Permission Denied!", "MTF threshold value is incorrect in config file",
                                              "Critical")
                            self.is_config_loaded = False
                            return

                        if "".join(list(str(self.mtf_excel["Center avg criteria"]).split("."))).isdigit():
                            self.center_criteria_mtf_threshold = float(self.mtf_excel["Center avg criteria"])

                        else:
                            logger.error("Center avg criteria is incorrect in config file")
                            self.msg_box_call("Permission Denied!",
                                              "Center avg criteria is incorrect in config file",
                                              "Critical")
                            self.is_config_loaded = False
                            return

                        if "".join(list(str(self.mtf_excel["TL avg criteria"]).split("."))).isdigit():
                            self.tl_mtf_threshold = float(self.mtf_excel["TL avg criteria"])

                        else:
                            logger.error("Tl avg criteria is incorrect in config file")
                            self.msg_box_call("Permission Denied!",
                                              "TL avg criteria is incorrect in config file",
                                              "Critical")
                            self.is_config_loaded = False
                            return

                        if "".join(list(str(self.mtf_excel["TR avg criteria"]).split("."))).isdigit():
                            self.tr_mtf_threshold = float(self.mtf_excel["TR avg criteria"])
                        else:
                            logger.error("TR avg criteria is incorrect in config file")
                            self.msg_box_call("Permission Denied!",
                                              "TR avg criteria is incorrect in config file",
                                              "Critical")
                            self.is_config_loaded = False
                            return

                        if "".join(list(str(self.mtf_excel["BL avg criteria"]).split("."))).isdigit():
                            self.bl_mtf_threshold = float(self.mtf_excel["BL avg criteria"])
                        else:
                            logger.error("BL avg criteria is incorrect in config file")
                            self.msg_box_call("Permission Denied!",
                                              "BL avg criteria is incorrect in config file",
                                              "Critical")
                            self.is_config_loaded = False
                            return

                        if "".join(list(str(self.mtf_excel["BR avg criteria"]).split("."))).isdigit():
                            self.br_mtf_threshold = float(self.mtf_excel["BR avg criteria"])
                        else:
                            logger.error("BR avg criteria is incorrect in config file")
                            self.msg_box_call("Permission Denied!",
                                              "BR avg criteria is incorrect in config file",
                                              "Critical")
                            self.is_config_loaded = False
                            return

                        self.focus_station_y_value = float(self.excel["Y-Actuator Collimator"]["Collimator station"])
                        self.focus_station_x_value = float(self.excel["X-Actuator Collimator"]["Collimator station"])

                        self.collimator_tr_intensity = int(self.excel["Collimator TR intensity"]["Collimator station"])
                        self.collimator_br_intensity = int(self.excel["Collimator BR intensity"]["Collimator station"])
                        self.collimator_bl_intensity = int(self.excel["Collimator BL intensity"]["Collimator station"])
                        self.collimator_tl_intensity = int(self.excel["Collimator TL intensity"]["Collimator station"])
                        self.collimator_c_intensity = int(self.excel["Collimator C intensity"]["Collimator station"])

                        self.collimator_list_items = [self.collimator_tr_intensity, self.collimator_br_intensity,
                                                      self.collimator_bl_intensity,
                                                      self.collimator_tl_intensity, self.collimator_c_intensity]
                        self.collimator_light_type = self.excel["Collimator light type"]["Collimator station"]

                    self.product_name = self.excel["Product name"]["Product details"]
                    if self.product_name == "" or self.product_name is None:
                        logger.error('product_name is not found')
                        self.msg_box_call("Permission Denied!", "Product name is not found.", "Critical")
                        self.is_config_loaded = False

                    if pd.isna(self.excel["Product Serial No."]["Product details"]) and \
                            pd.isna(self.excel["Module Serial No."]["Product details"]) and \
                            pd.isna(self.excel["Base Serial No."]["Product details"]):
                        logger.error('All Serial_no text_boxes are hide')
                        self.msg_box_call("Permission Denied!", "Please enable the any one serial_no textbox",
                                          "Critical")
                        self.is_config_loaded = False
                        return

                    elif not pd.isna(self.excel["Product Serial No."]["Product details"]) and not \
                            pd.isna(self.excel["Module Serial No."]["Product details"]) and not \
                            pd.isna(
                                self.excel["Base Serial No."][
                                    "Product details"]):  # Mod board, Base board, Product serial True
                        self.product_serial_lnedt.show()
                        self.product_serial_lbl.show()
                        self.mod_serial_lnedt.show()
                        self.mod_serial_lbl.show()
                        self.base_serial_lnedt.show()
                        self.base_serial_lbl.show()

                        self.mod_serial_lbl.setGeometry(QtCore.QRect(25, 190, 250, 15))
                        self.mod_serial_lnedt.setGeometry(QtCore.QRect(25, 210, 250, 40))

                        self.base_serial_lbl.setGeometry(QtCore.QRect(25, 260, 250, 15))
                        self.base_serial_lnedt.setGeometry(QtCore.QRect(25, 280, 250, 40))

                        self.product_serial_lbl.setGeometry(QtCore.QRect(25, 330, 250, 15))
                        self.product_serial_lnedt.setGeometry(QtCore.QRect(25, 350, 250, 40))

                        """if Mod board and Base board is True"""
                    elif pd.isna(self.excel["Product Serial No."]["Product details"]) and not \
                            pd.isna(self.excel["Module Serial No."]["Product details"]) and not \
                            pd.isna(self.excel["Base Serial No."]["Product details"]):
                        self.product_serial_lnedt.hide()
                        self.product_serial_lbl.hide()
                        self.mod_serial_lnedt.show()
                        self.mod_serial_lbl.show()
                        self.base_serial_lnedt.show()
                        self.base_serial_lbl.show()
                        self.mod_serial_lbl.setGeometry(QtCore.QRect(25, 190, 250, 15))
                        self.mod_serial_lnedt.setGeometry(QtCore.QRect(25, 210, 250, 40))

                        self.base_serial_lbl.setGeometry(QtCore.QRect(25, 260, 250, 15))
                        self.base_serial_lnedt.setGeometry(QtCore.QRect(25, 280, 250, 40))

                        """if mod board and Product serial is True"""
                    elif not pd.isna(self.excel["Product Serial No."]["Product details"]) and not \
                            pd.isna(self.excel["Module Serial No."]["Product details"]) and \
                            pd.isna(self.excel["Base Serial No."]["Product details"]):
                        self.product_serial_lnedt.show()
                        self.product_serial_lbl.show()

                        self.mod_serial_lbl.show()
                        self.mod_serial_lnedt.show()

                        self.base_serial_lnedt.hide()
                        self.base_serial_lbl.hide()

                        self.mod_serial_lbl.setGeometry(QtCore.QRect(25, 190, 250, 15))
                        self.mod_serial_lnedt.setGeometry(QtCore.QRect(25, 210, 250, 40))

                        self.product_serial_lbl.setGeometry(QtCore.QRect(25, 260, 250, 15))
                        self.product_serial_lnedt.setGeometry(QtCore.QRect(25, 280, 250, 40))

                        """if base board and Product serial is True"""
                    elif not pd.isna(self.excel["Product Serial No."]["Product details"]) and \
                            pd.isna(self.excel["Module Serial No."]["Product details"]) and not \
                            pd.isna(self.excel["Base Serial No."]["Product details"]):
                        self.product_serial_lnedt.show()
                        self.product_serial_lbl.show()

                        self.base_serial_lnedt.show()
                        self.base_serial_lbl.show()

                        self.mod_serial_lbl.hide()
                        self.mod_serial_lnedt.hide()

                        self.base_serial_lbl.setGeometry(QtCore.QRect(25, 190, 250, 15))
                        self.base_serial_lnedt.setGeometry(QtCore.QRect(25, 210, 250, 40))

                        self.product_serial_lbl.setGeometry(QtCore.QRect(25, 260, 250, 15))
                        self.product_serial_lnedt.setGeometry(QtCore.QRect(25, 280, 250, 40))

                        """if Mod board is True"""
                    elif pd.isna(self.excel["Product Serial No."]["Product details"]) and \
                            pd.isna(self.excel["Base Serial No."]["Product details"]) and not \
                            pd.isna(self.excel["Module Serial No."]["Product details"]):
                        self.product_serial_lnedt.hide()
                        self.product_serial_lbl.hide()

                        self.base_serial_lnedt.hide()
                        self.base_serial_lbl.hide()

                        self.mod_serial_lbl.show()
                        self.mod_serial_lnedt.show()

                        self.mod_serial_lbl.setGeometry(QtCore.QRect(25, 190, 250, 15))
                        self.mod_serial_lnedt.setGeometry(QtCore.QRect(25, 210, 250, 40))

                        """if Base board is True"""
                    elif pd.isna(self.excel["Product Serial No."]["Product details"]) and \
                            pd.isna(self.excel["Module Serial No."]["Product details"]) and not \
                            pd.isna(self.excel["Base Serial No."]["Product details"]):
                        self.product_serial_lnedt.hide()
                        self.product_serial_lbl.hide()

                        self.mod_serial_lbl.hide()
                        self.mod_serial_lnedt.hide()

                        self.base_serial_lnedt.show()
                        self.base_serial_lbl.show()

                        self.base_serial_lbl.setGeometry(QtCore.QRect(25, 190, 250, 15))
                        self.base_serial_lnedt.setGeometry(QtCore.QRect(25, 210, 250, 40))

                        """if only product serial is True"""
                    elif not pd.isna(self.excel["Product Serial No."]["Product details"]) and \
                            pd.isna(self.excel["Module Serial No."]["Product details"]) and \
                            pd.isna(self.excel["Base Serial No."]["Product details"]):
                        self.product_serial_lnedt.show()
                        self.product_serial_lbl.show()

                        self.mod_serial_lbl.hide()
                        self.mod_serial_lnedt.hide()

                        self.base_serial_lnedt.hide()
                        self.base_serial_lbl.hide()

                        self.product_serial_lbl.setGeometry(QtCore.QRect(25, 190, 250, 15))
                        self.product_serial_lnedt.setGeometry(QtCore.QRect(25, 210, 250, 40))

                    line_edit_list = ["Module Serial No.", "Base Serial No.", "Product Serial No."]
                    remove_item = []
                    for x in line_edit_list:
                        if not pd.isna(self.excel[x]["Product details"]):
                            remove_item.append(x)
                    found_line_edit = self.findChild(QLineEdit, remove_item[0])
                    found_line_edit.setFocus()

                except Exception as e:
                    exc_type, exc_obj, exc_tb = sys.exc_info()
                    fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
                    logger.error("Error while reading the config file : {}|{}|{}|{}".format(exc_type, fname,
                                                                                            exc_tb.tb_lineno, e))
                    self.msg_box_call("Permission Denied!", "Error while reading the config file.", "Critical")
                    self.is_config_loaded = False
                    return

                roi_status = self.roi_selection(setup_type=self.setup_type)
                if roi_status:
                    self.statusbar.setText("Config file is loaded")
                    self.product_name_lbl.setText("Product Name: {}".format(self.product_name))
                    if self.setup_type == "Relay station":
                        self.focus_station_z_value = self.excel["Z-Actuator Relay"]['Relay station']
                    if bool(self.excel["Gluing Status"]["Gluing station"]):
                        self.gluing_z_value = self.excel["Z-Actuator Gluing"]["Gluing station"]
                        self.gluing_z_reverse_value = self.excel["Z-Actuator reverse Gluing"]["Gluing station"]
                    if bool(self.excel["Curing Status"]["Curing station"]):
                        self.curing_z_value = self.excel["Z-Actuator Curing"]["Curing station"]
                        self.curing_z_reverse_value = self.excel["Z-Actuator reverse Curing"]["Curing station"]
                    self.update_yield()
                    item = QtWidgets.QTableWidgetItem(str("NA"))  # Validation
                    item.setTextAlignment(Qt.AlignCenter)
                    item.setForeground(QColor(245, 100, 20))
                    self.tableWidget.setItem(3, 1, item)
                    image_resolution = [int(self.resolution[1]), int(self.resolution[0])]
                    width_ratio = image_resolution[1] / image_resolution[0]
                    height_ratio = image_resolution[0] / image_resolution[1]
                    self.optimal_width = int(width_ratio * self.image_preview.geometry().height())
                    self.optimal_height = int(height_ratio * self.image_preview.geometry().width())
                    self.is_config_loaded = True
                    if not self.push_button_timer.isActive() and self.ready_port and self.is_all_homing:
                        self.push_button_timer.start()
                else:
                    self.statusbar.setText("Config file is error")
                    self.is_config_loaded = False
                    return
            else:
                if self.push_button_timer.isActive():
                    self.push_button_timer.stop()
                logger.error("Config file path is incorrect")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at load_config function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.msg_box_call("Permission Denied!", "Error while reading the config file.", "Critical")
            self.is_config_loaded = False
            return

    def convert_to_bool_or_original(self, value):
        try:
            """
              This method is used to convert the False or True str into bool.
              param lists: value datatype is str
              return: None
            """
            if isinstance(value, str) and value.strip().upper() in ['TRUE', 'FALSE']:
                return value.strip().upper() == 'TRUE'
            elif value in [0, 1]:
                return bool(value)
            return value

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at convert_to_bool_or_original function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno,
                                                                                     e))

    def roi_selection(self, setup_type):
        try:
            """
              This method is used to get the co-ordinates from the azimuth angle.
              param lists: setup_type datatype is str
              return: None
            """
            if setup_type == "Collimator station":
                roi_list = self.excel["Chart Position"]["Collimator station"].split(",")
                for x in roi_list:
                    if x not in ['TL', 'TR', 'C', 'BL', 'BR']:
                        logger.error('Chart position name is incorrect.')
                        self.msg_box_call("Permission Denied!", "Chart position name is incorrect.", "Critical")
                        return False

                if len(roi_list) == 5:
                    if str(self.excel["Outer Azimuth angle"]["Collimator station"]).replace(".", "", 1).isdigit() and \
                            str(self.excel["Outer Radius"]["Collimator station"]).replace(".", "", 1).isdigit() and \
                            str(self.excel["width"]["Collimator station"]).replace(".", "", 1).isdigit() and \
                            str(self.excel["height"]["Collimator station"]).replace(".", "", 1).isdigit():
                        self.rois["C"] = []
                        x = self.centre[0]
                        y = self.centre[1]
                        width = float(self.excel["width"]["Collimator station"])
                        height = float(self.excel["height"]["Collimator station"])
                        x1, y1 = [int(x - width / 2), int(y - height / 2)]
                        x2, y2 = [int(x + width / 2), int(y + height / 2)]
                        if (int(self.resolution[1]) >= y1 >= 0) and (int(self.resolution[1]) >= y2 >= 0) and \
                                (int(self.resolution[0]) >= x1 >= 0) and (int(self.resolution[0]) >= x2 >= 0):
                            self.rois["C"] = [y1, y2, x1, x2]

                        else:
                            logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                         "the config file at Center.")
                            self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                    "'Height' is incorrect in the config file.",
                                              "Critical")
                            return False

                        azimuth_angle = float(self.excel["Outer Azimuth angle"]["Collimator station"])
                        angles = [azimuth_angle, 180 - azimuth_angle, 180 + azimuth_angle, 360 - azimuth_angle]
                        radius = float(self.excel["Outer Radius"]["Collimator station"])
                        positions = ["TR", "TL", "BL", "BR"]

                        for angle, position in zip(angles, positions):
                            dy = radius * math.sin(math.radians(angle))
                            dx = radius * math.cos(math.radians(angle))
                            x = self.centre[0] + dx
                            y = self.centre[1] - dy
                            x1, y1 = [int(x - width / 2), int(y - height / 2)]
                            x2, y2 = [int(x + width / 2), int(y + height / 2)]
                            if (int(self.resolution[1]) >= y1 >= 0) and (int(self.resolution[1]) >= y2 >= 0) and \
                                    (int(self.resolution[0]) >= x1 >= 0) and (int(self.resolution[0]) >= x2 >= 0):
                                self.rois[position] = [y1, y2, x1, x2]


                            else:
                                logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                             "the config file at {}".format(position))
                                self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                        "'Height' is incorrect in the config file.",
                                                  "Critical")
                                return False

                        return True

                    else:
                        logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                     "the config file")
                        self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                "'Height' is incorrect in the config file.",
                                          "Critical")
                        return False

                else:
                    logger.error("ROI count is incorrect in the config file")
                    self.msg_box_call("Permission Denied!", "ROI count is incorrect in the config file.", "Critical")
                    return False

            elif setup_type == "Relay station":
                roi_list = self.excel["Chart Position"]["Relay station"].split(",")
                for x in roi_list:
                    if x not in ['TL', 'TR', 'C', 'BL', 'BR', 'TC', 'BC', 'RC', 'LC', 'ITL', 'ITR', 'IBL', 'IBR']:
                        logger.error('Chart position name is incorrect.')
                        self.msg_box_call("Permission Denied!", "Chart position name is incorrect.", "Critical")
                        return False

                if len(roi_list) == 5:
                    if str(self.excel["Outer Azimuth angle"]["Relay station"]).replace(".", "", 1).isdigit() and \
                            str(self.excel["Outer Radius"]["Relay station"]).replace(".", "", 1).isdigit() and \
                            str(self.excel["width"]["Relay station"]).replace(".", "", 1).isdigit() and \
                            str(self.excel["height"]["Relay station"]).replace(".", "", 1).isdigit():
                        self.rois["C"] = []
                        x = self.centre[0]
                        y = self.centre[1]
                        width = float(self.excel["width"]["Relay station"])
                        height = float(self.excel["height"]["Relay station"])
                        x1, y1 = [int(x - width / 2), int(y - height / 2)]
                        x2, y2 = [int(x + width / 2), int(y + height / 2)]
                        if (int(self.resolution[1]) >= y1 >= 0) and (int(self.resolution[1]) >= y2 >= 0) and \
                                (int(self.resolution[0]) >= x1 >= 0) and (int(self.resolution[0]) >= x2 >= 0):
                            self.rois["C"] = [y1, y2, x1, x2]

                        else:
                            logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                         "the config file at Center.")
                            self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                    "'Height' is incorrect in the config file.",
                                              "Critical")
                            return False

                        angles = [float(self.excel["Outer Azimuth angle"]["Relay station"]),
                                  180 - float(self.excel["Outer Azimuth angle"]["Relay station"]),
                                  180 + float(self.excel["Outer Azimuth angle"]["Relay station"]),
                                  360 - float(self.excel["Outer Azimuth angle"]["Relay station"])]

                        positions = ["TR", "TL", "BL", "BR"]
                        radius = float(self.excel["Outer Radius"]["Relay station"])
                        for angle, position in zip(angles, positions):
                            dy = radius * math.sin(math.radians(angle))
                            dx = radius * math.cos(math.radians(angle))
                            x = self.centre[0] + dx
                            y = self.centre[1] - dy
                            x1, y1 = [int(x - width / 2), int(y - height / 2)]
                            x2, y2 = [int(x + width / 2), int(y + height / 2)]
                            if (int(self.resolution[1]) >= y1 >= 0) and (int(self.resolution[1]) >= y2 >= 0) and \
                                    (int(self.resolution[0]) >= x1 >= 0) and (int(self.resolution[0]) >= x2 >= 0):
                                self.rois[position] = [y1, y2, x1, x2]

                            else:
                                logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                             "the config file at {}".format(position))
                                self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                        "'Height' is incorrect in the config file.",
                                                  "Critical")
                                return False

                        return True

                    else:
                        logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                     "the config file")
                        self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                "'Height' is incorrect in the config file.",
                                          "Critical")
                        return False

                elif len(roi_list) == 9:
                    if "TC" in roi_list:
                        if str(self.excel["Outer Azimuth angle"]["Relay station"]).replace(".", "", 1).isdigit() and \
                                str(self.excel["Outer Radius"]["Relay station"]).replace(".", "", 1).isdigit() and \
                                str(self.excel["width"]["Relay station"]).replace(".", "", 1).isdigit() and \
                                str(self.excel["height"]["Relay station"]).replace(".", "", 1).isdigit() and \
                                str(self.excel["Middle radius"]["Relay station"]).replace(".", "", 1).isdigit():
                            self.rois["C"] = []
                            x = self.centre[0]
                            y = self.centre[1]
                            width = float(self.excel["width"]["Relay station"])
                            height = float(self.excel["height"]["Relay station"])
                            x1, y1 = [int(x - width / 2), int(y - height / 2)]
                            x2, y2 = [int(x + width / 2), int(y + height / 2)]
                            if (int(self.resolution[1]) >= y1 >= 0) and (int(self.resolution[1]) >= y2 >= 0) and \
                                    (int(self.resolution[0]) >= x1 >= 0) and (int(self.resolution[0]) >= x2 >= 0):
                                self.rois["C"] = [y1, y2, x1, x2]

                            else:
                                logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                             "the config file at Center.")
                                self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                        "'Height' is incorrect in the config file.",
                                                  "Critical")
                                return False

                            outer_angle = float(self.excel["Outer Azimuth angle"]["Relay station"])
                            angles = [outer_angle, 180 - outer_angle, 180 + outer_angle, 360 - outer_angle, 90, 180,
                                      270, 360]

                            positions = ["TR", "TL", "BL", "BR", "TC", "LC", "BC", "RC"]
                            outer_radius = float(self.excel["Outer Radius"]["Relay station"])
                            middle_radius = float(self.excel["Middle Radius"]["Relay station"])
                            radii = [outer_radius, outer_radius, outer_radius, outer_radius, middle_radius,
                                     middle_radius, middle_radius, middle_radius]

                            for angle, position, radius in zip(angles, positions, radii):
                                dy = radius * math.sin(math.radians(angle))
                                dx = radius * math.cos(math.radians(angle))
                                x = self.centre[0] + dx
                                y = self.centre[1] - dy
                                x1, y1 = [int(x - width / 2), int(y - height / 2)]
                                x2, y2 = [int(x + width / 2), int(y + height / 2)]
                                if (int(self.resolution[1]) >= y1 >= 0) and (int(self.resolution[1]) >= y2 >= 0) and \
                                        (int(self.resolution[0]) >= x1 >= 0) and (int(self.resolution[0]) >= x2 >= 0):
                                    self.rois[position] = [y1, y2, x1, x2]

                                else:
                                    logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                                 "the config file at {}".format(position))
                                    self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                            "'Height' is incorrect in the config file.",
                                                      "Critical")
                                    return False

                            return True

                        else:
                            logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                         "the config file")
                            self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                    "'Height' is incorrect in the config file.",
                                              "Critical")
                            return False

                    if "ITL" in roi_list:
                        if str(self.excel["Outer Azimuth angle"]["Relay station"]).replace(".", "", 1).isdigit() and \
                                str(self.excel["Outer Radius"]["Relay station"]).replace(".", "", 1).isdigit() and \
                                str(self.excel["width"]["Relay station"]).replace(".", "", 1).isdigit() and \
                                str(self.excel["height"]["Relay station"]).replace(".", "", 1).isdigit() and \
                                str(self.excel["Inner Radius"]["Relay station"]).replace(".", "", 1).isdigit() and \
                                str(self.excel["Inner Azimuth angle"]["Relay station"]).replace(".", "", 1).isdigit():
                            self.rois["C"] = []
                            x = self.centre[0]
                            y = self.centre[1]
                            width = float(self.excel["width"]["Relay station"])
                            height = float(self.excel["height"]["Relay station"])
                            x1, y1 = [int(x - width / 2), int(y - height / 2)]
                            x2, y2 = [int(x + width / 2), int(y + height / 2)]
                            if (int(self.resolution[1]) >= y1 >= 0) and (int(self.resolution[1]) >= y2 >= 0) and \
                                    (int(self.resolution[0]) >= x1 >= 0) and (int(self.resolution[0]) >= x2 >= 0):
                                self.rois["C"] = [y1, y2, x1, x2]

                            else:
                                logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                             "the config file at Center.")
                                self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                        "'Height' is incorrect in the config file.",
                                                  "Critical")
                                return False

                            outer_angle = float(self.excel["Outer Azimuth angle"]["Relay station"])
                            inner_angle = float(self.excel["Inner Azimuth angle"]["Relay station"])
                            angles = [outer_angle, 180 - outer_angle, 180 + outer_angle, 360 - outer_angle,
                                      inner_angle, 180 - inner_angle, 180 + inner_angle, 360 - inner_angle]

                            positions = ["TR", "TL", "BL", "BR", 'ITR', 'ITL', 'IBL', 'IBR']
                            outer_radius = float(self.excel["Outer Radius"]["Relay station"])
                            inner_radius = float(self.excel["Inner Radius"]["Relay station"])
                            radii = [outer_radius, outer_radius, outer_radius, outer_radius, inner_radius,
                                     inner_radius, inner_radius, inner_radius]

                            for angle, position, radius in zip(angles, positions, radii):
                                dy = radius * math.sin(math.radians(angle))
                                dx = radius * math.cos(math.radians(angle))
                                x = self.centre[0] + dx
                                y = self.centre[1] - dy
                                x1, y1 = [int(x - width / 2), int(y - height / 2)]
                                x2, y2 = [int(x + width / 2), int(y + height / 2)]
                                if (int(self.resolution[1]) >= y1 >= 0) and (int(self.resolution[1]) >= y2 >= 0) and \
                                        (int(self.resolution[0]) >= x1 >= 0) and (int(self.resolution[0]) >= x2 >= 0):
                                    self.rois[position] = [y1, y2, x1, x2]

                                else:
                                    logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                                 "the config file at {}".format(position))
                                    self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                            "'Height' is incorrect in the config file.",
                                                      "Critical")
                                    return False

                            return True

                        else:
                            logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                         "the config file")
                            self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                    "'Height' is incorrect in the config file.",
                                              "Critical")
                            return False

                elif len(roi_list) == 13:
                    if str(self.excel["Outer Azimuth angle"]["Relay station"]).replace(".", "", 1).isdigit() and \
                            str(self.excel["Outer Radius"]["Relay station"]).replace(".", "", 1).isdigit() and \
                            str(self.excel["width"]["Relay station"]).replace(".", "", 1).isdigit() and \
                            str(self.excel["height"]["Relay station"]).replace(".", "", 1).isdigit() and \
                            str(self.excel["Inner Radius"]["Relay station"]).replace(".", "", 1).isdigit() and \
                            str(self.excel["Inner Azimuth angle"]["Relay station"]).replace(".", "", 1).isdigit() and \
                            str(self.excel["Middle radius"]["Relay station"]).replace(".", "", 1).isdigit():
                        self.rois["C"] = []
                        x = self.centre[0]
                        y = self.centre[1]
                        width = float(self.excel["width"]["Relay station"])
                        height = float(self.excel["height"]["Relay station"])
                        x1, y1 = [int(x - width / 2), int(y - height / 2)]
                        x2, y2 = [int(x + width / 2), int(y + height / 2)]
                        if (int(self.resolution[1]) >= y1 >= 0) and (int(self.resolution[1]) >= y2 >= 0) and \
                                (int(self.resolution[0]) >= x1 >= 0) and (int(self.resolution[0]) >= x2 >= 0):
                            self.rois["C"] = [y1, y2, x1, x2]

                        else:
                            logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                         "the config file at Center.")
                            self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                    "'Height' is incorrect in the config file.",
                                              "Critical")
                            return False

                        outer_angle = float(self.excel["Outer Azimuth angle"]["Relay station"])
                        inner_angle = float(self.excel["Inner Azimuth angle"]["Relay station"])
                        angles = [outer_angle, 180 - outer_angle, 180 + outer_angle, 360 - outer_angle, 90, 180, 270,
                                  360, inner_angle, 180 - inner_angle, 180 + inner_angle, 360 - inner_angle]

                        positions = ["TR", "TL", "BL", "BR", "TC", "LC", "BC", "RC", 'ITR', 'ITL', 'IBL', 'IBR']
                        outer_radius = float(self.excel["Outer Radius"]["Relay station"])
                        middle_radius = float(self.excel["Middle Radius"]["Relay station"])
                        inner_radius = float(self.excel["Inner Radius"]["Relay station"])
                        radii = [outer_radius, outer_radius, outer_radius, outer_radius, middle_radius,
                                 middle_radius, middle_radius, middle_radius, inner_radius,
                                 inner_radius, inner_radius, inner_radius]

                        for angle, position, radius in zip(angles, positions, radii):
                            dy = radius * math.sin(math.radians(angle))
                            dx = radius * math.cos(math.radians(angle))
                            x = self.centre[0] + dx
                            y = self.centre[1] - dy
                            x1, y1 = [int(x - width / 2), int(y - height / 2)]
                            x2, y2 = [int(x + width / 2), int(y + height / 2)]
                            if (int(self.resolution[1]) >= y1 >= 0) and (int(self.resolution[1]) >= y2 >= 0) and \
                                    (int(self.resolution[0]) >= x1 >= 0) and (int(self.resolution[0]) >= x2 >= 0):
                                self.rois[position] = [y1, y2, x1, x2]

                            else:
                                logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                             "the config file at {}".format(position))
                                self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                        "'Height' is incorrect in the config file.",
                                                  "Critical")
                                return False

                        return True

                    else:
                        logger.error("'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                     "the config file")
                        self.msg_box_call("Permission Denied!", "'Azimuth Angle' or 'Radius' or 'Width' or "
                                                                "'Height' is incorrect in the config file.",
                                          "Critical")
                        return False

                else:
                    logger.error("ROI count is incorrect in the config file")
                    self.msg_box_call("Permission Denied!", "ROI count is incorrect in the config file.",
                                      "Critical")
                    return False
            else:
                logger.error("Setup type is incorrect in the config file")
                self.msg_box_call("Permission Denied!", "Setup type is incorrect in the config file.",
                                  "Critical")
                return False

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at roi_selection function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.msg_box_call("Permission Denied!", "Error at ROI coordinate.", "Critical")
            self.is_config_loaded = False
            return

    def update_mtf_plot_live(self, mtf_list, save=""):
        try:
            """
              This method is used to save the mtf plot graph
              param lists: mtf_list datatype is list, save datatype is str
              return: None
            """
            if save != "":
                now = datetime.datetime.now()
                """Mod board, Base board, Product serial is True"""
                if self.is_config_loaded and not pd.isna(self.excel["Product Serial No."]['Product details']) and not \
                        pd.isna(self.excel["Module Serial No."]['Product details']) and not \
                        pd.isna(self.excel["Base Serial No."]['Product details']):
                    result_name = "{}_{}".format(self.mod_serial, now.strftime("%H%M%S"))

                    """if Mod board and Base board is True"""
                elif self.is_config_loaded and pd.isna(self.excel["Product Serial No."]['Product details']) and not \
                        pd.isna(self.excel["Module Serial No."]['Product details']) and not \
                        pd.isna(self.excel["Base Serial No."]['Product details']):
                    result_name = "{}_{}".format(self.mod_serial, now.strftime("%H%M%S"))

                    """if Mod board is True"""
                elif pd.isna(self.excel["Product Serial No."]['Product details']) and \
                        pd.isna(self.excel["Base Serial No."]['Product details']) and not \
                        pd.isna(self.excel["Module Serial No."]['Product details']):
                    result_name = "{}_{}".format(self.mod_serial, now.strftime("%H%M%S"))

                    """if Base board is True"""
                elif pd.isna(self.excel["Product Serial No."]['Product details']) and \
                        pd.isna(self.excel["Module Serial No."]['Product details']) and not \
                        pd.isna(self.excel["Base Serial No."]['Product details']):
                    result_name = "{}_{}".format(self.base_serial, now.strftime("%H%M%S"))

                    """if only product serial is True"""
                elif not pd.isna(self.excel["Product Serial No."]['Product details']) and \
                        pd.isna(self.excel["Module Serial No."]['Product details']) and \
                        pd.isna(self.excel["Base Serial No."]['Product details']):
                    result_name = "{}_{}".format(self.product_serial, now.strftime("%H%M%S"))

                    """if base board and Product serial is True"""
                elif not pd.isna(self.excel["Product Serial No."]['Product details']) and \
                        pd.isna(self.excel["Module Serial No."]['Product details']) and not \
                        pd.isna(self.excel["Base Serial No."]['Product details']):
                    result_name = "{}_{}".format(self.base_serial, now.strftime("%H%M%S"))

                    """if mod board and Product serial is True"""
                elif not pd.isna(self.excel["Product Serial No."]['Product details']) and not \
                        pd.isna(self.excel["Module Serial No."]['Product details']) and \
                        pd.isna(self.excel["Base Serial No."]['Product details']):
                    result_name = "{}_{}".format(self.mod_serial, now.strftime("%H%M%S"))

                self.figure.clear()
                self.ax = self.figure.add_subplot(111)
                self.ax.set_title('')
                font1 = {'family': 'serif', 'color': 'green', 'size': 12}
                self.ax.set_title('MTF graph - Rotation completed', font1)
                mtf_list_copy = mtf_list.copy()
                for label in mtf_list_copy.keys():
                    self.ax.plot(range(len(mtf_list_copy[label])), mtf_list_copy[label], label=label)
                self.ax.legend()
                cursor = mplcursors.cursor(hover=True)
                self.ax.set_xlabel("Number of turns")
                self.ax.set_ylabel("MTF")
                self.canvas.draw()
                self.canvas.resize(580, 450)

                @cursor.connect("add")
                def on_add(sel):
                    label = sel.artist.get_label()
                    x_val = sel.target[1]
                    sel.annotation.set_text(f"ROI Position: {label} \nMTF50: {x_val:.3f}")

                self.plt_graph.savefig("{}\\{}_graph.png".format(self.folder_path, result_name))
                return

            self.figure.clear()
            self.ax = self.figure.add_subplot(111)
            font1 = {'family': 'serif', 'color': 'orange', 'size': 12}
            self.ax.set_title('MTF graph - Rotation In progress', fontdict=font1)
            mtf_list_copy = mtf_list.copy()
            # remove_all_mtf_list = mtf_list_copy.pop("All")
            for label in mtf_list_copy.keys():
                self.ax.plot(range(len(mtf_list_copy[label])), mtf_list_copy[label], label=label)

            self.ax.legend()
            cursor = mplcursors.cursor(hover=True)
            self.ax.set_xlabel("Number of turns")
            self.ax.set_ylabel("MTF")
            self.canvas.draw()
            self.canvas.resize(580, 450)

            @cursor.connect("add")
            def on_add(sel):
                label = sel.artist.get_label()
                x_val = sel.target[1]
                sel.annotation.set_text(f"ROI Position: {label} \nMTF50: {x_val:.3f}")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at update_mtf_plot_live function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def text_update(self, text=None, value=None, position=None):
        try:
            """
              This method is used to write the current progress of Plc and actuator in the status bar.
              param lists: text, value and position datatype is str
              return: None
            """
            if text == "slider down" or text == "slider up":
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("slider moving is in progress..")
                elif value == "Slider moved":
                    self.machine_flow.diagnostic_page_statusbar.setText("slider moving is completed")
                    self.machine_flow.slider_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            if text == "Slider homing" or text == "Gripper homing":
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("plc init is in progress..")
                elif value == "completed":
                    self.machine_flow.diagnostic_page_statusbar.setText("plc init is completed")
                    self.machine_flow.slider_act_position_value.setText(str(0.0))
                    self.machine_flow.gripper_act_position_value.setText(str(40.0))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == "gripper close" or text == "gripper open":
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("gripper moving is in progress..")
                elif value == "Gripper moved":
                    self.machine_flow.diagnostic_page_statusbar.setText("gripper moving is completed")
                    self.machine_flow.gripper_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == 'y-axis forward' or text == 'y-axis reverse':
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Y-actuator moving is in progress..")
                elif value == "Y-axis Moved":
                    self.machine_flow.diagnostic_page_statusbar.setText("Y-actuator moving is completed")
                    self.machine_flow.y_axis_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == 'Y-axis homing diagnostic':
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Y-actuator homing is in progress..")
                elif value == "completed":
                    self.machine_flow.diagnostic_page_statusbar.setText("Y-actuator homing is completed")
                    self.machine_flow.y_axis_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == 'x-axis forward' or text == 'x-axis reverse':
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("X-actuator moving is in progress..")
                elif value == "X-axis Moved":
                    self.machine_flow.diagnostic_page_statusbar.setText("X-actuator moving is completed")
                    self.machine_flow.x_axis_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == 'X-axis homing diagnostic':
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("X-actuator homing is in progress..")
                elif value == "completed":
                    self.machine_flow.diagnostic_page_statusbar.setText("X-actuator homing is completed")
                    self.machine_flow.x_axis_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == "front door open diagnostic":
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Front door open is in progress")
                elif value == "completed":
                    self.machine_flow.diagnostic_page_statusbar.setText("Front door open is completed")
                    self.machine_flow.front_door_act_position_lbl.setText("Open")
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))
                    self.machine_flow.front_door_act_position_lbl.setText("Error")

            elif text == "front door close diagnostic":
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Front door close is in progress")
                elif value == "completed":
                    self.machine_flow.diagnostic_page_statusbar.setText("Front door close is completed")
                    self.machine_flow.front_door_act_position_lbl.setText("Close")
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))
                    self.machine_flow.front_door_act_position_lbl.setText("Error")

            elif text == 'light panel up' or text == 'light panel down':
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Z-actuator moving is in progress..")
                elif value == "Z-axis Moved":
                    self.machine_flow.diagnostic_page_statusbar.setText("Z-actuator moving is completed")
                    self.machine_flow.light_panel_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == "Relay Z-axis homing diagnostic":
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Z-actuator homing is in progress..")
                elif value == "completed":
                    self.machine_flow.diagnostic_page_statusbar.setText("Z-actuator homing is completed")
                    self.machine_flow.light_panel_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == "Relay intensity":
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Light panel lux set is in progress..")
                elif value == "lux set":
                    self.machine_flow.diagnostic_page_statusbar.setText("Light panel lux set is in completed")
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == 'Gluing z-axis up' or text == 'Gluing z-axis down':
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Z-actuator moving is in progress..")
                elif value == "Z-axis Moved":
                    self.machine_flow.diagnostic_page_statusbar.setText("Z-actuator moving is completed")
                    self.machine_flow.gd_z_axis_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == "Gluing Z-axis homing diagnostic":
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Z-actuator homing is in progress..")
                elif value == "completed":
                    self.machine_flow.diagnostic_page_statusbar.setText("Z-actuator homing is completed")
                    self.machine_flow.gd_z_axis_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == 'Gluing x1 inside' or text == 'Gluing x1 outside':
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Gluing X1 moving is in progress..")
                elif value == "Gluing X1 moved":
                    self.machine_flow.diagnostic_page_statusbar.setText("Gluing X1 moving is completed")
                    self.machine_flow.gluing_x1_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == 'Gluing x2 inside' or text == 'Gluing x2 outside':
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Gluing X2 moving is in progress..")
                elif value == "Gluing X2 moved":
                    self.machine_flow.diagnostic_page_statusbar.setText("Gluing X2 moving is completed")
                    self.machine_flow.gluing_x2_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == 'Gluing y inside' or text == 'Gluing y outside':
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Gluing y moving is in progress..")
                elif value == "Gluing y moved":
                    self.machine_flow.diagnostic_page_statusbar.setText("Gluing y moving is completed")
                    self.machine_flow.gluing_y_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == 'Gluing init diagnostic':
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Gluing init is in progress..")
                elif value == "Gluing init is done":
                    self.machine_flow.diagnostic_page_statusbar.setText("Gluing init is completed")
                    self.machine_flow.gluing_y_act_position_value.setText(str(0))
                    self.machine_flow.gluing_x1_act_position_value.setText(str(0))
                    self.machine_flow.gluing_x2_act_position_value.setText(str(0))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == 'Glue purge diagnostic':
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Gluing init is in progress..")
                elif value == "Gluing purge is done":
                    self.machine_flow.diagnostic_page_statusbar.setText("Gluing init is completed")
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == 'curing z-axis up' or text == 'curing z-axis down':
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Z-actuator moving is in progress..")
                elif value == "Z-axis Moved":
                    self.machine_flow.diagnostic_page_statusbar.setText("Z-actuator moving is completed")
                    self.machine_flow.uv_z_axis_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == "Curing Z-axis homing diagnostic":
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("Z-actuator homing is in progress..")
                elif value == "completed":
                    self.machine_flow.diagnostic_page_statusbar.setText("Z-actuator homing is completed")
                    self.machine_flow.uv_z_axis_act_position_value.setText(str(position))
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == "curing door open diagnostic":
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("UV door open is in progress")
                elif value == "completed":
                    self.machine_flow.diagnostic_page_statusbar.setText("UV door open is completed")
                    self.machine_flow.uv_left_cylinder_act_position_lbl.setText("Open")
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))
                    self.machine_flow.uv_left_cylinder_act_position_lbl.setText("Error")

            elif text == "curing door close diagnostic":
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("UV door close is in progress")
                elif value == "completed":
                    self.machine_flow.diagnostic_page_statusbar.setText("UV door close is completed")
                    self.machine_flow.uv_left_cylinder_act_position_lbl.setText("Close")
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))
                    self.machine_flow.uv_left_cylinder_act_position_lbl.setText("Error")

            elif text == "Uv curing diagnostic":
                if value == "in progress":
                    self.machine_flow.diagnostic_page_statusbar.setText("UV apply is in progress")
                elif value == "completed":
                    self.machine_flow.diagnostic_page_statusbar.setText("UV apply is completed")
                else:
                    self.machine_flow.diagnostic_page_statusbar.setText("{}".format(value))

            elif text == "loading init":
                if value == "in progress":
                    self.statusbar.setText("Plc initialize is in progress..")
                elif value == "completed":
                    self.statusbar.setText("Plc initialize is completed")
                    self.loading_slider_current_position_value.setText(str(0.0))
                    self.loading_gripper_current_position_value.setText(str(40.0))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == "front door open":
                if value == "in progress":
                    self.statusbar.setText("Front open is in progress")
                elif value == "completed":
                    self.statusbar.setText("Front open is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == "front door close":
                if value == "in progress":
                    self.statusbar.setText("Front close is in progress")
                elif value == "completed":
                    self.statusbar.setText("Front close is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == "part_loading in":
                if value == "in progress":
                    self.statusbar.setText("part_loading_in is in progress")
                elif value == "completed":
                    self.statusbar.setText("part_loading_in is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == "part_loading out":
                if value == "in progress":
                    self.statusbar.setText("part_loading_out is in progress")
                elif value == "completed":
                    self.statusbar.setText("part_loading_out is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == "loading x_axis_homing btn":
                if value == "in progress":
                    self.statusbar.setText("X-actuator homing is in progress..")
                elif value == "completed":
                    self.statusbar.setText("X-actuator homing is completed")
                    self.loading_x_axis_current_position_value.setText("10.0")
                    self.lens_rotator_x_axis_current_position_value.setText("10.0")
                    self.collimator_x_axis_current_position_value.setText("10.0")
                    self.relay_x_axis_current_position_value.setText("10.0")
                    self.gluing_x_axis_current_position_value.setText(str("5.0"))
                    self.curing_x_axis_current_position_value.setText(str("5.0"))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == "loading y_axis_homing btn":
                if value == "in progress":
                    self.statusbar.setText("Y-actuator homing is in progress..")
                elif value == "completed":
                    self.statusbar.setText("Y-actuator homing is completed")
                    self.loading_y_axis_current_position_value.setText("5.0")
                    self.lens_rotator_y_axis_current_position_value.setText("5.0")
                    self.collimator_y_axis_current_position_value.setText("5.0")
                    self.relay_y_axis_current_position_value.setText("5.0")
                    self.gluing_y_axis_current_position_value.setText(str("5.0"))
                    self.curing_y_axis_current_position_value.setText(str("5.0"))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'loading_x_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("X-axis movement is in progress")
                elif value == "X-axis Moved":
                    self.statusbar.setText("X-axis movement is completed")
                    self.loading_x_axis_current_position_value.setText(str(position))
                    self.lens_rotator_x_axis_current_position_value.setText(str(position))
                    self.collimator_x_axis_current_position_value.setText(str(position))
                    self.relay_x_axis_current_position_value.setText(str(position))
                    self.gluing_x_axis_current_position_value.setText(str(position))
                    self.curing_x_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'loading_y_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("Y-axis movement is in progress..")
                elif value == "Y-axis Moved":
                    self.statusbar.setText("Y-axis movement is completed")
                    self.loading_y_axis_current_position_value.setText(str(position))
                    self.lens_rotator_y_axis_current_position_value.setText(str(position))
                    self.collimator_y_axis_current_position_value.setText(str(position))
                    self.relay_y_axis_current_position_value.setText(str(position))
                    self.gluing_y_axis_current_position_value.setText(str(position))
                    self.curing_y_axis_current_position_value.setText(str(position))

                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'loading_slider_run_btn':
                if value == "in progress":
                    self.statusbar.setText("Slider movement is in progress")
                elif value == "Slider moved":
                    self.statusbar.setText("Slider movement is completed")
                    self.loading_slider_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'loading slider_homing btn':
                if value == "in progress":
                    self.statusbar.setText("Plc init is in progress")
                elif value == "Slider moved":
                    self.statusbar.setText("Plc init is completed")
                    self.loading_slider_current_position_value.setText(str(0.0))
                    self.loading_gripper_current_position_value.setText(str(40.0))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == "loading_gripper_run_btn":
                if value == "in progress":
                    self.statusbar.setText("Gripper movement is in progress")
                elif value == "Gripper moved":
                    self.statusbar.setText("Gripper movement is completed")
                    self.loading_gripper_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == "loading gripper_homing btn":
                if value == "in progress":
                    self.statusbar.setText("Gripper open is in progress")
                elif value == "Gripper moved":
                    self.statusbar.setText("Gripper open is completed")
                    self.loading_gripper_current_position_value.setText(str(40.0))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'loading_clockwise' or text == 'clockwise btn':
                if value == "in progress":
                    self.statusbar.setText("Clockwise rotation is in progress")
                elif value == "clockwise rotation is done":
                    self.statusbar.setText("Clockwise rotation is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'loading_anti_clockwise' or text == 'anti-clockwise btn':
                if value == "in progress":
                    self.statusbar.setText("Anti-Clockwise rotation is in progress")
                elif value == "anti-clockwise rotation is done":
                    self.statusbar.setText("Anti-Clockwise rotation is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'lens_rotator_x_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("X-axis movement is in progress")
                elif value == "X-axis Moved":
                    self.statusbar.setText("X-axis movement is completed")
                    self.loading_x_axis_current_position_value.setText(str(position))
                    self.lens_rotator_x_axis_current_position_value.setText(str(position))
                    self.collimator_x_axis_current_position_value.setText(str(position))
                    self.relay_x_axis_current_position_value.setText(str(position))
                    self.gluing_x_axis_current_position_value.setText(str(position))
                    self.curing_x_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'lens_rotator_y_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("Y-axis movement is in progress..")
                elif value == "Y-axis Moved":
                    self.statusbar.setText("Y-axis movement is completed")
                    self.loading_y_axis_current_position_value.setText(str(position))
                    self.lens_rotator_y_axis_current_position_value.setText(str(position))
                    self.collimator_y_axis_current_position_value.setText(str(position))
                    self.relay_y_axis_current_position_value.setText(str(position))
                    self.gluing_y_axis_current_position_value.setText(str(position))
                    self.curing_y_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'lens_rotator_x_axis_homing_btn':
                if value == "in progress":
                    self.statusbar.setText("X-actuator homing is in progress..")
                elif value == "completed":
                    self.statusbar.setText("X-actuator homing is completed")
                    self.loading_x_axis_current_position_value.setText("10.0")
                    self.lens_rotator_x_axis_current_position_value.setText("10.0")
                    self.collimator_x_axis_current_position_value.setText("10.0")
                    self.relay_x_axis_current_position_value.setText("10.0")
                    self.gluing_x_axis_current_position_value.setText(str("10.0"))
                    self.curing_x_axis_current_position_value.setText(str("10.0"))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'lens_rotator_y_axis_homing_btn':
                if value == "in progress":
                    self.statusbar.setText("Y-actuator homing is in progress..")
                elif value == "completed":
                    self.statusbar.setText("Y-actuator homing is completed")
                    self.loading_y_axis_current_position_value.setText("5.0")
                    self.lens_rotator_y_axis_current_position_value.setText("5.0")
                    self.collimator_y_axis_current_position_value.setText("5.0")
                    self.relay_y_axis_current_position_value.setText("5.0")
                    self.gluing_y_axis_current_position_value.setText(str("5.0"))
                    self.curing_y_axis_current_position_value.setText(str("5.0"))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'lens_rotator_clockwise':
                if value == "in progress":
                    self.statusbar.setText("Clockwise rotation is in progress")
                elif value == "clockwise rotation is done":
                    self.statusbar.setText("Clockwise rotation is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'lens_rotator_anti_clockwise':
                if value == "in progress":
                    self.statusbar.setText("Anti-Clockwise rotation is in progress")
                elif value == "anti-clockwise rotation is done":
                    self.statusbar.setText("Anti-Clockwise rotation is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == "Lens height_value":
                self.lens_rotator_sensor_value.setText(value)

            elif text == 'collimator_x_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("X-axis movement is in progress")
                elif value == "X-axis Moved":
                    self.statusbar.setText("X-axis movement is completed")
                    self.loading_x_axis_current_position_value.setText(str(position))
                    self.lens_rotator_x_axis_current_position_value.setText(str(position))
                    self.collimator_x_axis_current_position_value.setText(str(position))
                    self.relay_x_axis_current_position_value.setText(str(position))
                    self.gluing_x_axis_current_position_value.setText(str(position))
                    self.curing_x_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'collimator_y_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("Y-axis movement is in progress..")
                elif value == "Y-axis Moved":
                    self.statusbar.setText("Y-axis movement is completed")
                    self.loading_y_axis_current_position_value.setText(str(position))
                    self.lens_rotator_y_axis_current_position_value.setText(str(position))
                    self.collimator_y_axis_current_position_value.setText(str(position))
                    self.relay_y_axis_current_position_value.setText(str(position))
                    self.gluing_y_axis_current_position_value.setText(str(position))
                    self.curing_y_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'collimator_x_axis_homing_btn':
                if value == "in progress":
                    self.statusbar.setText("X-actuator homing is in progress..")
                elif value == "completed":
                    self.statusbar.setText("X-actuator homing is completed")
                    self.loading_x_axis_current_position_value.setText("10")
                    self.lens_rotator_x_axis_current_position_value.setText("10")
                    self.collimator_x_axis_current_position_value.setText("10")
                    self.relay_x_axis_current_position_value.setText("10")
                    self.gluing_x_axis_current_position_value.setText(str("10.0"))
                    self.curing_x_axis_current_position_value.setText(str("10.0"))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'collimator_y_axis_homing_btn':
                if value == "in progress":
                    self.statusbar.setText("Y-actuator homing is in progress..")
                elif value == "completed":
                    self.statusbar.setText("Y-actuator homing is completed")
                    self.loading_y_axis_current_position_value.setText("5.0")
                    self.lens_rotator_y_axis_current_position_value.setText("5.0")
                    self.collimator_y_axis_current_position_value.setText("5.0")
                    self.relay_y_axis_current_position_value.setText("5.0")
                    self.gluing_y_axis_current_position_value.setText(str("5.0"))
                    self.curing_y_axis_current_position_value.setText(str("5.0"))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'collimator_clockwise_btn':
                if value == "in progress":
                    self.statusbar.setText("Clockwise rotation is in progress")
                elif value == "clockwise rotation is done":
                    self.statusbar.setText("Clockwise rotation is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'collimator_anti_clockwise_btn':
                if value == "in progress":
                    self.statusbar.setText("Anti-Clockwise rotation is in progress")
                elif value == "anti-clockwise rotation is done":
                    self.statusbar.setText("Anti-Clockwise rotation is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == "Collimator_chart_dst_lux_btn":
                if value == "chart_distance&intensity in progress":
                    self.statusbar.setText("Collimator Chart_distance&intensity set in progress")
                elif value == "chart_distance&intensity is completed":
                    self.statusbar.setText("Collimator Chart_distance&intensity is completed")
                elif value == "chart_distance&intensity Error":
                    self.statusbar.setText("Error to set chart_distance or intensity Error")

            elif text == 'relay_x_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("X-axis movement is in progress")
                elif value == "X-axis Moved":
                    self.statusbar.setText("X-axis movement is completed")
                    self.loading_x_axis_current_position_value.setText(str(position))
                    self.lens_rotator_x_axis_current_position_value.setText(str(position))
                    self.collimator_x_axis_current_position_value.setText(str(position))
                    self.relay_x_axis_current_position_value.setText(str(position))
                    self.gluing_x_axis_current_position_value.setText(str(position))
                    self.curing_x_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'relay_y_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("Y-axis movement is in progress..")
                elif value == "Y-axis Moved":
                    self.statusbar.setText("Y-axis movement is completed")
                    self.loading_y_axis_current_position_value.setText(str(position))
                    self.lens_rotator_y_axis_current_position_value.setText(str(position))
                    self.collimator_y_axis_current_position_value.setText(str(position))
                    self.relay_y_axis_current_position_value.setText(str(position))
                    self.gluing_y_axis_current_position_value.setText(str(position))
                    self.curing_y_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'relay_x_axis_homing_btn':
                if value == "in progress":
                    self.statusbar.setText("X-actuator homing is in progress..")
                elif value == "completed":
                    self.statusbar.setText("X-actuator homing is completed")
                    self.loading_x_axis_current_position_value.setText("10.0")
                    self.lens_rotator_x_axis_current_position_value.setText("10.0")
                    self.collimator_x_axis_current_position_value.setText("10.0")
                    self.relay_x_axis_current_position_value.setText("10.0")
                    self.gluing_x_axis_current_position_value.setText(str("10.0"))
                    self.curing_x_axis_current_position_value.setText(str("10.0"))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'relay_y_axis_homing_btn':
                if value == "in progress":
                    self.statusbar.setText("Y-actuator homing is in progress..")
                elif value == "completed":
                    self.statusbar.setText("Y-actuator homing is completed")
                    self.loading_y_axis_current_position_value.setText("5.0")
                    self.lens_rotator_y_axis_current_position_value.setText("5.0")
                    self.collimator_y_axis_current_position_value.setText("5.0")
                    self.relay_y_axis_current_position_value.setText("5.0")
                    self.gluing_y_axis_current_position_value.setText(str(5.0))
                    self.curing_y_axis_current_position_value.setText(str(5.0))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'relay_clockwise_btn':
                if value == "in progress":
                    self.statusbar.setText("Clockwise rotation is in progress")
                elif value == "clockwise rotation is done":
                    self.statusbar.setText("Clockwise rotation is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'relay_anti_clockwise_btn':
                if value == "in progress":
                    self.statusbar.setText("Anti-Clockwise rotation is in progress")
                elif value == "anti-clockwise rotation is done":
                    self.statusbar.setText("Anti-Clockwise rotation is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'relay_light_panel_actuator_run_btn':
                if value == "in progress":
                    self.statusbar.setText("Z-axis movement is in progress..")
                elif value == "relay z-axis Moved":
                    self.statusbar.setText("Z-axis movement is completed")
                    self.relay_light_panel_actuator_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'relay_light_panel_actuator_homing_btn':
                if value == "in progress":
                    self.statusbar.setText("Z-actuator homing is in progress..")
                elif value == "completed":
                    self.statusbar.setText("Z-actuator homing is completed")
                    self.relay_light_panel_actuator_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'relay_light_panel_intensity_btn':
                if value == "in progress":
                    self.statusbar.setText("Light panel lux set is in progress..")
                elif value == "lux set":
                    self.statusbar.setText("Light panel lux set is in completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'gluing_x_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("X-axis movement is in progress")
                elif value == "X-axis Moved":
                    self.statusbar.setText("X-axis movement is completed")
                    self.loading_x_axis_current_position_value.setText(str(position))
                    self.lens_rotator_x_axis_current_position_value.setText(str(position))
                    self.collimator_x_axis_current_position_value.setText(str(position))
                    self.relay_x_axis_current_position_value.setText(str(position))
                    self.gluing_x_axis_current_position_value.setText(str(position))
                    self.curing_x_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'gluing_y_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("Y-axis movement is in progress..")
                elif value == "Y-axis Moved":
                    self.statusbar.setText("Y-axis movement is completed")
                    self.loading_y_axis_current_position_value.setText(str(position))
                    self.lens_rotator_y_axis_current_position_value.setText(str(position))
                    self.collimator_y_axis_current_position_value.setText(str(position))
                    self.relay_y_axis_current_position_value.setText(str(position))
                    self.gluing_y_axis_current_position_value.setText(str(position))
                    self.curing_y_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'gluing_z_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("Z-axis movement is in progress..")
                elif value == "Z-axis Moved":
                    self.statusbar.setText("Z-axis movement is completed")
                    self.gluing_z_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'gluing_z_axis_homing_btn':
                if value == "in progress":
                    self.statusbar.setText("Z-actuator homing is in progress..")
                elif value == "completed":
                    self.statusbar.setText("Z-actuator homing is completed")
                    self.gluing_z_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'gluing_teaching_x1_run_btn':
                if value == "in progress":
                    self.statusbar.setText("Gluing_X1-axis movement is in progress..")
                elif value == "gluing_x1-axis moved":
                    self.statusbar.setText("Gluing_X1-axis movement is completed")
                    self.gluing_teaching_x1_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'gluing_teaching_x2_run_btn':
                if value == "in progress":
                    self.statusbar.setText("Gluing_X2-axis movement is in progress..")
                elif value == "gluing_x2-axis moved":
                    self.statusbar.setText("Gluing_X2-axis movement is completed")
                    self.gluing_teaching_x2_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'gluing_teaching_y_run_btn':
                if value == "in progress":
                    self.statusbar.setText("Gluing_y-axis movement is in progress..")
                elif value == "gluing_y-axis moved":
                    self.statusbar.setText("Gluing_y-axis movement is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'Gluing init btn':
                if value == "in progress":
                    self.statusbar.setText("Gluing initialization is in progress..")
                elif value == "Completed":
                    self.gluing_teaching_x1_current_position_value.setText("0.0")
                    self.gluing_teaching_x2_current_position_value.setText("0.0")
                    self.statusbar.setText("Gluing initialization is Completed.")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'Gluing apply btn':
                if value == "in progress":
                    self.statusbar.setText("Gluing apply is in progress..")
                elif value == "Glue applied":
                    self.statusbar.setText("Gluing apply is Completed.")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'gluing_dispenser_off_btn':
                if value == "in progress":
                    self.statusbar.setText("Gluing dispenser off is in progress..")
                elif value == "Glue off":
                    self.statusbar.setText("Gluing dispenser off is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'curing_x_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("X-axis movement is in progress")
                elif value == "X-axis Moved":
                    self.statusbar.setText("X-axis movement is completed")
                    self.loading_x_axis_current_position_value.setText(str(position))
                    self.lens_rotator_x_axis_current_position_value.setText(str(position))
                    self.collimator_x_axis_current_position_value.setText(str(position))
                    self.relay_x_axis_current_position_value.setText(str(position))
                    self.gluing_x_axis_current_position_value.setText(str(position))
                    self.curing_x_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'curing_y_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("Y-axis movement is in progress..")
                elif value == "Y-axis Moved":
                    self.statusbar.setText("Y-axis movement is completed")
                    self.loading_y_axis_current_position_value.setText(str(position))
                    self.lens_rotator_y_axis_current_position_value.setText(str(position))
                    self.collimator_y_axis_current_position_value.setText(str(position))
                    self.relay_y_axis_current_position_value.setText(str(position))
                    self.gluing_y_axis_current_position_value.setText(str(position))
                    self.curing_y_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'curing_z_axis_run_btn':
                if value == "in progress":
                    self.statusbar.setText("Z-axis movement is in progress..")
                elif value == "Z-axis Moved":
                    self.statusbar.setText("Z-axis movement is completed")
                    self.curing_z_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == 'curing_z_axis_homing_btn':
                if value == "in progress":
                    self.statusbar.setText("Z-actuator homing is in progress..")
                elif value == "completed":
                    self.statusbar.setText("Z-actuator homing is completed")
                    self.curing_z_axis_current_position_value.setText(str(position))
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == "curing door open":
                if value == "in progress":
                    self.statusbar.setText("UV door open is in progress")
                elif value == "completed":
                    self.statusbar.setText("UV door open is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == "curing door close":
                if value == "in progress":
                    self.statusbar.setText("UV door close is in progress")
                elif value == "completed":
                    self.statusbar.setText("UV door close is completed")
                else:
                    self.statusbar.setText("{}".format(value))

            elif text == "Curing_on":
                if value == "in progress":
                    self.statusbar.setText("UV apply is in progress")
                elif value == "completed":
                    self.statusbar.setText("UV apply is completed")
                else:
                    self.statusbar.setText("{}".format(value))
            else:
                logger.error("Update button value and text is wrong")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at text_update function :{}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def diagnostic_thread_new(self):
        """
          This method is used to start the thread for diagnostic screen.
          param lists: None
          return: None
        """
        if not self.machine_movement_clicked:
            logger.info("*********Diagnostic page thread initialization started*************")
            threadCount = QThreadPool.globalInstance().maxThreadCount()
            pool = QThreadPool.globalInstance()
            pool.setMaxThreadCount(16)
            if threadCount >= 2:
                self.machine_movement_clicked = True
                runnable = diagnostic_control(pool)
                runnable.signals.call_MsgBox.connect(self.msg_box_call)
                runnable.signals.call_texts.connect(self.text_update)
                pool.start(runnable)

    def recipe_create_thread(self, btn_type, position_value):
        try:
            """
              This method is used to start the thread for recipe creation page.
              param lists: btn_type is str, position value is str 
              btn_type which button is pressed
              position_value is movement value 
              return: None
            """
            if self.push_button_timer.isActive():
                self.push_button_timer.stop()

            if not self.machine_movement_clicked:
                logger.info("Recipe_create_Thread initialization started")
                threadCount = QThreadPool.globalInstance().maxThreadCount()
                pool = QThreadPool.globalInstance()
                pool.setMaxThreadCount(16)
                if threadCount >= 2:
                    self.machine_movement_clicked = True
                    runnable_recipe_create = Runnable_recipe_create(pool, btn_type, position_value)
                    runnable_recipe_create.signals.call_MsgBox.connect(self.msg_box_call)
                    runnable_recipe_create.signals.call_texts.connect(self.text_update)
                    pool.start(runnable_recipe_create)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at recipe_create_thread function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def update_input_output_values(self, input_type, row, value):
        try:
            if row < 28:
                if input_type == "input":
                    item = ui.machine_flow.sensor_tableWidget_ip_1.item(row, 1)
                else:
                    item = ui.machine_flow.sensor_tableWidget_op_1.item(row, 1)
            else:
                if input_type == "input":
                    item = ui.machine_flow.sensor_tableWidget_ip_2.item((row + 1) - 28, 1)
                else:
                    item = ui.machine_flow.sensor_tableWidget_op_2.item((row + 1) - 28, 1)

            if value == "0":
                item.setText("Off")
                item.setBackground(QBrush(QColor(170, 0, 40)))
            else:
                item.setText("On")
                item.setBackground(QBrush(QColor(0, 200, 40)))


        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at update_input_output_values function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def update_text(self, text, status, io_list=None):
        try:
            """
              This method is used to update the text in port connection and input and output dialog box.
              param lists: text datatype is str, status datatype is str and io_list datatype is list 
              return: None
            """
            if text == "PLC":
                item = self.machine_flow.port_tableWidget.item(1, 2)
                item.setText("{}".format(status))

            if text == "PLC 2":
                item = self.machine_flow.port_tableWidget.item(2, 2)
                item.setText("{}".format(status))

            if text == "Modbus":
                item = ui.machine_flow.port_tableWidget.item(3, 2)
                item.setText("{}".format(status))

            if text == "UV":
                item = self.machine_flow.port_tableWidget.item(4, 2)
                item.setText("{}".format(status))

            if text == "Collimator":
                item = self.machine_flow.port_tableWidget.item(5, 2)
                item.setText("{}".format(status))

            if text == "Light_panel":
                item = self.machine_flow.port_tableWidget.item(6, 2)
                item.setText("{}".format(status))

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at update_text function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def overall_prod_qty_count(self, count):
        try:
            """
              This method is used to update the overall quantity.
              param lists: count datatype is int
              return: None
            """
            item = QtWidgets.QTableWidgetItem(str(f"{count}"))
            item.setTextAlignment(Qt.AlignCenter)
            item.setForeground(QColor(0, 100, 255))
            self.tableWidget.setItem(0, 1, item)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at overall_prod_qty_count function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def update_cycle_result(self, result):
        try:
            """
              This method is used to update the auto sequence validation status.
              param lists: None
              return: None
            """
            if result == "Passed":
                item = QtWidgets.QTableWidgetItem(str("Passed"))
                item.setTextAlignment(Qt.AlignCenter)
                item.setForeground(QColor(0, 255, 0))
                self.tableWidget.setItem(3, 1, item)

            elif result == "Failed":
                item = QtWidgets.QTableWidgetItem(str("Failed"))
                item.setTextAlignment(Qt.AlignCenter)
                item.setForeground(QColor(255, 0, 0))
                self.tableWidget.setItem(3, 1, item)

            else:
                item = QtWidgets.QTableWidgetItem(str("NA"))
                item.setTextAlignment(Qt.AlignCenter)
                item.setForeground(QColor(0, 255, 0))
                self.tableWidget.setItem(3, 1, item)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at update_cycle_result function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def update_yield(self):
        try:
            """
              This method is used to update the yield in the UI.
              param lists: None
              return: None
            """
            if self.is_config_loaded:
                if os.path.isfile(self.passed_excel_path) or os.path.isfile(self.failed_excel_path) or \
                        os.path.isfile(self.intermediate_excel_path):
                    paths = [self.passed_excel_path, self.failed_excel_path, self.intermediate_excel_path]
                    passed_count = 0
                    failed_count = 0
                    intermediate_count = 0
                    for idx, path in enumerate(paths):
                        data = pd.read_excel(io=path, sheet_name=1)
                        overall_result = data["Overall Result"]
                        if idx == 0:
                            if len(overall_result) > 1:
                                passed_count = len(overall_result) - 1
                        elif idx == 1:
                            if len(overall_result) > 1:
                                failed_count = len(overall_result) - 1
                        elif idx == 2:
                            if len(overall_result) > 1:
                                intermediate_count = len(overall_result) - 1

                    overall_running = passed_count + failed_count + intermediate_count
                    if overall_running > 0:
                        item = QtWidgets.QTableWidgetItem(str(f"{overall_running}"))
                        item.setTextAlignment(Qt.AlignCenter)
                        item.setForeground(QColor(0, 100, 255))
                        self.tableWidget.setItem(0, 1, item)

                    if passed_count > 0:
                        item = QtWidgets.QTableWidgetItem(str(f"{passed_count}"))
                        item.setTextAlignment(Qt.AlignCenter)
                        item.setForeground(QColor(0, 153, 76))
                        self.tableWidget.setItem(1, 1, item)

                    if failed_count > 0:
                        item = QtWidgets.QTableWidgetItem(str(f"{failed_count}"))
                        item.setTextAlignment(Qt.AlignCenter)
                        item.setForeground(QColor(255, 0, 0))
                        self.tableWidget.setItem(2, 1, item)

                else:
                    if not os.path.isfile(self.passed_excel_path):
                        self.statusbar.setText("Passed Reports excel doesn't exist in the path")
                        logger.error("Passed Reports excel doesn't exist in the path")
                        return
                    if not os.path.isfile(self.failed_excel_path):
                        self.statusbar.setText("Failed Reports excel doesn't exist in the path")
                        logger.error("Failed Reports excel doesn't exist in the path")
                        return
                    if not os.path.isfile(self.intermediate_excel_path):
                        self.statusbar.setText("Intermediate Reports excel doesn't exist in the path")
                        logger.error("Intermediate Reports excel doesn't exist in the path")
                        return

            else:
                logger.error("Config file is not loaded")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at update_yield function :{}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def clear_recipe_creation_data(self):
        """
          This method is used to clear the recipe creation page textboxes and labels.
          param lists: None
          return: None
        """
        self.collimator_simulate_clicked = False
        self.collimator_clicked = False
        self.collimator_chart_check_clicked = False
        self.collimator_offset_clicked = False
        self.relay_simulate_clicked = False
        self.relay_clicked = False
        self.relay_chart_check_clicked = False
        self.relay_offset_clicked = False
        self.device_name_box.clear()
        self.resolution_box.currentIndexChanged.disconnect(self.on_resolution_changed)
        self.resolution_box.clear()
        self.resolution_box.currentIndexChanged.connect(self.on_resolution_changed)
        self.device_name_box.setText("No Devices")
        self.collimator_azimuth_lndt.setText("")
        self.collimator_radius_lndt.setText("")
        self.collimator_width_lndt.setText("")
        self.collimator_height_lndt.setText("")
        self.no_of_ROI_txtbox.setCurrentText("5")
        self.chart_position_box.setCurrentText("C, TL, TR, BL, BR")
        self.azimuth_ang_txtbox.setText("")
        self.outer_radius_txtbox.setText("")
        self.width_txtbox.setText("")
        self.height_txtbox.setText("")
        self.inr_radius_txtbox.setText("")
        self.inr_azimuth_ang_txtbox.setText("")
        self.collimator_red_value_lndt.setText("")
        self.collimator_blue_value_lndt.setText("")
        self.collimator_green_value_lndt.setText("")
        self.relay_red_value_lndt.setText("")
        self.relay_blue_value_lndt.setText("")
        self.relay_green_value_lndt.setText("")
        self.relay_black_lvl_value_lndt.setText("")
        self.collimator_black_lvl_value_lndt.setText("")
        self.collimator_median_frame_cnt_lndt.setText("")
        self.relay_median_frame_cnt_lndt.setText("")
        self.get_device_btn.setEnabled(True)

    def run_thread_streaming(self):
        try:
            """
              This method is used to start the thread for camera connection in recipe creation page.
              param lists: None
              return: None
            """
            logger.info('get device clicked')
            if self.push_button_timer.isActive():
                self.push_button_timer.stop()

            if not self.update:
                self.update = True
                logger.info("Thread initialization started")
                threadCount = QThreadPool.globalInstance().maxThreadCount()
                pool = QThreadPool.globalInstance()
                pool.setMaxThreadCount(16)
                if threadCount >= 2:
                    runnable = Runnable_streaming(pool)
                    runnable.signals.call_ResetPreview_recipe_page.connect(self.No_preview_window_found_recipe_page)
                    runnable.signals.call_updateLbl.connect(self.update_imageToLbl_1)
                    runnable.signals.call_MsgBox.connect(self.msg_box_call)
                    runnable.signals.update_statusbar.connect(self.update_statusbar_text)
                    runnable.signals.update_device_text.connect(self.update_device_text)
                    runnable.signals.clear_all.connect(self.clear_recipe_creation_data)
                    pool.start(runnable)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at run_thread_streaming function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.No_preview_window_found_recipe_page()

    def homing_all(self):
        try:
            """
              This method is used to start the homing thread.
              param lists: None
              return: None
            """
            logger.info("Init button is clicked")
            if self.ready_port:
                msg_box = QMessageBox()
                msg_box.setIcon(QMessageBox.Question)
                msg_box.setWindowTitle("Question")
                msg_box.setText("Do you want to perform machine homing?")
                msg_box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                msg_box.setDefaultButton(QMessageBox.Yes)
                msg_box.exec()
                choice = msg_box.result()
                if choice == QMessageBox.Yes:
                    logger.info("User select yes")
                    self.statusbar.setText("Machine Homing is in progress..")
                    li = [self.gluing_homing, self.z_curing_homing, self.z_gluing_homing, self.z_relay_homing,
                          self.y_axis_homing, self.x_axis_homing, self.plc_initialize_homing,
                          self.front_door_homing]
                    for x in li:
                        x.setCheckState(Qt.Unchecked)
                    self.init_clicked = True
                    self.connect_ports_thread()

                else:
                    self.init_clicked = False
                    logger.info("User cancelled the init")
            else:
                self.msg_box_call("Permission Denied!", "Ports are not connected", "Critical")
                return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.e("Error at homing_all function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.No_preview_found()

    def connect_ports_thread(self):
        try:
            """
              This method is used to start the port connection thread.
              param lists: None
              return: None
            """
            if self.push_button_timer.isActive():
                self.push_button_timer.stop()

            if not self.refresh_btn_clicked:
                logger.info("Port_connect_Thread initialization started")
                threadCount = QThreadPool.globalInstance().maxThreadCount()
                home_pool = QThreadPool.globalInstance()
                home_pool.setMaxThreadCount(16)
                if threadCount >= 2:
                    self.refresh_btn_clicked = True
                    runnable_ports = Runnable_ports(home_pool)
                    ui.machine_flow.port_btn_refresh.setEnabled(False)
                    ui.machine_flow.port_btn_dclose.setEnabled(False)
                    runnable_ports.signals.call_MsgBox.connect(self.msg_box_call)
                    runnable_ports.signals.close_MsgBox.connect(self.close_msg)
                    runnable_ports.signals.call_text.connect(self.update_text)
                    runnable_ports.signals.update_io_status.connect(self.update_input_output_values)
                    runnable_ports.signals.show_dialog.connect(self.dialog_execute)
                    runnable_ports.signals.call_ResetPreview.connect(self.No_preview_found)
                    runnable_ports.signals.close_dialog.connect(self.dialog_close)
                    runnable_ports.signals.update_statusbar.connect(self.update_statusbar_text)
                    home_pool.start(runnable_ports)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at connect_ports_thread function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def update_progressbar(self, value):
        """
          This method is used to update the progress bar value.
          param lists: None
          return: None
        """
        self.progress_bar.setValue(value)

    def update_device_text(self, types, text):
        """
          This method is used to update the camera name, resolution, exposure in recipe creation page.
          param lists: types and text is str
          return: None
        """
        if types == "Camera name":
            self.device_name_box.setText(text)
        elif types == "Exposure":
            self.exposure_box.setCurrentText(text)
        elif types == "Resolution":
            self.resolution_box.addItems(text)

    def update_statusbar_text(self, text):
        try:
            """
              This method is used to update the current progress in status bar.
              param lists: text is str
              return: None
            """
            self.statusbar.setText(text)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at update_statusbar_text function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def close_mtf_graph(self):
        try:
            """
              This method is used to close the mtf plot graph.
              param lists: None
              return: None
            """
            self.plt_graph.clf()
            self.plt_graph.close()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at close_mtf_graph function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def step_run_btn_enable_function(self, btn_state):
        """
          This method is used to enable and disable the step run button.
          param lists: btn_state is bool
          return: None
        """
        if btn_state:
            self.step_run_btn.setEnabled(True)
        else:
            self.step_run_btn.setEnabled(False)

    def step_run_flag_disable_function(self):
        self.step_run_btn_clicked = False

    def run_thread(self):
        try:
            """
              This method is used to start the thread for auto sequence and step run sequence.
              param lists: None
              return: None
            """
            if not self.timer:
                if self.mtf_excel["Final Test"]:
                    logger.info("Final test true in config file")
                    if self.excel["Gluing Status"]["Gluing station"]:
                        self.msg_box_call("Alert", "Please disable the Gluing option", "Critical")
                        self.No_preview_found()
                        return

                    if self.excel["Curing Status"]["Curing station"]:
                        self.msg_box_call("Alert", "Please disable the Curing option", "Critical")
                        self.No_preview_found()
                        return

                    if self.excel["After glue focus"]["Relay station"]:
                        self.msg_box_call("Alert", "Please disable the After glue focus option", "Critical")
                        self.No_preview_found()
                        return

                    if self.excel["After cure focus"]["Relay station"]:
                        self.msg_box_call("Alert", "Please disable the After cure focus option", "Critical")
                        self.No_preview_found()
                        return

                    self.validation_clicked = False
                    self.get_result_clicked = True

                else:
                    self.validation_clicked = True
                    self.get_result_clicked = False
                try:
                    if self.consider_focus_chart_flag and bool(self.mtf_excel["Consider all region"]):  # Another config
                        self.msg_box_call("Permission Denied!", "Please choose any one in Consider one region or "
                                                                "Consider all region in MTF config file", "Critical")
                        self.No_preview_found()
                        return

                except Exception as e:
                    logger.error("Error at read mtf excel")
                    self.validation_clicked = False
                    self.get_result_clicked = False
                    return

                self.start_val_time_now = datetime.datetime.now()
                self.start_val_time = self.start_val_time_now.strftime("%H:%M:%S")
                logger.info("Auto sequence start-time: {}".format(self.start_val_time))
                logger.info("Thread initialization started")
                threadCount = QThreadPool.globalInstance().maxThreadCount()
                pool = QThreadPool.globalInstance()
                pool.setMaxThreadCount(16)
                if threadCount >= 2:
                    self.timer = True
                    if self.first_step_run_clicked:
                        self.first_step_run_clicked = True
                        self.first_start_btn_clicked = False
                    else:
                        self.first_step_run_clicked = False
                        self.first_start_btn_clicked = True
                    runnable = Runnable(pool)
                    runnable.signals.call_ResetPreview.connect(self.No_preview_found)
                    runnable.signals.cycle_result.connect(self.update_cycle_result)
                    runnable.signals.updateProgressVal.connect(self.update_progressbar)
                    runnable.signals.product_qty_count.connect(self.overall_prod_qty_count)
                    runnable.signals.call_updateLbl.connect(self.update_imageToLbl)
                    runnable.signals.call_MsgBox.connect(self.msg_box_call)
                    runnable.signals.close_MsgBox.connect(self.close_msg)
                    runnable.signals.update_results.connect(self.update_result)
                    runnable.signals.update_excel.connect(self.update_excel)
                    runnable.signals.update_live_graph.connect(self.update_mtf_plot_live)
                    runnable.signals.close_graph.connect(self.close_mtf_graph)
                    runnable.signals.update_statusbar.connect(self.update_statusbar_text)
                    runnable.signals.update_station_position.connect(self.update_station_position)
                    runnable.signals.step_run_btn_enable.connect(self.step_run_btn_enable_function)
                    runnable.signals.step_run_flag.connect(self.step_run_flag_disable_function)
                    pool.start(runnable)

                else:
                    logger.error("Can not able to start thread")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at run_thread function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.No_preview_found()
            return

    def fingerprint_thread(self):
        try:
            """
              This method is used to start the thread for fingerprint creation.
              param lists: None
              return: None
            """
            if self.push_button_timer.isActive():
                self.push_button_timer.stop()

            if not self.fingerprint_login:
                logger.info("Fingerprint thread initialization started")
                threadCount = QThreadPool.globalInstance().maxThreadCount()
                pool = QThreadPool.globalInstance()
                pool.setMaxThreadCount(16)
                if threadCount >= 2:
                    self.fingerprint_login = True
                    runnable = Fingerprint_runnable(pool)
                    runnable.signals.call_MsgBox.connect(self.msg_box_call)
                    runnable.signals.update_fingerprint_img.connect(self.fingerprint_update_lbl)
                    runnable.signals.call_user.connect(self.evt_btn_mode)
                    pool.start(runnable)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at fingerprint_thread function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))


class Fingerprint_runnable(QRunnable):
    """
    This class is used to run the Qthread for fingerprint scanner
    """

    def __init__(self, threadpool):
        try:
            super(Fingerprint_runnable, self).__init__()
            self.signals = WorkerSignals()
            self.fingerprint_obj = MFS100()
            self.fingerprint_data = FingerData()
            self.match_fingerprint = None
            self.fingerprint_list = None
            self.threadpool = threadpool

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at Fingerprint_runnable class : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def run(self):
        try:
            logger.info("*********Fingerprint Thread Started!*************")
            self.threadpool.reserveThread()
            if ui.fingerprint_login:
                ui.fingerprint_login = False
                if ui.fingerprint_create_flag:
                    ui.fingerprint_create_flag = False
                    self.create_fingerprint_process()
                else:
                    self.get_fingerprint_data()
            ui.close_fingerprint_thread = False
            self.fingerprint_obj.Uninit()
            self.fingerprint_obj.Dispose()
            logger.info("Fingerprint Thread completed")
            self.threadpool.releaseThread()
            logger.info("*********Fingerprint Thread Completed!*************")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at Fingerprint_run function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def get_fingerprint_data(self):
        try:
            """
              This method is used to get the match the fingerprint from db and login fingerprint.
              param lists: None
              return: None
            """
            is_connected = self.fingerprint_obj.IsConnected()
            if is_connected:
                fingerprint_init = self.fingerprint_obj.Init()
                if fingerprint_init == 0:
                    count = 0
                    score = 0
                    while len(ui.emp_id_txtbox.text()) == 9 and count < 3:
                        capture = self.fingerprint_obj.AutoCapture(fingerprintData=self.fingerprint_data, TimeOut=10000,
                                                                   ShowPreview=True,
                                                                   IsDetectFinger=True)
                        if capture[0] == 0 and capture[1].Quality >= 50:
                            iso = capture[1].ISOTemplate
                            convert_bytearray = list(bytearray(iso))
                            for x in ui.biometric:
                                ret, score = self.fingerprint_obj.MatchISO(convert_bytearray, x, score)
                                if score >= 10000:
                                    if ui.mycursor[0] == "ADMIN" or ui.mycursor[0] == "OPERATOR" \
                                            or ui.mycursor[0] == "SUPERVISOR":
                                        self.signals.call_user.emit("{}".format(ui.mycursor[0]))
                                        self.fingerprint_obj.Uninit()
                                        return

                            if count < 2:
                                self.signals.call_MsgBox.emit('Alert', "Fingerprint is not matched", "Critical_finger")
                                while True:
                                    if ui.ok_pressed:
                                        ui.ok_pressed = False
                                        break
                            count += 1
                    else:
                        self.signals.call_MsgBox.emit('Alert', "Fingerprint attempt failed\n"
                                                               "Get privilege from supervisor",
                                                      "Critical_finger")
                        ui.emp_id_txtbox.clear()
                        return
                else:
                    self.signals.call_MsgBox.emit('Alert', 'Fingerprint initialization is failed', 'Critical')
                    return

            else:
                self.signals.call_MsgBox.emit('Alert', 'Fingerprint device is not connected', 'Critical')
                return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at get_fingerprint_data function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def convert_bytearray_to_image(self, byte_array):
        try:
            """
              This method is used to convert the byte array into image.
              param lists: byte_array is numpy array
              return: None
            """
            bytes_data = bytes(byte_array)
            image = Image.open(io.BytesIO(bytes_data))
            image_data = image.convert("RGBA").tobytes("raw", "RGBA")
            qpixmap = QPixmap.fromImage(QImage(image_data, image.size[0], image.size[1], QImage.Format_RGBA8888))
            return qpixmap

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at convert_bytearray_to_image function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno,
                                                                                    e))

    def create_fingerprint_process(self):
        try:
            """
              This method is used to create the fingerprint process.
              param lists: None
              return: None
            """
            fingerprint_list = []
            score_1 = 0
            score_2 = 0
            score_3 = 0
            is_connected = self.fingerprint_obj.IsConnected()
            if is_connected:
                fingerprint_init = self.fingerprint_obj.Init()
                if fingerprint_init == 0:
                    for x in range(3):
                        get_fingerprint = False
                        while not get_fingerprint:
                            capture = self.fingerprint_obj.AutoCapture(fingerprintData=self.fingerprint_data,
                                                                       TimeOut=10000, ShowPreview=True,
                                                                       IsDetectFinger=True)
                            if ui.close_fingerprint_thread:
                                return
                            if capture[1] is not None:
                                bytes = self.fingerprint_obj.BitmapToBytes(capture[1].FingerImage)
                                image = self.convert_bytearray_to_image(bytes)
                                self.signals.update_fingerprint_img.emit(image)
                                if capture[0] == 0 and capture[1].Quality >= 50:
                                    iso = capture[1].ISOTemplate
                                    fingerprint_list.append(iso)
                                    if x == 0:
                                        self.signals.call_MsgBox.emit('Alert',
                                                                      "Your First Fingerprint got successfully",
                                                                      "Critical_finger")
                                        while True:
                                            if ui.ok_pressed:
                                                ui.ok_pressed = False
                                                break
                                        get_fingerprint = True

                                    if len(fingerprint_list) == 2:
                                        ret, score_1 = self.fingerprint_obj.MatchANSI(fingerprint_list[0],
                                                                                      fingerprint_list[1],
                                                                                      score_1)
                                        if score_1 >= 10000:
                                            self.signals.call_MsgBox.emit('Alert',
                                                                          "Your Second Fingerprint got successfully",
                                                                          "Critical_finger")
                                            while True:
                                                if ui.ok_pressed:
                                                    ui.ok_pressed = False
                                                    break
                                            get_fingerprint = True

                                        else:
                                            self.signals.call_MsgBox.emit('Alert',
                                                                          "Your Fingerprint does not match with your "
                                                                          "previous fingerprint", "Critical_finger")
                                            while True:
                                                if ui.ok_pressed:
                                                    ui.ok_pressed = False
                                                    break
                                            fingerprint_list.pop()

                                    if len(fingerprint_list) == 3:
                                        ret, score_2 = self.fingerprint_obj.MatchANSI(fingerprint_list[0],
                                                                                      fingerprint_list[2],
                                                                                      score_2)
                                        if score_2 >= 10000:
                                            ret, score_3 = self.fingerprint_obj.MatchANSI(fingerprint_list[1],
                                                                                          fingerprint_list[2],
                                                                                          score_3)
                                            if score_3 >= 10000:
                                                self.signals.call_MsgBox.emit('Alert',
                                                                              "Your Third Fingerprint got successfully",
                                                                              "Critical_finger")
                                                while True:
                                                    if ui.ok_pressed:
                                                        ui.ok_pressed = False
                                                        break
                                                get_fingerprint = True

                                            else:
                                                self.signals.call_MsgBox.emit('Alert',
                                                                              "Your last Fingerprint does not match with "
                                                                              "second fingerprint \n So please "
                                                                              "place your correct fingerprint",
                                                                              "Critical_finger")
                                                while True:
                                                    if ui.ok_pressed:
                                                        ui.ok_pressed = False
                                                        break
                                                fingerprint_list.pop()

                                        else:
                                            self.signals.call_MsgBox.emit('Alert',
                                                                          "Your last Fingerprint does not match with "
                                                                          "your first fingerprint \n So please place "
                                                                          "your correct fingerprint", "Critical_finger")
                                            while True:
                                                if ui.ok_pressed:
                                                    ui.ok_pressed = False
                                                    break
                                            fingerprint_list.pop()

                                    if len(fingerprint_list) == 3:
                                        byte_list = []
                                        for x in fingerprint_list:
                                            fingerprint_bytearray = bytearray(x)
                                            convert_bytearray = list(fingerprint_bytearray)
                                            byte_list.append(convert_bytearray)
                                        ui.fingerprint_list = byte_list

                                else:
                                    self.signals.call_MsgBox.emit('Alert', "Place your finger properly",
                                                                  "Critical_finger")
                                    while True:
                                        if ui.ok_pressed:
                                            ui.ok_pressed = False
                                            break
                else:
                    self.signals.call_MsgBox.emit('Alert', 'Fingerprint initialization is failed', 'Critical')
                    return
            else:
                self.signals.call_MsgBox.emit('Alert', 'Fingerprint device is not connected', 'Critical')
                return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at create_fingerprint_process function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno,
                                                                                    e))


class WorkerSignals(QObject):
    """
    This class is used to create the signal for all threads using in this application.
    """
    call_ResetPreview = pyqtSignal(str)
    cycle_result = pyqtSignal(str)
    update_fingerprint_img = pyqtSignal(object)
    update_results = pyqtSignal(object, object, str, object)
    update_live_graph = pyqtSignal(dict, str)
    close_graph = pyqtSignal()
    update_excel = pyqtSignal(list, str, dict, object)
    update_statusbar = pyqtSignal(str)
    call_user = pyqtSignal(str)
    updateProgressVal = pyqtSignal(int)
    product_qty_count = pyqtSignal(int)
    call_updateLbl = pyqtSignal(object)
    call_MsgBox = pyqtSignal(str, str, str)
    close_MsgBox = pyqtSignal()
    update_station_position = pyqtSignal(int)
    call_text = pyqtSignal(str, str, list)
    show_dialog = pyqtSignal()
    close_dialog = pyqtSignal()
    call_texts = pyqtSignal(str, str, str)
    finished = pyqtSignal()
    is_thread_running = pyqtSignal()
    step_run_btn_enable = pyqtSignal(bool)
    step_run_flag = pyqtSignal(bool)
    glue_teach_status_updated = pyqtSignal(str)
    update_io_status = pyqtSignal(str, int, str)
    call_ResetPreview_recipe_page = pyqtSignal()
    clear_all = pyqtSignal()
    update_device_text = pyqtSignal(str, object)


class Runnable(QRunnable):
    """
    This class is used to run the Qrunnable thread for auto sequence and step run sequence.
    """

    def __init__(self, threadpool):
        self.overall_result_list = {"loading_station": "Not Tested", "height_sensor_station": "Not Tested",
                                    "focus_station": "Not Tested", "gluing_station": "Not Tested",
                                    "curing_station": "Not Tested",
                                    "result": "Failed", "Fixture offset remarks": ""}
        self.check_clipping = False
        self.enter_threshold = False
        self.emergency_pressed = False
        self.achieve_min_focus = True
        self.completed_basic_rotation = False
        self.find_clkwise = False
        self.final_result = None
        self.format_type = None
        self.eCAM_dll = None
        self.freezed_frame = None
        self.plc_status = None
        self.image = None
        self.camera_connected = False
        self.Device_detected = False
        self.find_anticlockwise = False
        self.thread_stop = False
        self.cap = cv2.VideoCapture()
        try:
            super(Runnable, self).__init__()
            self.label = ui.image_preview
            if self.label.geometry().height() >= int(ui.resolution[1]) and \
                    self.label.geometry().width() >= int(ui.resolution[0]):
                self.dim = (int(ui.resolution[0]), int(ui.resolution[1]))

            elif self.label.geometry().width() > ui.optimal_width:
                self.dim = (ui.optimal_width, self.label.geometry().height())

            elif self.label.geometry().height() > ui.optimal_height:
                self.dim = (self.label.geometry().width(), ui.optimal_height)

            else:
                self.dim = (self.label.geometry().width(), self.label.geometry().height())
            self.threshold = 10
            self.minor_rotation = 0
            self.i = 0
            self.rotation = 0
            self.init_focus_rotation = 0
            self.rotation_dir = "clockwise"
            self.clockwise = ui.rotation_excel['Clockwise']  # Another config
            self.after_glue_iteration = 0
            self.get_peak_value = 0
            self.get_peak_value_C = 0
            self.get_peak_value_TL = 0
            self.get_peak_value_TR = 0
            self.get_peak_value_BL = 0
            self.get_peak_value_BR = 0
            self.after_cure_iteration = 0
            self.checking_rotation = 0
            self.validation_done = False
            self.achieve_low_value = False
            self.front_door_status = None
            self.start_ip_check = False
            self.is_result_updated = False
            self.loading_station_status = ""
            self.ip_status = True
            self.focus_station_status = ""
            self.relay_z_movement_status = ""
            self.gluing_z_movement_status = ""
            self.gluing_y_movement_status = ""
            self.gluing_x1_movement_status = ""
            self.gluing_x2_movement_status = ""
            self.set_lux_status = ""
            self.curing_z_movement_status = ""
            self.curing_door_open_status = ""
            self.mtf_center_value = []
            self.loading_list = []
            self.overall_info = []
            self.mtf_roi_avg = {'All': []}
            self.before_glue = {'All': 0, "Dx": None, "Dy": None}
            self.after_glue = {'All': 0, "Dx": None, "Dy": None}
            self.after_cure = {'All': 0, "Dx": None, "Dy": None}

            self.step_run_front_door = False
            self.step_run_slider = False
            self.step_run_gripper = False
            self.step_run_actuators_focusing_station = False
            self.step_run_actuators_gluing_station = False
            self.step_run_actuators_curing_station = False
            self.step_run_gluing_z_actuator = False
            self.step_run_gluing_x1_actuator = False
            self.step_run_gluing_x2_actuator = False
            self.step_run_gluing_y_actuator = False
            self.step_run_curing_z_actuator = False
            self.step_run_gluing_reverse = False
            self.step_run_curing_door_open = False
            self.step_run_curing_door_open_reverse = False
            self.step_run_curing_door_close = False
            self.step_run_curing_process = False
            self.step_run_curing_unloading = False

            for p in ui.rois.keys():
                self.mtf_roi_avg[p] = []
                self.before_glue[p] = 0
                self.after_glue[p] = 0
                self.after_cure[p] = 0
            self.mtf_roi_list = None
            self.mtf_average_list = []
            self.signals = WorkerSignals()
            self.threadpool = threadpool
            self.lens_offset = LensOffset()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at Runnable init function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def run(self):
        try:
            logger.info("*********Thread Started!*************")
            self.threadpool.reserveThread()
            if ui.first_step_run_clicked:
                self.step_run_sequence()
                self.signals.cycle_result.emit("Passed")
            elif ui.first_start_btn_clicked:
                self.auto_sequence()
            ui.first_step_run_clicked = False
            ui.first_start_btn_clicked = False
            self.signals.updateProgressVal.emit(0)
            time.sleep(0.25)
            status = ui_plc_communication.plc_control_class.tower_light_control(light="Yellow")
            if status != "Passed":
                logger.error("error to set tower light change")
            try:
                self.cap.release()
            except Exception as e:
                logger.error(f"Cap release error in auto sequence run function: {e}")
            cv2.destroyAllWindows()
            logger.info("Thread completed")
            self.threadpool.releaseThread()
            self.signals.call_ResetPreview.emit("")
            del self.cap
            logger.info("*********Thread Completed!*************")
            logger.info("*********Auto flow Completed*************\n")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at run function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))
            self.signals.updateProgressVal.emit(0)
            try:
                self.cap.release()
                del self.cap
            except Exception as e:
                logger.error(f"Cap release error in auto sequence run function: {e}")
            cv2.destroyAllWindows()
            status = self.unloading()
            if status == "Done":
                pass
            else:
                self.signals.update_statusbar.emit("Error in unloading station.")
            status = self.front_door_close_open(command="open")
            if status == "Passed":
                pass
            status = ui_plc_communication.plc_control_class.tower_light_control(light="Yellow")
            if status != "Passed":
                logger.error("error to set tower light change")
            if self.validation_done:
                self.signals.cycle_result.emit("Passed")
            elif not self.validation_done:
                self.signals.cycle_result.emit("Failed")
            else:
                self.signals.cycle_result.emit("NA")
            self.signals.update_statusbar.emit("Error at run function")
            self.signals.close_graph.emit()
            self.signals.close_MsgBox.emit()
            logger.info("Thread completed")
            self.signals.call_ResetPreview.emit("")
            self.threadpool.releaseThread()
            logger.info("*********Thread Completed!*************")

    def step_run_sequence(self):
        try:
            """
              This method is used to run the step run sequence.
              param lists: None
              return: None
            """
            loop_break = True
            while loop_break:
                if not self.step_run_front_door:
                    self.signals.step_run_btn_enable.emit(False)
                    self.signals.step_run_flag.emit(False)
                    self.signals.update_statusbar.emit("Front door close is in progress..")
                    status = self.thread_front_door_tower_light()
                    if status == "Passed":
                        self.signals.update_statusbar.emit("Front door closed.")
                        self.signals.update_station_position.emit(1)
                        t_end = time.time() + 15
                        self.signals.update_statusbar.emit('Camera is connecting...')
                        while time.time() < t_end:
                            try:
                                if self.camera_connected:
                                    break
                            except Exception as e:
                                logger.error(f"Camera connected: {e}")

                        if self.camera_connected:
                            self.step_run_front_door = True
                            self.signals.updateProgressVal.emit(10)
                            self.signals.update_statusbar.emit("Camera is connected")
                        else:
                            status = self.unloading()
                            if status == "Done":
                                self.signals.update_statusbar.emit("Camera is not connected")
                                return
                            else:
                                self.signals.update_statusbar.emit("Error to unload module.")
                    else:
                        status = self.front_door_close_open(command="open")
                        if status == "Passed":
                            self.signals.update_statusbar.emit("Front door close error.")
                        loop_break = False

                    self.signals.step_run_btn_enable.emit(True)
                    time.sleep(0.5)
                    while True:
                        if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                            if ui.step_run_btn_clicked:
                                self.signals.step_run_btn_enable.emit(False)
                                self.signals.step_run_flag.emit(False)
                                break

                            if ui.abort_auto_sequence_clicked:
                                self.validation_done = False
                                status = self.unloading()
                                if status == "Done":
                                    return
                                else:
                                    self.signals.update_statusbar.emit("Error to unload module.")
                                self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                return "Not Done"

                time.sleep(0.5)
                if not self.step_run_slider:
                    self.signals.update_statusbar.emit("Slider moving is in progress...")
                    status = ui_plc_communication.plc_control_class.slider(port_number="Port 2",
                                                                           slider=float(
                                                                               ui.excel["Slider"]["Loading station"]))
                    if status == "Passed":
                        self.step_run_slider = True
                        self.signals.update_statusbar.emit("Slider moving is completed.")
                    else:
                        ip_check = self.check_input_manually()
                        if not ip_check:
                            logger.info("User clicked no in slider while step run sequence.")
                            self.validation_done = False
                            self.overall_result_list["Fixture offset remarks"] = "User selected No in step run process."
                            return "Not Done"

                    self.signals.step_run_btn_enable.emit(True)
                    time.sleep(0.5)
                    while True:
                        if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                            if ui.step_run_btn_clicked:
                                self.signals.step_run_btn_enable.emit(False)
                                self.signals.step_run_flag.emit(False)
                                break

                            if ui.abort_auto_sequence_clicked:
                                self.validation_done = False
                                status = self.unloading()
                                if status == "Done":
                                    pass
                                else:
                                    self.signals.update_statusbar.emit("Error to unload module.")
                                self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                return "Not Done"

                time.sleep(0.5)
                if not self.step_run_gripper:
                    self.signals.update_statusbar.emit("Gripper moving is in progress...")
                    status = ui_plc_communication.plc_control_class.gripper(
                        gripper=float(ui.excel["Gripper"]["Loading station"]))
                    if status == "Passed":
                        self.signals.update_statusbar.emit("Gripper moving is completed.")
                        self.step_run_gripper = True
                    else:
                        ip_check = self.check_input_manually()
                        if not ip_check:
                            logger.info("User clicked no in gripper while step run sequence.")
                            self.validation_done = False
                            self.overall_result_list["Fixture offset remarks"] = "User selected No in step run process."
                            return "Not Done"

                    self.signals.step_run_btn_enable.emit(True)
                    time.sleep(0.5)
                    while True:
                        if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                            if ui.step_run_btn_clicked:
                                self.signals.step_run_btn_enable.emit(False)
                                self.signals.step_run_flag.emit(False)
                                break

                            if ui.abort_auto_sequence_clicked:
                                self.validation_done = False
                                status = self.unloading()
                                if status == "Done":
                                    pass
                                else:
                                    self.signals.update_statusbar.emit("Error to unload module.")
                                self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                return "Not Done"

                time.sleep(0.5)
                if not self.step_run_actuators_focusing_station:
                    if ui.setup_type == "Collimator station":
                        self.signals.update_station_position.emit(3)
                    else:
                        self.signals.update_station_position.emit(4)
                    self.signals.update_statusbar.emit(f"X and Y actuator moving to {ui.setup_type} station...")
                    status = self.parallel_x_y(ui.focus_station_x_value, ui.focus_station_y_value)
                    if status == "Done":
                        self.step_run_actuators_focusing_station = True
                        self.signals.update_statusbar.emit("X and Y actuator moving is completed.")
                    else:
                        ip_check = self.check_input_manually()
                        if not ip_check:
                            logger.info("User clicked no in actuator movement while step run sequence.")
                            self.validation_done = False
                            self.overall_result_list["Fixture offset remarks"] = "User selected No in step run process."
                            return "Not Done"

                    self.signals.step_run_btn_enable.emit(True)
                    time.sleep(0.5)
                    while True:
                        if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                            if ui.step_run_btn_clicked:
                                self.signals.step_run_btn_enable.emit(False)
                                self.signals.step_run_flag.emit(False)
                                break

                            if ui.abort_auto_sequence_clicked:
                                self.validation_done = False
                                status = self.unloading()
                                if status == "Done":
                                    pass
                                else:
                                    self.signals.update_statusbar.emit("Error to unload module.")
                                self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                return "Not Done"

                time.sleep(0.5)
                if bool(ui.excel["Gluing Status"]["Gluing station"]):
                    if not self.step_run_actuators_gluing_station:
                        self.signals.update_statusbar.emit("Gluing init is in progress...")
                        status = ui_plc_communication.plc_control_class.gluing_init()
                        if status == "Passed":
                            self.signals.update_station_position.emit(5)
                            self.signals.update_statusbar.emit("Gluing init is completed.")
                            time.sleep(0.25)
                            self.signals.update_statusbar.emit("X and Y actuators moving to gluing station...")
                            status = self.parallel_x_y(
                                position_x=float(ui.excel["X-Actuator Gluing"]["Gluing station"]),
                                position_y=float(ui.excel["Y-Actuator Gluing"]["Gluing station"]))
                            if status == "Done":
                                self.signals.update_statusbar.emit("X and Y actuators moved to gluing station.")
                                self.step_run_actuators_gluing_station = True
                            else:
                                ip_check = self.check_input_manually()
                                if not ip_check:
                                    logger.info("User clicked no in actuator movement while step run sequence.")
                                    self.validation_done = False
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "User selected No in step run process."
                                    return "Not Done"
                        else:
                            ip_check = self.check_input_manually()
                            if not ip_check:
                                logger.info("User clicked no in while step run gluing init.")
                                self.validation_done = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User selected No in step run process."
                                return "Not Done"

                        self.signals.step_run_btn_enable.emit(True)
                        time.sleep(0.5)
                        while True:
                            if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                                if ui.step_run_btn_clicked:
                                    self.signals.step_run_btn_enable.emit(False)
                                    self.signals.step_run_flag.emit(False)
                                    break

                                if ui.abort_auto_sequence_clicked:
                                    self.validation_done = False
                                    status = self.cure_glue_unloading()
                                    if status == "Done":
                                        pass
                                    else:
                                        self.signals.update_statusbar.emit("Error to unload module.")
                                    self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                    return "Not Done"

                    time.sleep(0.5)
                    if not self.step_run_gluing_z_actuator:
                        self.signals.update_statusbar.emit("Gluing Z-axis moving is in progress...")
                        status = ui_plc_communication.modbus_class.actuator_movement(slave_id=3,
                                                                                     distance=float(ui.excel[
                                                                                                        "Z-Actuator Gluing"][
                                                                                                        "Gluing station"]))
                        if status == "Passed":
                            self.signals.update_statusbar.emit("Gluing Z-axis moved.")
                            self.step_run_gluing_z_actuator = True
                        else:
                            ip_check = self.check_input_manually()
                            if not ip_check:
                                logger.info("User clicked no in actuator movement while step run sequence.")
                                self.validation_done = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User selected No in step run process."
                                return "Not Done"

                        self.signals.step_run_btn_enable.emit(True)
                        time.sleep(0.5)
                        while True:
                            if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                                if ui.step_run_btn_clicked:
                                    self.signals.step_run_btn_enable.emit(False)
                                    self.signals.step_run_flag.emit(False)
                                    break

                                if ui.abort_auto_sequence_clicked:
                                    self.validation_done = False
                                    status = self.cure_glue_unloading()
                                    if status == "Done":
                                        pass
                                    else:
                                        self.signals.update_statusbar.emit("Error to unload module.")
                                    self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                    return "Not Done"

                    if ui.excel["Glue Type"]["Gluing station"] == "Spot glue":
                        time.sleep(0.5)
                        if not self.step_run_gluing_y_actuator:
                            self.signals.update_statusbar.emit("Gluing Y-axis moving is in progress..")
                            status = ui_plc_communication.plc_control_class.glue_manual_move_recipe(y_manual=20)
                            if status == "Passed":
                                self.step_run_gluing_y_actuator = True
                                self.signals.update_statusbar.emit("Gluing Y-axis moved.")
                            else:
                                ip_check = self.check_input_manually()
                                if not ip_check:
                                    logger.info("User clicked no in actuator movement while step run sequence.")
                                    self.validation_done = False
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "User selected No in step run process."
                                    return "Not Done"

                            self.signals.step_run_btn_enable.emit(True)
                            time.sleep(0.5)
                            while True:
                                if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                                    if ui.step_run_btn_clicked:
                                        self.signals.step_run_btn_enable.emit(False)
                                        self.signals.step_run_flag.emit(False)
                                        break

                                    if ui.abort_auto_sequence_clicked:
                                        self.validation_done = False
                                        status = self.cure_glue_unloading()
                                        if status == "Done":
                                            pass
                                        else:
                                            self.signals.update_statusbar.emit("Error to unload module.")
                                        self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                        return "Not Done"

                        time.sleep(0.5)
                        if not self.step_run_gluing_x1_actuator:
                            self.signals.update_statusbar.emit("Gluing X1-axis moving is in progress..")
                            status = ui_plc_communication.plc_control_class.gluing_x1_move(x1_manual=float(
                                ui.excel["Gluing x1"]["Gluing station"]))
                            if status == "Passed":
                                self.step_run_gluing_x1_actuator = True
                                self.signals.update_statusbar.emit("Gluing X1-axis moved.")
                            else:
                                ip_check = self.check_input_manually()
                                if not ip_check:
                                    logger.info("User clicked no in actuator movement while step run sequence.")
                                    self.validation_done = False
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "User selected No in step run process."
                                    return "Not Done"

                            self.signals.step_run_btn_enable.emit(True)
                            time.sleep(0.5)
                            while True:
                                if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                                    if ui.step_run_btn_clicked:
                                        self.signals.step_run_btn_enable.emit(False)
                                        self.signals.step_run_flag.emit(False)
                                        break

                                    if ui.abort_auto_sequence_clicked:
                                        self.validation_done = False
                                        status = self.cure_glue_unloading()
                                        if status == "Done":
                                            pass
                                        else:
                                            self.signals.update_statusbar.emit("Error to unload module.")
                                        self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                        return "Not Done"

                        time.sleep(0.5)
                        if not self.step_run_gluing_x2_actuator:
                            self.signals.update_statusbar.emit("Gluing X2-axis moving is in progress..")
                            status = ui_plc_communication.plc_control_class.glue_manual_move_recipe(
                                port_number="Port 2",
                                x2_manual=
                                float(ui.excel["Gluing x2"]
                                      ["Gluing station"]))
                            if status == "Passed":
                                self.step_run_gluing_x2_actuator = True
                                self.signals.update_statusbar.emit("Gluing X2-axis moved.")
                            else:
                                ip_check = self.check_input_manually()
                                if not ip_check:
                                    logger.info("User clicked no in actuator movement while step run sequence.")
                                    self.validation_done = False
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "User selected No in step run process."
                                    return "Not Done"

                            self.signals.step_run_btn_enable.emit(True)
                            time.sleep(0.5)
                            while True:
                                if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                                    if ui.step_run_btn_clicked:
                                        self.signals.step_run_btn_enable.emit(False)
                                        self.signals.step_run_flag.emit(False)
                                        break

                                    if ui.abort_auto_sequence_clicked:
                                        self.validation_done = False
                                        status = self.cure_glue_unloading()
                                        if status == "Done":
                                            pass
                                        else:
                                            self.signals.update_statusbar.emit("Error to unload module.")
                                        self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                        return "Not Done"

                        self.signals.call_MsgBox.emit("Question", "Do you want to Glue Purge ?", "Question")
                        while True:
                            if ui.user_call_init_yes:
                                self.signals.update_statusbar.emit("Gluing purge is in progress...")
                                status = ui_plc_communication.plc_control_class.glue_dispenser_timer(
                                    timer=float(ui.excel["Glue time"]["Gluing station"]),
                                    x1_value=float(ui.excel["Gluing x1"]))
                                if status == "Passed":
                                    self.signals.update_statusbar.emit("Gluing purge is completed.")
                                    break
                                else:
                                    ip_check = self.check_input_manually()
                                    if not ip_check:
                                        logger.info("User clicked no in actuator movement while step run sequence.")
                                        self.validation_done = False
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "User selected No in step run process."
                                        return "Not Done"

                                self.signals.step_run_btn_enable.emit(True)
                                time.sleep(0.5)
                                while True:
                                    if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                                        if ui.step_run_btn_clicked:
                                            self.signals.step_run_btn_enable.emit(False)
                                            self.signals.step_run_flag.emit(False)
                                            break

                                        if ui.abort_auto_sequence_clicked:
                                            self.validation_done = False
                                            status = self.cure_glue_unloading()
                                            if status == "Done":
                                                pass
                                            else:
                                                self.signals.update_statusbar.emit("Error to unload module.")
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "User abort the sequence."
                                            return "Not Done"

                            elif ui.user_call_init_no:
                                self.signals.step_run_btn_enable.emit(True)
                                time.sleep(0.5)
                                while True:
                                    if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                                        if ui.step_run_btn_clicked:
                                            self.signals.step_run_btn_enable.emit(False)
                                            self.signals.step_run_flag.emit(False)
                                            break

                                        if ui.abort_auto_sequence_clicked:
                                            self.validation_done = False
                                            status = self.cure_glue_unloading()
                                            if status == "Done":
                                                pass
                                            else:
                                                self.signals.update_statusbar.emit("Error to unload module.")
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "User abort the sequence."
                                            return "Not Done"
                                self.signals.update_statusbar.emit("Gluing purge option cancelled by the user.")
                                logger.info("Gluing purge option cancelled by the user in step run.")
                                break

                        time.sleep(0.5)
                        if not self.step_run_gluing_reverse:
                            self.signals.update_statusbar.emit("Gluing reverse is in progress...")
                            status = ui_plc_communication.plc_control_class.glue_reverse_paralel()
                            if status == "Passed":
                                self.signals.update_statusbar.emit("Gluing reverse is completed.")
                                self.step_run_gluing_reverse = True
                            else:
                                ip_check = self.check_input_manually()
                                if not ip_check:
                                    logger.info("User clicked no in actuator movement while step run sequence.")
                                    self.validation_done = False
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "User selected No in step run process."
                                    return "Not Done"

                            self.signals.step_run_btn_enable.emit(True)
                            time.sleep(0.5)
                            while True:
                                if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                                    if ui.step_run_btn_clicked:
                                        self.signals.step_run_btn_enable.emit(False)
                                        self.signals.step_run_flag.emit(False)
                                        break

                                    if ui.abort_auto_sequence_clicked:
                                        self.validation_done = False
                                        status = self.cure_glue_unloading()
                                        if status == "Done":
                                            pass
                                        else:
                                            self.signals.update_statusbar.emit("Error to unload module.")
                                        self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                        return "Not Done"

                    else:
                        time.sleep(0.5)
                        status = ui_plc_communication.plc_control_class.write_values_glue_offset(
                            c1_manual=float(ui.excel["Gluing x1"]["Gluing station"]),
                            c2_manual=float(ui.excel["Gluing x2"]["Gluing station"]))
                        if status == "Passed":
                            self.signals.update_statusbar.emit("Glue apply is in progress...")
                            if pd.isna(ui.excel["Glue on time_delay"]["Gluing station"]) and \
                                    pd.isna(ui.excel["Glue off time_delay"]["Gluing station"]):
                                status = ui_plc_communication.plc_control_class.apply_glue(
                                    speed=ui.excel["Glue speed"]["Gluing station"],
                                    diameter=ui.excel["Glue Diameter"]["Gluing station"],
                                    # if on_delay & off_delay is None
                                    glue_type=ui.excel["Glue Type"]["Gluing station"])

                            elif not pd.isna(ui.excel["Glue on time_delay"]["Gluing station"]) and not \
                                    pd.isna(ui.excel["Glue off time_delay"]["Gluing station"]):
                                status = ui_plc_communication.plc_control_class.apply_glue(
                                    speed=ui.excel["Glue speed"]["Gluing station"],
                                    diameter=ui.excel["Glue Diameter"]["Gluing station"],
                                    glue_type=ui.excel["Glue Type"]["Gluing station"],
                                    # if on_delay & off_delay is not None
                                    on_delay=float(ui.excel["Glue on time_delay"]["Gluing station"]),
                                    off_delay=float(ui.excel["Glue off time_delay"]["Gluing station"]))

                            elif not pd.isna(ui.excel["Glue on time_delay"]["Gluing station"]):
                                status = ui_plc_communication.plc_control_class.apply_glue(
                                    speed=ui.excel["Glue speed"]["Gluing station"],
                                    diameter=ui.excel["Glue Diameter"]["Gluing station"],
                                    glue_type=ui.excel["Glue Type"]["Gluing station"],  # if on_delay is Not none
                                    on_delay=float(
                                        ui.excel["Glue on time_delay"]["Gluing station"]))  # and off_delay is None

                            elif not pd.isna(ui.excel["Glue off time_delay"]["Gluing station"]):
                                status = ui_plc_communication.plc_control_class.apply_glue(
                                    speed=ui.excel["Glue speed"]["Gluing station"],
                                    diameter=ui.excel["Glue Diameter"]["Gluing station"],
                                    glue_type=ui.excel["Glue Type"]["Gluing station"],  # if off_delay is Not none
                                    off_delay=float(
                                        ui.excel["Glue off time_delay"]["Gluing station"]))  # and on_delay is None
                            else:
                                logger.error("Invalid glue type values")
                                self.overall_result_list["Fixture offset remarks"] = "Invalid glue type values"
                                self.validation_done = False
                                return "Not Done"

                            if status == "Passed":
                                self.signals.update_statusbar.emit("Glue successfully applied")

                            elif status == "Error in glue cartridge 1 empty" or "Error in glue cartridge 2 empty":
                                self.overall_result_list["Fixture offset remarks"] = f"{status}"
                                self.validation_done = False
                                return "Not Done"
                            else:
                                logger.error("Error in continuous glue apply: {}".format(status))
                                ip_check = self.check_input_manually()
                                if not ip_check:
                                    logger.info("User clicked no in actuator movement while step run sequence.")
                                    self.validation_done = False
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "User selected No in step run process."
                                    return "Not Done"

                if bool(ui.excel["Curing Status"]["Curing station"]):
                    time.sleep(0.5)
                    if not bool(ui.excel["Gluing Status"]["Gluing station"]):
                        self.signals.update_statusbar.emit("Gluing init is in progress...")
                        status = ui_plc_communication.plc_control_class.gluing_init()
                        if status == "Passed":
                            self.signals.update_station_position.emit(6)
                            self.signals.update_statusbar.emit("Gluing init is completed.")
                        else:
                            ip_check = self.check_input_manually()
                            if not ip_check:
                                logger.info("User clicked no in while step run gluing init.")
                                self.validation_done = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User selected No in step run process."
                                return "Not Done"

                    if not self.step_run_curing_door_open:
                        self.signals.update_statusbar.emit("UV door open is in progress...")
                        status = ui_plc_communication.plc_control_class.uv_door_open()
                        if status == "Passed":
                            self.signals.update_statusbar.emit("UV door opened.")
                            self.signals.update_statusbar.emit("X and Y axis moving to curing station...")
                            status = self.parallel_x_y(
                                position_x=float(ui.excel["X-Actuator Curing"]["Curing station"]),
                                position_y=float(ui.excel["Y-Actuator Curing"]["Curing station"]))
                            if status == "Done":
                                self.step_run_curing_door_open = True
                                self.signals.update_statusbar.emit("X and Y actuator moved to curing station.")
                            else:
                                ip_check = self.check_input_manually()
                                if not ip_check:
                                    logger.info("User clicked no in actuator movement while step run sequence.")
                                    self.validation_done = False
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "User selected No in step run process."
                                    return "Not Done"

                            self.signals.step_run_btn_enable.emit(True)
                            time.sleep(0.5)
                            while True:
                                if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                                    if ui.step_run_btn_clicked:
                                        self.signals.step_run_btn_enable.emit(False)
                                        self.signals.step_run_flag.emit(False)
                                        break

                                    if ui.abort_auto_sequence_clicked:
                                        self.validation_done = False
                                        status = self.cure_glue_unloading()
                                        if status == "Done":
                                            pass
                                        else:
                                            self.signals.update_statusbar.emit("Error to unload module.")
                                        self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                        return "Not Done"
                        else:
                            ip_check = self.check_input_manually()
                            if not ip_check:
                                logger.info("User clicked no in actuator movement while step run sequence.")
                                self.validation_done = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User selected No in step run process."
                                return "Not Done"

                    time.sleep(0.5)
                    if not self.step_run_curing_z_actuator:
                        self.signals.update_statusbar.emit("Curing Z-axis moving is in progress...")
                        status = ui_plc_communication.modbus_class.actuator_movement(slave_id=4,
                                                                                     distance=float(ui.excel[
                                                                                                        "Z-Actuator Curing"][
                                                                                                        "Curing station"]))
                        if status == "Passed":
                            self.signals.update_statusbar.emit("Curing Z-axis moved.")
                            self.step_run_curing_z_actuator = True
                        else:
                            ip_check = self.check_input_manually()
                            if not ip_check:
                                logger.info("User clicked no in actuator movement while step run sequence.")
                                self.validation_done = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User selected No in step run process."
                                return "Not Done"

                        self.signals.step_run_btn_enable.emit(True)
                        time.sleep(0.5)
                        while True:
                            if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                                if ui.step_run_btn_clicked:
                                    self.signals.step_run_btn_enable.emit(False)
                                    self.signals.step_run_flag.emit(False)
                                    break

                                if ui.abort_auto_sequence_clicked:
                                    self.validation_done = False
                                    status = self.cure_glue_unloading()
                                    if status == "Done":
                                        pass
                                    else:
                                        self.signals.update_statusbar.emit("Error to unload module.")
                                    self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                    return "Not Done"

                    time.sleep(0.5)
                    if not self.step_run_curing_door_close:
                        self.signals.update_statusbar.emit("Curing door close is in progress...")
                        status = ui_plc_communication.plc_control_class.uv_door_close()
                        if status == "Passed":
                            self.signals.update_statusbar.emit("Curing door closed.")
                            self.step_run_curing_door_close = True
                        else:
                            ip_check = self.check_input_manually()
                            if not ip_check:
                                logger.info("User clicked no in actuator movement while step run sequence.")
                                self.validation_done = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User selected No in step run process."
                                return "Not Done"

                        self.signals.step_run_btn_enable.emit(True)
                        time.sleep(0.5)
                        while True:
                            if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                                if ui.step_run_btn_clicked:
                                    self.signals.step_run_btn_enable.emit(False)
                                    self.signals.step_run_flag.emit(False)
                                    break

                                if ui.abort_auto_sequence_clicked:
                                    self.validation_done = False
                                    status = self.cure_glue_unloading()
                                    if status == "Done":
                                        pass
                                    else:
                                        self.signals.update_statusbar.emit("Error to unload module.")
                                    self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                    return "Not Done"

                    time.sleep(0.5)
                    if not self.step_run_curing_process:
                        self.signals.update_statusbar.emit("UV curing is in progress...")
                        status = ui_plc_communication.uv_control_class.write_values(
                            int(ui.excel["UV intensity"]["Curing station"]),
                            int(ui.excel["Curing Time"]["Curing station"]))
                        logger.info(
                            "Writing uv intensity is {} and delay is {}".format(
                                int(ui.excel["UV intensity"]["Curing station"]),
                                int(ui.excel["Curing Time"]["Curing station"])))
                        if status == "Passed":
                            logger.info("Uv values write successful")
                            status = ui_plc_communication.uv_control_class.read_values()
                            if status == "Passed":
                                logger.info("read the uv values")
                            else:
                                logger.error("Error to read the uv values")
                                self.signals.call_MsgBox.emit("Alert", "Error to read the uv values", "Auto_sequence")
                                self.validation_done = False
                                self.overall_result_list["Fixture offset remarks"] = "Error to read the uv values"
                                return "Not Done"
                        else:
                            logger.error("Error in uv write values")
                            self.signals.call_MsgBox.emit("Alert", "Error in uv write values", "Auto_sequence")
                            self.validation_done = False
                            self.overall_result_list["Fixture offset remarks"] = "Error in uv write values"
                            return "Not Done"

                        status = ui_plc_communication.uv_control_class.uv_power_on()
                        if status == "Passed":
                            self.signals.update_statusbar.emit("UV light is ON")
                            logger.info("Uv power on successful")
                            for x in reversed(range(int(ui.excel["Curing Time"]["Curing station"]) + 1)):
                                self.signals.update_statusbar.emit(f"{x} seconds left..")
                                time.sleep(1)
                            self.step_run_curing_process = True
                            self.signals.update_statusbar.emit("Uv curing is completed.")
                        else:
                            logger.error("Error in uv power on")
                            self.signals.call_MsgBox.emit("Alert", "Error in uv power on", "Auto_sequence")
                            self.validation_done = False
                            self.overall_result_list["Fixture offset remarks"] = "Error in uv power on"
                            return "Not Done"

                        self.signals.step_run_btn_enable.emit(True)
                        time.sleep(0.5)
                        while True:
                            if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                                if ui.step_run_btn_clicked:
                                    self.signals.step_run_btn_enable.emit(False)
                                    self.signals.step_run_flag.emit(False)
                                    break

                                if ui.abort_auto_sequence_clicked:
                                    self.validation_done = False
                                    status = self.cure_glue_unloading()
                                    if status == "Done":
                                        pass
                                    else:
                                        self.signals.update_statusbar.emit("Error to unload module.")
                                    self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                    return "Not Done"

                    time.sleep(0.5)
                    if not self.step_run_curing_door_open_reverse:
                        self.signals.update_statusbar.emit("Curing door open is in progress...")
                        status = ui_plc_communication.plc_control_class.uv_door_open()
                        if status == "Passed":
                            self.signals.update_statusbar.emit("Curing door opened.")
                            self.step_run_curing_door_open_reverse = True
                        else:
                            ip_check = self.check_input_manually()
                            if not ip_check:
                                logger.info("User clicked no in actuator movement while step run sequence.")
                                self.validation_done = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User selected No in step run process."
                                return "Not Done"

                        self.signals.step_run_btn_enable.emit(True)
                        time.sleep(0.5)
                        while True:
                            if ui.step_run_btn_clicked or ui.abort_auto_sequence_clicked:
                                if ui.step_run_btn_clicked:
                                    self.signals.step_run_btn_enable.emit(False)
                                    self.signals.step_run_flag.emit(False)
                                    break

                                if ui.abort_auto_sequence_clicked:
                                    self.validation_done = False
                                    status = self.cure_glue_unloading()
                                    if status == "Done":
                                        pass
                                    else:
                                        self.signals.update_statusbar.emit("Error to unload module.")
                                    self.overall_result_list["Fixture offset remarks"] = "User abort the sequence."
                                    return "Not Done"

                    time.sleep(0.5)
                    if not self.step_run_curing_unloading:
                        self.signals.update_statusbar.emit("Y-axis moving to unloading is in progress..")
                        status = self.parallel_x_y(position_x=float(ui.excel["X-Actuator Loading"]["Loading station"]),
                                                   position_y=float(ui.excel["Y-Actuator Loading"]["Loading station"]))
                        if status == "Done":
                            self.signals.update_statusbar.emit("Y-axis moved to unloading.")
                            time.sleep(0.25)
                            self.signals.update_statusbar.emit("Plc init is in progress...")
                            status = ui_plc_communication.plc_control_class.plc_initialize()
                            if status == "Passed":
                                self.signals.update_statusbar.emit("Plc init is completed.")
                                self.signals.update_statusbar.emit("Front door open is in progress...")
                                time.sleep(0.25)
                                self.signals.update_statusbar.emit("Front door open is completed.")
                                status = ui_plc_communication.plc_control_class.front_door_open()
                                if status == "Passed":
                                    self.step_run_curing_unloading = True
                                    return
                                else:
                                    ip_check = self.check_input_manually()
                                    if not ip_check:
                                        logger.info("User clicked no in actuator movement while step run sequence.")
                                        self.validation_done = False
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "User selected No in step run process."
                                        return "Not Done"
                            else:
                                ip_check = self.check_input_manually()
                                if not ip_check:
                                    logger.info("User clicked no in actuator movement while step run sequence.")
                                    self.validation_done = False
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "User selected No in step run process."
                                    return "Not Done"
                        else:
                            ip_check = self.check_input_manually()
                            if not ip_check:
                                logger.info("User clicked no in actuator movement while step run sequence.")
                                self.validation_done = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User selected No in step run process."
                                return "Not Done"

                self.signals.update_statusbar.emit("Y-axis moving to unloading is in progress..")
                status = self.parallel_x_y(position_x=float(ui.excel["X-Actuator Loading"]["Loading station"]),
                                           position_y=float(ui.excel["Y-Actuator Loading"]["Loading station"]))
                if status == "Done":
                    self.signals.update_statusbar.emit("Y-axis moved to unloading.")
                    time.sleep(0.25)
                    self.signals.update_statusbar.emit("Plc init is in progress...")
                    status = ui_plc_communication.plc_control_class.plc_initialize()
                    if status == "Passed":
                        self.signals.update_statusbar.emit("Plc init is completed.")
                        self.signals.update_statusbar.emit("Front door open is in progress...")
                        time.sleep(0.25)
                        self.signals.update_statusbar.emit("Front door open is completed.")
                        status = ui_plc_communication.plc_control_class.front_door_open()
                        if status == "Passed":
                            self.step_run_curing_unloading = True
                            return
                        else:
                            ip_check = self.check_input_manually()
                            if not ip_check:
                                logger.info("User clicked no in actuator movement while step run sequence.")
                                self.validation_done = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User selected No in step run process."
                                return "Not Done"
                    else:
                        ip_check = self.check_input_manually()
                        if not ip_check:
                            logger.info("User clicked no in actuator movement while step run sequence.")
                            self.validation_done = False
                            self.overall_result_list[
                                "Fixture offset remarks"] = "User selected No in step run process."
                            return "Not Done"
                else:
                    ip_check = self.check_input_manually()
                    if not ip_check:
                        logger.info("User clicked no in actuator movement while step run sequence.")
                        self.validation_done = False
                        self.overall_result_list[
                            "Fixture offset remarks"] = "User selected No in step run process."
                        return "Not Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at run function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))
            self.signals.updateProgressVal.emit(0)
            self.cap.release()
            del self.cap
            cv2.destroyAllWindows()
            status = self.unloading()
            if status == "Done":
                pass
            else:
                self.signals.update_statusbar.emit("Error in unloading station.")
            status = self.front_door_close_open(command="open")
            if status == "Passed":
                pass
            status = ui_plc_communication.plc_control_class.tower_light_control(light="Yellow")
            if status != "Passed":
                logger.error("error to set tower light change")
            if self.validation_done:
                self.signals.cycle_result.emit("Passed")
            elif not self.validation_done:
                self.signals.cycle_result.emit("Failed")
            else:
                self.signals.cycle_result.emit("NA")
            self.signals.update_statusbar.emit("Error at run function")
            self.signals.close_graph.emit()
            self.signals.close_MsgBox.emit()
            logger.info("Thread completed")
            self.signals.call_ResetPreview.emit("")
            self.threadpool.releaseThread()
            logger.info("*********Thread Completed!*************")

    def auto_sequence(self):
        """
          This method is used to run the auto sequence.
          param lists: None
          return: None
        """
        try:
            logger.info("*********Thread Started!*************")
            status = self.thread_front_door_tower_light()
            if status == "Passed":
                self.signals.update_station_position.emit(1)
                t_end = time.time() + 15
                while time.time() < t_end:
                    try:
                        if self.camera_connected:
                            break
                    except Exception as e:
                        print(e)
                if self.camera_connected:
                    self.signals.updateProgressVal.emit(10)
                    self.signals.update_statusbar.emit("Camera is connected")
                    status = "Done"
                    if status == "Done":
                        self.signals.updateProgressVal.emit(20)
                        if bool(ui.excel["Displacement Status"]["Displacement sensor"]):
                            self.signals.update_station_position.emit(2)
                            status = self.height_adjustment()
                            if status == "Done":
                                status = self.loading_to_focusing_station(station=ui.setup_type)
                                if status == "Done":
                                    status = self.check_center_offset(station=ui.setup_type)
                                    if status == "Done":
                                        self.signals.update_statusbar.emit('Focus validation is in progress')
                                        self.signals.updateProgressVal.emit(40)
                                        start_now = datetime.datetime.now()
                                        start_time = start_now.strftime("%H:%M:%S")
                                        logger.info("Focusing start time: {}".format(start_time))
                                        self.streaming()
                                        end_now = datetime.datetime.now()
                                        end_time = end_now.strftime("%H:%M:%S")
                                        logger.info("Focusing end time: {}".format(end_time))
                                        diff = end_now - start_now
                                        logger.info("Overall focusing taken time is: {} seconds\n".format(
                                            diff.total_seconds()))
                                        if self.validation_done:
                                            self.overall_result_list["focus_station"] = "Passed"
                                            self.signals.update_statusbar.emit('Focus validation is done')
                                            self.signals.updateProgressVal.emit(60)
                                            self.after_glue_iteration = 0
                                            if bool(ui.excel["Gluing Status"]["Gluing station"]):
                                                status = self.gluing_station()
                                                if status == "Done":
                                                    self.signals.updateProgressVal.emit(70)
                                                    if bool(ui.excel["After glue focus"][ui.setup_type]):
                                                        status = self.go_to_focus_station(station=ui.setup_type)
                                                        if status == "Done":
                                                            self.signals.updateProgressVal.emit(75)
                                                            ui.after_glue_clicked = True
                                                            start_now = datetime.datetime.now()
                                                            start_time = start_now.strftime("%H:%M:%S")
                                                            logger.info("Recheck focus start time: {}".format(
                                                                start_time))
                                                            self.streaming()
                                                            if self.validation_done:
                                                                end_now = datetime.datetime.now()
                                                                end_time = end_now.strftime("%H:%M:%S")
                                                                logger.info("Recheck Focus end time: {}".format(
                                                                    end_time))
                                                                diff = end_now - start_now
                                                                logger.info(
                                                                    "Time taken to reach recheck focus: {} seconds\n".format(
                                                                        diff.total_seconds()))
                                                                ui.after_glue_clicked = False
                                                                if bool(ui.excel["Curing Status"]["Curing station"]):
                                                                    status = self.curing_station()
                                                                    if status == "Done":
                                                                        self.signals.updateProgressVal.emit(80)
                                                                        if bool(ui.excel["After cure focus"][
                                                                                    ui.setup_type]):
                                                                            status = self.go_to_focus_station(
                                                                                station=ui.setup_type)
                                                                            if status == "Done":
                                                                                ui.after_curing_clicked = True
                                                                                start_now = datetime.datetime.now()
                                                                                start_time = start_now.strftime(
                                                                                    "%H:%M:%S")
                                                                                logger.info(
                                                                                    "Recheck focus start time: {}".format(
                                                                                        start_time))
                                                                                self.streaming()
                                                                                if self.validation_done:
                                                                                    end_now = datetime.datetime.now()
                                                                                    end_time = end_now.strftime(
                                                                                        "%H:%M:%S")
                                                                                    logger.info(
                                                                                        "Recheck Focus end time: {}".format(
                                                                                            end_time))
                                                                                    diff = end_now - start_now
                                                                                    logger.info(
                                                                                        "Time taken to reach recheck focus: {} seconds\n".format(
                                                                                            diff.total_seconds()))
                                                                                    self.signals.updateProgressVal.emit(
                                                                                        90)
                                                                                    ui.after_curing_clicked = False
                                                                                    self.signals.updateProgressVal.emit(
                                                                                        100)
                                                                                    status = self.unloading()
                                                                                    if status == "Done":
                                                                                        pass
                                                                                    else:
                                                                                        self.signals.update_statusbar.emit(
                                                                                            "Error in Loading station.")
                                                                                else:
                                                                                    status = self.unloading()
                                                                                    if status == "Done":
                                                                                        pass
                                                                                    else:
                                                                                        self.signals.update_statusbar.emit(
                                                                                            "Error in Loading station.")
                                                                            else:
                                                                                status = self.unloading()
                                                                                if status == "Done":
                                                                                    pass
                                                                                else:
                                                                                    self.signals.update_statusbar.emit(
                                                                                        "Error in Loading station.")
                                                                        else:
                                                                            status = self.unloading()
                                                                            if status == "Done":
                                                                                pass
                                                                            else:
                                                                                self.signals.update_statusbar.emit(
                                                                                    "Error in Loading station.")
                                                                    else:
                                                                        self.overall_result_list[
                                                                            "curing_station"] = "Failed"
                                                                        logger.error(
                                                                            "Curing is not done {}".format(status))
                                                                        status = self.cure_glue_unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                'Error in curing_unloading station')
                                                                else:
                                                                    if bool(ui.excel["After cure focus"][
                                                                                ui.setup_type]):
                                                                        status = self.go_to_focus_station(
                                                                            station=ui.setup_type)
                                                                        if status == "Done":
                                                                            ui.after_curing_clicked = True
                                                                            start_now = datetime.datetime.now()
                                                                            start_time = start_now.strftime("%H:%M:%S")
                                                                            logger.info(
                                                                                "Recheck focus start time: {}".format(
                                                                                    start_time))
                                                                            self.streaming()
                                                                            if self.validation_done:
                                                                                end_now = datetime.datetime.now()
                                                                                end_time = end_now.strftime("%H:%M:%S")
                                                                                logger.info(
                                                                                    "Recheck Focus end time: {}".format(
                                                                                        end_time))
                                                                                diff = end_now - start_now
                                                                                logger.info(
                                                                                    "Time taken to reach recheck focus: {} seconds\n".format(
                                                                                        diff.total_seconds()))
                                                                                self.signals.updateProgressVal.emit(90)
                                                                                ui.after_curing_clicked = False
                                                                                self.signals.updateProgressVal.emit(100)
                                                                                status = self.unloading()
                                                                                if status == "Done":
                                                                                    pass
                                                                                else:
                                                                                    self.signals.update_statusbar.emit(
                                                                                        "Error in Loading station.")
                                                                            else:
                                                                                status = self.unloading()
                                                                                if status == "Done":
                                                                                    pass
                                                                                else:
                                                                                    self.signals.update_statusbar.emit(
                                                                                        "Error in Loading station.")
                                                                        else:
                                                                            status = self.unloading()
                                                                            if status == "Done":
                                                                                pass
                                                                            else:
                                                                                self.signals.update_statusbar.emit(
                                                                                    "Error in Loading station.")
                                                                    else:
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                            else:
                                                                status = self.unloading()
                                                                if status == "Done":
                                                                    pass
                                                                else:
                                                                    self.signals.update_statusbar.emit(
                                                                        "Error in Loading station.")
                                                        else:
                                                            status = self.unloading()
                                                            if status == "Done":
                                                                pass
                                                            else:
                                                                self.signals.update_statusbar.emit(
                                                                    "Error in Loading station.")

                                                    else:
                                                        if bool(ui.excel["Curing Status"]["Curing station"]):
                                                            status = self.curing_station()
                                                            if status == "Done":
                                                                if bool(ui.excel["After cure focus"][ui.setup_type]):
                                                                    self.signals.updateProgressVal.emit(80)
                                                                    status = self.go_to_focus_station(
                                                                        station=ui.setup_type)
                                                                    if status == "Done":
                                                                        ui.after_curing_clicked = True
                                                                        start_now = datetime.datetime.now()
                                                                        start_time = start_now.strftime("%H:%M:%S")
                                                                        logger.info(
                                                                            "Recheck focus start time: {}".format(
                                                                                start_time))
                                                                        self.streaming()
                                                                        if self.validation_done:
                                                                            end_now = datetime.datetime.now()
                                                                            end_time = end_now.strftime("%H:%M:%S")
                                                                            logger.info(
                                                                                "Recheck Focus end time: {}".format(
                                                                                    end_time))
                                                                            diff = end_now - start_now
                                                                            logger.info(
                                                                                "Time taken to reach recheck focus: {} seconds\n".format(
                                                                                    diff.total_seconds()))
                                                                            self.signals.updateProgressVal.emit(90)
                                                                            ui.after_curing_clicked = False
                                                                            self.signals.updateProgressVal.emit(100)
                                                                            status = self.unloading()
                                                                            if status == "Done":
                                                                                pass
                                                                            else:
                                                                                self.signals.update_statusbar.emit(
                                                                                    "Error in Loading station.")
                                                                        else:
                                                                            status = self.unloading()
                                                                            if status == "Done":
                                                                                pass
                                                                            else:
                                                                                self.signals.update_statusbar.emit(
                                                                                    "Error in Loading station.")
                                                                    else:
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            self.signals.updateProgressVal.emit(100)
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                else:
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        self.signals.updateProgressVal.emit(100)
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")
                                                            else:
                                                                self.overall_result_list[
                                                                    "curing_station"] = "Failed"
                                                                logger.error("Curing is not done {}".format(status))
                                                                status = self.cure_glue_unloading()
                                                                if status == "Done":
                                                                    pass
                                                                else:
                                                                    self.signals.update_statusbar.emit(
                                                                        'Error in curing_unloading station')
                                                        else:
                                                            if bool(ui.excel["After cure focus"][ui.setup_type]):
                                                                status = self.go_to_focus_station(station=ui.setup_type)
                                                                if status == "Done":
                                                                    ui.after_curing_clicked = True
                                                                    start_now = datetime.datetime.now()
                                                                    start_time = start_now.strftime("%H:%M:%S")
                                                                    logger.info("Recheck focus start time: {}".format(
                                                                        start_time))
                                                                    self.streaming()
                                                                    if self.validation_done:
                                                                        end_now = datetime.datetime.now()
                                                                        end_time = end_now.strftime("%H:%M:%S")
                                                                        logger.info("Recheck Focus end time: {}".format(
                                                                            end_time))
                                                                        diff = end_now - start_now
                                                                        logger.info(
                                                                            "Time taken to reach recheck focus: {} seconds\n".format(
                                                                                diff.total_seconds()))
                                                                        self.signals.updateProgressVal.emit(90)
                                                                        ui.after_curing_clicked = False
                                                                        self.signals.updateProgressVal.emit(100)
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                    else:
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                else:
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        self.signals.updateProgressVal.emit(100)
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")
                                                            else:
                                                                status = self.unloading()
                                                                if status == "Done":
                                                                    pass
                                                                else:
                                                                    self.signals.update_statusbar.emit(
                                                                        "Error in Loading station.")
                                                else:
                                                    self.overall_result_list["gluing_station"] = "Failed"
                                                    logger.error("Gluing is not done {}".format(status))
                                                    status = ui_plc_communication.modbus_class.read_actuator_current_position(
                                                        1)
                                                    if status > 1950:
                                                        status = self.cure_glue_unloading()
                                                        if status == "Done":
                                                            pass
                                                        else:
                                                            self.signals.update_statusbar.emit(
                                                                'Error in gluing_unloading station')
                                                    else:
                                                        status = self.unloading()
                                                        if status == "Done":
                                                            pass
                                                        else:
                                                            self.signals.update_statusbar.emit(
                                                                "Error in Loading station.")
                                            else:
                                                if bool(ui.excel["After cure focus"][ui.setup_type]):
                                                    status = self.go_to_focus_station(station=ui.setup_type)
                                                    if status == "Done":
                                                        self.signals.updateProgressVal.emit(75)
                                                        ui.after_glue_clicked = True
                                                        start_now = datetime.datetime.now()
                                                        start_time = start_now.strftime("%H:%M:%S")
                                                        logger.info("Recheck focus start time: {}".format(
                                                            start_time))
                                                        self.streaming()
                                                        if self.validation_done:
                                                            end_now = datetime.datetime.now()
                                                            end_time = end_now.strftime("%H:%M:%S")
                                                            logger.info("Recheck Focus end time: {}".format(
                                                                end_time))
                                                            diff = end_now - start_now
                                                            logger.info(
                                                                "Time taken to reach recheck focus: {} seconds\n".format(
                                                                    diff.total_seconds()))
                                                            ui.after_glue_clicked = False
                                                            if bool(ui.excel["Curing Status"]["Curing station"]):
                                                                status = self.curing_station()
                                                                if status == "Done":
                                                                    self.signals.updateProgressVal.emit(80)
                                                                    if bool(ui.excel["After cure focus"][
                                                                                ui.setup_type]):
                                                                        status = self.go_to_focus_station(
                                                                            station=ui.setup_type)
                                                                        if status == "Done":
                                                                            ui.after_curing_clicked = True
                                                                            start_now = datetime.datetime.now()
                                                                            start_time = start_now.strftime("%H:%M:%S")
                                                                            logger.info(
                                                                                "Recheck focus start time: {}".format(
                                                                                    start_time))
                                                                            self.streaming()
                                                                            if self.validation_done:
                                                                                end_now = datetime.datetime.now()
                                                                                end_time = end_now.strftime("%H:%M:%S")
                                                                                logger.info(
                                                                                    "Recheck Focus end time: {}".format(
                                                                                        end_time))
                                                                                diff = end_now - start_now
                                                                                logger.info(
                                                                                    "Time taken to reach recheck focus: {} seconds\n".format(
                                                                                        diff.total_seconds()))
                                                                                self.signals.updateProgressVal.emit(90)
                                                                                ui.after_curing_clicked = False
                                                                                self.signals.updateProgressVal.emit(100)
                                                                                status = self.unloading()
                                                                                if status == "Done":
                                                                                    pass
                                                                                else:
                                                                                    self.signals.update_statusbar.emit(
                                                                                        "Error in Loading station.")
                                                                            else:
                                                                                status = self.unloading()
                                                                                if status == "Done":
                                                                                    pass
                                                                                else:
                                                                                    self.signals.update_statusbar.emit(
                                                                                        "Error in Loading station.")
                                                                        else:
                                                                            status = self.unloading()
                                                                            if status == "Done":
                                                                                pass
                                                                            else:
                                                                                self.signals.update_statusbar.emit(
                                                                                    "Error in Loading station.")
                                                                    else:
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                else:
                                                                    self.overall_result_list[
                                                                        "curing_station"] = "Failed"
                                                                    logger.error("Curing is not done {}".format(status))
                                                                    status = self.cure_glue_unloading()
                                                                    if status == "Done":
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            'Error in curing_unloading station')
                                                            else:
                                                                if bool(ui.excel["After cure focus"][ui.setup_type]):
                                                                    status = self.go_to_focus_station(
                                                                        station=ui.setup_type)
                                                                    if status == "Done":
                                                                        ui.after_curing_clicked = True
                                                                        start_now = datetime.datetime.now()
                                                                        start_time = start_now.strftime("%H:%M:%S")
                                                                        logger.info(
                                                                            "Recheck focus start time: {}".format(
                                                                                start_time))
                                                                        self.streaming()
                                                                        if self.validation_done:
                                                                            end_now = datetime.datetime.now()
                                                                            end_time = end_now.strftime("%H:%M:%S")
                                                                            logger.info(
                                                                                "Recheck Focus end time: {}".format(
                                                                                    end_time))
                                                                            diff = end_now - start_now
                                                                            logger.info(
                                                                                "Time taken to reach recheck focus: {} seconds\n".format(
                                                                                    diff.total_seconds()))
                                                                            self.signals.updateProgressVal.emit(90)
                                                                            ui.after_curing_clicked = False
                                                                            self.signals.updateProgressVal.emit(100)
                                                                            status = self.unloading()
                                                                            if status == "Done":
                                                                                pass
                                                                            else:
                                                                                self.signals.update_statusbar.emit(
                                                                                    "Error in Loading station.")
                                                                        else:
                                                                            status = self.unloading()
                                                                            if status == "Done":
                                                                                pass
                                                                            else:
                                                                                self.signals.update_statusbar.emit(
                                                                                    "Error in Loading station.")
                                                                    else:
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                else:
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")

                                                        else:
                                                            status = self.unloading()
                                                            if status == "Done":
                                                                pass
                                                            else:
                                                                self.signals.update_statusbar.emit(
                                                                    "Error in Loading station.")
                                                    else:
                                                        status = self.unloading()
                                                        if status == "Done":
                                                            pass
                                                        else:
                                                            self.signals.update_statusbar.emit(
                                                                "Error in Loading station.")

                                                else:
                                                    if bool(ui.excel["Curing Status"]["Curing station"]):
                                                        status = self.curing_station()
                                                        if status == "Done":
                                                            if bool(ui.excel["After cure focus"][ui.setup_type]):
                                                                self.signals.updateProgressVal.emit(75)
                                                                status = self.go_to_focus_station(station=ui.setup_type)
                                                                if status == "Done":
                                                                    ui.after_curing_clicked = True
                                                                    start_now = datetime.datetime.now()
                                                                    start_time = start_now.strftime("%H:%M:%S")
                                                                    logger.info("Recheck focus start time: {}".format(
                                                                        start_time))
                                                                    self.streaming()
                                                                    if self.validation_done:
                                                                        end_now = datetime.datetime.now()
                                                                        end_time = end_now.strftime("%H:%M:%S")
                                                                        logger.info("Recheck Focus end time: {}".format(
                                                                            end_time))
                                                                        diff = end_now - start_now
                                                                        logger.info(
                                                                            "Time taken to reach recheck focus: {} seconds\n".format(
                                                                                diff.total_seconds()))
                                                                        self.signals.updateProgressVal.emit(90)
                                                                        ui.after_curing_clicked = False
                                                                        self.signals.updateProgressVal.emit(100)
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                    else:
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                else:
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        self.signals.updateProgressVal.emit(100)
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")
                                                            else:
                                                                status = self.unloading()
                                                                if status == "Done":
                                                                    self.signals.updateProgressVal.emit(100)
                                                                    pass
                                                                else:
                                                                    self.signals.update_statusbar.emit(
                                                                        "Error in Loading station.")
                                                        else:
                                                            self.overall_result_list[
                                                                "curing_station"] = "Failed"
                                                            logger.error("Curing is not done {}".format(status))
                                                            status = self.cure_glue_unloading()
                                                            if status == "Done":
                                                                pass
                                                            else:
                                                                self.signals.update_statusbar.emit(
                                                                    'Error in curing_unloading station')
                                                    else:
                                                        if bool(ui.excel["After cure focus"][ui.setup_type]):
                                                            status = self.go_to_focus_station(station=ui.setup_type)
                                                            if status == "Done":
                                                                ui.after_curing_clicked = True
                                                                start_now = datetime.datetime.now()
                                                                start_time = start_now.strftime("%H:%M:%S")
                                                                logger.info("Recheck focus start time: {}".format(
                                                                    start_time))
                                                                self.streaming()
                                                                if self.validation_done:
                                                                    end_now = datetime.datetime.now()
                                                                    end_time = end_now.strftime("%H:%M:%S")
                                                                    logger.info("Recheck Focus end time: {}".format(
                                                                        end_time))
                                                                    diff = end_now - start_now
                                                                    logger.info(
                                                                        "Time taken to reach recheck focus: {} seconds\n".format(
                                                                            diff.total_seconds()))
                                                                    self.signals.updateProgressVal.emit(90)
                                                                    ui.after_curing_clicked = False
                                                                    self.signals.updateProgressVal.emit(100)
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")
                                                                else:
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")
                                                            else:
                                                                status = self.unloading()
                                                                if status == "Done":
                                                                    pass
                                                                else:
                                                                    self.signals.update_statusbar.emit(
                                                                        "Error in Loading station.")
                                                        else:
                                                            status = self.unloading()
                                                            if status == "Done":
                                                                self.signals.updateProgressVal.emit(100)
                                                                pass
                                                            else:
                                                                self.signals.update_statusbar.emit(
                                                                    "Error in Loading station.")
                                        else:
                                            self.overall_result_list["focus_station"] = "Failed"
                                            status = self.unloading()
                                            if status == "Done":
                                                pass
                                            else:
                                                self.signals.update_statusbar.emit("Error in Loading station.")
                                    else:
                                        status = self.unloading()
                                        if status == "Done":
                                            pass
                                        else:
                                            self.signals.update_statusbar.emit("")
                                else:
                                    self.overall_result_list["focus_station"] = "Failed"
                                    status = self.unloading()
                                    if status == "Done":
                                        pass
                                    else:
                                        self.signals.update_statusbar.emit("Error in Loading station.")
                            else:
                                self.overall_result_list["height_sensor_station"] = "Failed"
                                status = self.unloading()
                                if status == "Done":
                                    pass
                                else:
                                    self.signals.update_statusbar.emit("Error in Loading station.")
                        else:
                            status = self.loading_to_focusing_station(station=ui.setup_type)
                            if status == "Done":
                                self.signals.updateProgressVal.emit(20)
                                status = self.check_center_offset(station=ui.setup_type)
                                if status == "Done":
                                    self.signals.update_statusbar.emit('Focus validation is in progress')
                                    self.signals.updateProgressVal.emit(40)
                                    start_now = datetime.datetime.now()
                                    start_time = start_now.strftime("%H:%M:%S")
                                    logger.info("Focusing start time: {}".format(start_time))
                                    self.streaming()
                                    end_now = datetime.datetime.now()
                                    end_time = end_now.strftime("%H:%M:%S")
                                    logger.info("Focusing end time: {}".format(end_time))
                                    diff = end_now - start_now
                                    logger.info("Overall focusing taken time is: {} seconds\n".format(
                                        diff.total_seconds()))
                                    if self.validation_done:
                                        self.overall_result_list["focus_station"] = "Passed"
                                        self.signals.update_statusbar.emit('Focus validation is done')
                                        self.signals.updateProgressVal.emit(60)
                                        self.after_glue_iteration = 0
                                        if bool(ui.excel["Gluing Status"]["Gluing station"]):
                                            status = self.gluing_station()
                                            if status == "Done":
                                                self.signals.updateProgressVal.emit(70)
                                                if bool(ui.excel["After glue focus"][ui.setup_type]):
                                                    status = self.go_to_focus_station(station=ui.setup_type)
                                                    if status == "Done":
                                                        self.signals.updateProgressVal.emit(75)
                                                        ui.after_glue_clicked = True
                                                        start_now = datetime.datetime.now()
                                                        start_time = start_now.strftime("%H:%M:%S")
                                                        logger.info("Recheck focus start time: {}".format(
                                                            start_time))
                                                        self.streaming()
                                                        if self.validation_done:
                                                            end_now = datetime.datetime.now()
                                                            end_time = end_now.strftime("%H:%M:%S")
                                                            logger.info("Recheck Focus end time: {}".format(
                                                                end_time))
                                                            diff = end_now - start_now
                                                            logger.info(
                                                                "Time taken to reach recheck focus: {} seconds\n".format(
                                                                    diff.total_seconds()))
                                                            ui.after_glue_clicked = False
                                                            if bool(ui.excel["Curing Status"]["Curing station"]):
                                                                status = self.curing_station()
                                                                if status == "Done":
                                                                    self.signals.updateProgressVal.emit(80)
                                                                    if bool(ui.excel["After cure focus"][
                                                                                ui.setup_type]):
                                                                        status = self.go_to_focus_station(
                                                                            station=ui.setup_type)
                                                                        if status == "Done":
                                                                            self.signals.updateProgressVal.emit(90)
                                                                            ui.after_glue_clicked = False
                                                                            ui.after_curing_clicked = True
                                                                            start_now = datetime.datetime.now()
                                                                            start_time = start_now.strftime("%H:%M:%S")
                                                                            logger.info(
                                                                                "Recheck focus start time: {}".format(
                                                                                    start_time))
                                                                            self.streaming()
                                                                            if self.validation_done:
                                                                                end_now = datetime.datetime.now()
                                                                                end_time = end_now.strftime("%H:%M:%S")
                                                                                logger.info(
                                                                                    "Recheck Focus end time: {}".format(
                                                                                        end_time))
                                                                                diff = end_now - start_now
                                                                                logger.info(
                                                                                    "Time taken to reach recheck focus: {} seconds\n".format(
                                                                                        diff.total_seconds()))
                                                                                self.signals.updateProgressVal.emit(100)
                                                                                status = self.unloading()
                                                                                if status == "Done":
                                                                                    pass
                                                                                else:
                                                                                    self.signals.update_statusbar.emit(
                                                                                        "Error in Loading station.")
                                                                            else:
                                                                                status = self.unloading()
                                                                                if status == "Done":
                                                                                    pass
                                                                                else:
                                                                                    self.signals.update_statusbar.emit(
                                                                                        "Error in Loading station.")
                                                                        else:
                                                                            status = self.unloading()
                                                                            if status == "Done":
                                                                                pass
                                                                            else:
                                                                                self.signals.update_statusbar.emit(
                                                                                    "Error in Loading station.")
                                                                    else:
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                else:
                                                                    self.overall_result_list[
                                                                        "curing_station"] = "Failed"
                                                                    logger.error("Curing is not done {}".format(status))
                                                                    status = self.cure_glue_unloading()
                                                                    if status == "Done":
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            'Error in curing_unloading station')
                                                            else:
                                                                if bool(ui.excel["After cure focus"][ui.setup_type]):
                                                                    status = self.go_to_focus_station(
                                                                        station=ui.setup_type)
                                                                    if status == "Done":
                                                                        ui.after_curing_clicked = True
                                                                        start_now = datetime.datetime.now()
                                                                        start_time = start_now.strftime("%H:%M:%S")
                                                                        logger.info(
                                                                            "Recheck focus start time: {}".format(
                                                                                start_time))
                                                                        self.streaming()
                                                                        if self.validation_done:
                                                                            end_now = datetime.datetime.now()
                                                                            end_time = end_now.strftime("%H:%M:%S")
                                                                            logger.info(
                                                                                "Recheck Focus end time: {}".format(
                                                                                    end_time))
                                                                            diff = end_now - start_now
                                                                            logger.info("Time taken to reach recheck "
                                                                                        "focus: {} seconds\n".format(
                                                                                diff.total_seconds()))
                                                                            self.signals.updateProgressVal.emit(90)
                                                                            ui.after_curing_clicked = False
                                                                            self.signals.updateProgressVal.emit(100)
                                                                            status = self.unloading()
                                                                            if status == "Done":
                                                                                pass
                                                                            else:
                                                                                self.signals.update_statusbar.emit(
                                                                                    "Error in Loading station.")
                                                                        else:
                                                                            status = self.unloading()
                                                                            if status == "Done":
                                                                                pass
                                                                            else:
                                                                                self.signals.update_statusbar.emit(
                                                                                    "Error in Loading station.")
                                                                    else:
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                else:
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")
                                                        else:
                                                            status = self.unloading()
                                                            if status == "Done":
                                                                pass
                                                            else:
                                                                self.signals.update_statusbar.emit(
                                                                    "Error in Loading station.")
                                                    else:
                                                        status = self.unloading()
                                                        if status == "Done":
                                                            pass
                                                        else:
                                                            self.signals.update_statusbar.emit(
                                                                "Error in Loading station.")
                                                else:
                                                    if bool(ui.excel["Curing Status"]["Curing station"]):
                                                        status = self.curing_station()
                                                        if status == "Done":
                                                            self.signals.updateProgressVal.emit(80)
                                                            if bool(ui.excel["After cure focus"][ui.setup_type]):
                                                                status = self.go_to_focus_station(station=ui.setup_type)
                                                                if status == "Done":
                                                                    self.signals.updateProgressVal.emit(90)
                                                                    ui.after_glue_clicked = False
                                                                    ui.after_curing_clicked = True
                                                                    start_now = datetime.datetime.now()
                                                                    start_time = start_now.strftime("%H:%M:%S")
                                                                    logger.info("Recheck focus start time: {}".format(
                                                                        start_time))
                                                                    self.streaming()
                                                                    if self.validation_done:
                                                                        end_now = datetime.datetime.now()
                                                                        end_time = end_now.strftime("%H:%M:%S")
                                                                        logger.info("Recheck Focus end time: {}".format(
                                                                            end_time))
                                                                        diff = end_now - start_now
                                                                        logger.info(
                                                                            "Time taken to reach recheck "
                                                                            "focus: {} seconds\n".format(
                                                                                diff.total_seconds()))
                                                                        self.signals.updateProgressVal.emit(100)
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                    else:
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                else:
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")
                                                            else:
                                                                status = self.unloading()
                                                                if status == "Done":
                                                                    pass
                                                                else:
                                                                    self.signals.update_statusbar.emit(
                                                                        "Error in Loading station.")
                                                        else:
                                                            self.overall_result_list[
                                                                "curing_station"] = "Failed"
                                                            logger.error("Curing is not done {}".format(status))
                                                            status = self.cure_glue_unloading()
                                                            if status == "Done":
                                                                pass
                                                            else:
                                                                self.signals.update_statusbar.emit(
                                                                    'Error in curing_unloading station')
                                                    else:
                                                        if bool(ui.excel["After cure focus"][ui.setup_type]):
                                                            status = self.go_to_focus_station(station=ui.setup_type)
                                                            if status == "Done":
                                                                ui.after_curing_clicked = True
                                                                start_now = datetime.datetime.now()
                                                                start_time = start_now.strftime("%H:%M:%S")
                                                                logger.info("Recheck focus start time: {}".format(
                                                                    start_time))
                                                                self.streaming()
                                                                if self.validation_done:
                                                                    end_now = datetime.datetime.now()
                                                                    end_time = end_now.strftime("%H:%M:%S")
                                                                    logger.info("Recheck Focus end time: {}".format(
                                                                        end_time))
                                                                    diff = end_now - start_now
                                                                    logger.info(
                                                                        "Time taken to reach "
                                                                        "recheck focus: {} seconds\n".format(
                                                                            diff.total_seconds()))
                                                                    self.signals.updateProgressVal.emit(90)
                                                                    ui.after_curing_clicked = False
                                                                    self.signals.updateProgressVal.emit(100)
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")
                                                                else:
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")
                                                            else:
                                                                status = self.unloading()
                                                                if status == "Done":
                                                                    pass
                                                                else:
                                                                    self.signals.update_statusbar.emit(
                                                                        "Error in Loading station.")
                                                        else:
                                                            status = self.unloading()
                                                            if status == "Done":
                                                                pass
                                                            else:
                                                                self.signals.update_statusbar.emit(
                                                                    "Error in Loading station.")

                                            else:
                                                self.overall_result_list["gluing_station"] = "Failed"
                                                logger.error("Gluing is not done {}".format(status))
                                                status = ui_plc_communication.modbus_class.read_actuator_current_position(
                                                    1)
                                                if status > 1950:
                                                    status = self.cure_glue_unloading()
                                                    if status == "Done":
                                                        pass
                                                    else:
                                                        self.signals.update_statusbar.emit(
                                                            'Error in gluing_unloading station')
                                                else:
                                                    status = self.unloading()
                                                    if status == "Done":
                                                        pass
                                                    else:
                                                        self.signals.update_statusbar.emit(
                                                            "Error in Loading station.")
                                        else:
                                            if bool(ui.excel["After glue focus"][ui.setup_type]):
                                                status = self.go_to_focus_station(station=ui.setup_type)
                                                if status == "Done":
                                                    self.signals.updateProgressVal.emit(75)
                                                    ui.after_glue_clicked = True
                                                    start_now = datetime.datetime.now()
                                                    start_time = start_now.strftime("%H:%M:%S")
                                                    logger.info("Recheck focus start time: {}".format(
                                                        start_time))
                                                    self.streaming()
                                                    if self.validation_done:
                                                        end_now = datetime.datetime.now()
                                                        end_time = end_now.strftime("%H:%M:%S")
                                                        logger.info("Recheck Focus end time: {}".format(
                                                            end_time))
                                                        diff = end_now - start_now
                                                        logger.info(
                                                            "Time taken to reach recheck focus: {} seconds\n".format(
                                                                diff.total_seconds()))
                                                        ui.after_glue_clicked = False
                                                        if bool(ui.excel["Curing Status"]["Curing station"]):
                                                            status = self.curing_station()
                                                            if status == "Done":
                                                                self.signals.updateProgressVal.emit(80)
                                                                if bool(ui.excel["After cure focus"][ui.setup_type]):
                                                                    status = self.go_to_focus_station(
                                                                        station=ui.setup_type)
                                                                    if status == "Done":
                                                                        ui.after_curing_clicked = True
                                                                        start_now = datetime.datetime.now()
                                                                        start_time = start_now.strftime("%H:%M:%S")
                                                                        logger.info(
                                                                            "Recheck focus start time: {}".format(
                                                                                start_time))
                                                                        self.streaming()
                                                                        if self.validation_done:
                                                                            end_now = datetime.datetime.now()
                                                                            end_time = end_now.strftime("%H:%M:%S")
                                                                            logger.info(
                                                                                "Recheck Focus end time: {}".format(
                                                                                    end_time))
                                                                            diff = end_now - start_now
                                                                            logger.info(
                                                                                "Time taken to reach "
                                                                                "recheck focus: {} seconds\n".format(
                                                                                    diff.total_seconds()))
                                                                            self.signals.updateProgressVal.emit(90)
                                                                            ui.after_curing_clicked = False
                                                                            self.signals.updateProgressVal.emit(100)
                                                                            status = self.unloading()
                                                                            if status == "Done":
                                                                                pass
                                                                            else:
                                                                                self.signals.update_statusbar.emit(
                                                                                    "Error in Loading station.")
                                                                        else:
                                                                            status = self.unloading()
                                                                            if status == "Done":
                                                                                pass
                                                                            else:
                                                                                self.signals.update_statusbar.emit(
                                                                                    "Error in Loading station.")
                                                                    else:
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                else:
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        self.signals.updateProgressVal.emit(100)
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")
                                                            else:
                                                                self.overall_result_list[
                                                                    "curing_station"] = "Failed"
                                                                logger.error("Curing is not done {}".format(status))
                                                                status = self.cure_glue_unloading()
                                                                if status == "Done":
                                                                    pass
                                                                else:
                                                                    self.signals.update_statusbar.emit(
                                                                        'Error in curing_unloading station')
                                                        else:
                                                            if bool(ui.excel["After cure focus"][ui.setup_type]):
                                                                status = self.go_to_focus_station(
                                                                    station=ui.setup_type)
                                                                if status == "Done":
                                                                    ui.after_curing_clicked = True
                                                                    start_now = datetime.datetime.now()
                                                                    start_time = start_now.strftime("%H:%M:%S")
                                                                    logger.info("Recheck focus start time: {}".format(
                                                                        start_time))
                                                                    self.streaming()
                                                                    if self.validation_done:
                                                                        end_now = datetime.datetime.now()
                                                                        end_time = end_now.strftime("%H:%M:%S")
                                                                        logger.info("Recheck Focus end time: {}".format(
                                                                            end_time))
                                                                        diff = end_now - start_now
                                                                        logger.info(
                                                                            "Time taken to reach "
                                                                            "recheck focus: {} seconds\n".format(
                                                                                diff.total_seconds()))
                                                                        self.signals.updateProgressVal.emit(90)
                                                                        ui.after_curing_clicked = False
                                                                        self.signals.updateProgressVal.emit(100)
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                    else:
                                                                        status = self.unloading()
                                                                        if status == "Done":
                                                                            pass
                                                                        else:
                                                                            self.signals.update_statusbar.emit(
                                                                                "Error in Loading station.")
                                                                else:
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")
                                                            else:
                                                                status = self.unloading()
                                                                if status == "Done":
                                                                    pass
                                                                else:
                                                                    self.signals.update_statusbar.emit(
                                                                        "Error in Loading station.")

                                                    else:
                                                        status = self.unloading()
                                                        if status == "Done":
                                                            pass
                                                        else:
                                                            self.signals.update_statusbar.emit(
                                                                "Error in Loading station.")
                                                else:
                                                    status = self.unloading()
                                                    if status == "Done":
                                                        pass
                                                    else:
                                                        self.signals.update_statusbar.emit(
                                                            "Error in Loading station.")
                                            else:
                                                if bool(ui.excel["Curing Status"]["Curing station"]):
                                                    status = self.curing_station()
                                                    if status == "Done":
                                                        if bool(ui.excel["After cure focus"][ui.setup_type]):
                                                            status = self.go_to_focus_station(station=ui.setup_type)
                                                            if status == "Done":
                                                                ui.after_curing_clicked = True
                                                                start_now = datetime.datetime.now()
                                                                start_time = start_now.strftime("%H:%M:%S")
                                                                logger.info("Recheck focus start time: {}".format(
                                                                    start_time))
                                                                self.streaming()
                                                                if self.validation_done:
                                                                    end_now = datetime.datetime.now()
                                                                    end_time = end_now.strftime("%H:%M:%S")
                                                                    logger.info("Recheck Focus end time: {}".format(
                                                                        end_time))
                                                                    diff = end_now - start_now
                                                                    logger.info(
                                                                        "Time taken to reach "
                                                                        "recheck focus: {} seconds\n".format(
                                                                            diff.total_seconds()))
                                                                    self.signals.updateProgressVal.emit(90)
                                                                    ui.after_curing_clicked = False
                                                                    self.signals.updateProgressVal.emit(100)
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")
                                                                else:
                                                                    status = self.unloading()
                                                                    if status == "Done":
                                                                        pass
                                                                    else:
                                                                        self.signals.update_statusbar.emit(
                                                                            "Error in Loading station.")
                                                            else:
                                                                status = self.unloading()
                                                                if status == "Done":
                                                                    self.signals.updateProgressVal.emit(100)
                                                                    pass
                                                                else:
                                                                    self.signals.update_statusbar.emit(
                                                                        "Error in Loading station.")
                                                        else:
                                                            status = self.unloading()
                                                            if status == "Done":
                                                                pass
                                                            else:
                                                                self.signals.update_statusbar.emit(
                                                                    "Error in Loading station.")
                                                    else:
                                                        self.overall_result_list[
                                                            "curing_station"] = "Failed"
                                                        logger.error("Curing is not done {}".format(status))
                                                        status = self.cure_glue_unloading()
                                                        if status == "Done":
                                                            pass
                                                        else:
                                                            self.signals.update_statusbar.emit(
                                                                'Error in curing_unloading station')
                                                else:
                                                    if bool(ui.excel["After cure focus"][ui.setup_type]):
                                                        status = self.go_to_focus_station(station=ui.setup_type)
                                                        if status == "Done":
                                                            ui.after_curing_clicked = True
                                                            start_now = datetime.datetime.now()
                                                            start_time = start_now.strftime("%H:%M:%S")
                                                            logger.info("Recheck focus start time: {}".format(
                                                                start_time))
                                                            self.streaming()
                                                            if self.validation_done:
                                                                end_now = datetime.datetime.now()
                                                                end_time = end_now.strftime("%H:%M:%S")
                                                                logger.info("Recheck Focus end time: {}".format(
                                                                    end_time))
                                                                diff = end_now - start_now
                                                                logger.info(
                                                                    "Time taken to reach "
                                                                    "recheck focus: {} seconds\n".format(
                                                                        diff.total_seconds()))
                                                                self.signals.updateProgressVal.emit(90)
                                                                ui.after_curing_clicked = False
                                                                self.signals.updateProgressVal.emit(100)
                                                                status = self.unloading()
                                                                if status == "Done":
                                                                    pass
                                                                else:
                                                                    self.signals.update_statusbar.emit(
                                                                        "Error in Loading station.")
                                                            else:
                                                                status = self.unloading()
                                                                if status == "Done":
                                                                    pass
                                                                else:
                                                                    self.signals.update_statusbar.emit(
                                                                        "Error in Loading station.")
                                                        else:
                                                            status = self.unloading()
                                                            if status == "Done":
                                                                pass
                                                            else:
                                                                self.signals.update_statusbar.emit(
                                                                    "Error in Loading station.")
                                                    else:
                                                        status = self.unloading()
                                                        if status == "Done":
                                                            pass
                                                        else:
                                                            self.signals.update_statusbar.emit(
                                                                "Error in Loading station.")
                                    else:
                                        self.overall_result_list["focus_station"] = "Failed"
                                        status = self.unloading()
                                        if status == "Done":
                                            pass
                                        else:
                                            self.signals.update_statusbar.emit("Error in Un loading station.")

                                else:
                                    status = self.unloading()
                                    if status == "Done":
                                        pass
                                    else:
                                        self.signals.update_statusbar.emit("")
                            else:
                                self.overall_result_list["focus_station"] = "Failed"
                                status = self.unloading()
                                if status == "Done":
                                    pass
                                else:
                                    self.signals.update_statusbar.emit("Error in Loading station.")
                    else:
                        self.overall_result_list["loading_station"] = "Failed"
                        status = self.unloading()
                        if status == "Done":
                            pass
                        else:
                            self.signals.update_statusbar.emit("Error in Loading station.")

                else:
                    status = self.unloading()
                    if status == "Done":
                        pass
                    else:
                        self.signals.update_statusbar.emit("Error in Loading station.")
                        logger.error("Error in Front door close: {}".format(status))
                    self.signals.update_statusbar.emit("Camera is not connected")

            else:
                status = self.front_door_close_open(command="open")
                if status == "Passed":
                    self.signals.update_statusbar.emit("Front door open failed.")
                    self.signals.cycle_result.emit("Failed")
                    self.signals.close_graph.emit()
                    self.signals.close_MsgBox.emit()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at auto sequence function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))
            self.signals.updateProgressVal.emit(0)
            self.cap.release()
            del self.cap
            cv2.destroyAllWindows()
            status = self.unloading()
            if status == "Done":
                pass
            else:
                self.signals.update_statusbar.emit("Error in unloading station.")
            status = self.front_door_close_open(command="open")
            if status == "Passed":
                pass
            status = ui_plc_communication.plc_control_class.tower_light_control(light="Yellow")
            if status != "Passed":
                logger.error("error to set tower light change")
            if self.validation_done:
                self.signals.cycle_result.emit("Passed")
            elif not self.validation_done:
                self.signals.cycle_result.emit("Failed")
            else:
                self.signals.cycle_result.emit("NA")
            self.signals.update_statusbar.emit("Error at run function")
            self.signals.close_graph.emit()
            self.signals.close_MsgBox.emit()
            logger.info("Thread completed")
            self.signals.call_ResetPreview.emit("")
            self.threadpool.releaseThread()
            logger.info("*********Thread Completed!*************")

    def plc_thread(self, port_option="Port 2"):
        try:
            """
              This method is used to start the thread for ip status.
              param lists: None
              return: None
            """
            self.start_ip_check = True
            self.t3 = threading.Thread(target=self.check_input, args=(port_option,))
            self.t3.start()

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at plc_thread function : {}|{}|{}|{}".format(exc_type, func_name,
                                                                             exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at plc thread func"
            return "Not Done"

    def loading_to_focusing_station(self, station="Relay station"):
        try:
            """
              This method is used to parallel movement in auto sequence.
              param lists: None
              return: None
            """
            start_now = datetime.datetime.now()
            start_time = start_now.strftime("%H:%M:%S")
            logger.info("loading to focus station start time: {}".format(start_time))
            count = 0
            while count < 1:
                t2 = threading.Thread(target=self.loading_station)
                t3 = threading.Thread(target=self.relay_z_movement)
                t4 = threading.Thread(target=self.set_relay_lux, args=(station,))
                t5 = threading.Thread(target=self.gluing_z_movement)
                t7 = threading.Thread(target=self.curing_z_movement)
                t8 = threading.Thread(target=self.parallel_x_y,
                                      args=(ui.focus_station_x_value, ui.focus_station_y_value))
                t2.start()
                t3.start()
                t4.start()
                t5.start()
                t7.start()
                t8.start()
                t2.join()
                t3.join()
                t4.join()
                t5.join()
                t7.join()
                t8.join()
                logger.debug(f"Thread status for loading station: {self.loading_station_status}")
                logger.debug(f"Thread status for Relay Z: {self.relay_z_movement_status}")
                logger.debug(f"Thread status for Gluing Z: {self.gluing_z_movement_status}")
                logger.debug(f"Thread status for lux set: {self.set_lux_status}")
                logger.debug(f"Thread status for Curing Z: {self.curing_z_movement_status}")
                logger.debug(f"Thread status for Parallel x and Y: {self.focus_station_status}")

                if ui.abort_auto_sequence_clicked:
                    self.validation_done = False
                    ui.validation_clicked = False
                    self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                         "abort button."
                    gc.collect()
                    return "Not Done"

                if self.loading_station_status == "Done" and self.relay_z_movement_status == "Done" and \
                        self.gluing_z_movement_status == "Done" and self.set_lux_status == "Done" and \
                        self.curing_z_movement_status == "Done" and self.focus_station_status == "Done":
                    self.start_ip_check = False
                    end_now = datetime.datetime.now()
                    end_time = end_now.strftime("%H:%M:%S")
                    logger.info("loading to focus station end time: {}".format(end_time))
                    return "Done"

                count += 1
                time.sleep(0.15)
                check = self.check_input_manually()
                self.loading_station_status = ""
                self.gluing_y_movement_status = ""
                self.curing_door_open_status = ""
                self.relay_z_movement_status = ""
                self.gluing_z_movement_status = ""
                self.set_lux_status = ""
                self.curing_z_movement_status = ""
                self.focus_station_status = ""
                if not check:
                    logger.info("User clicked no in thread loading function")
                    self.validation_done = False
                    self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence " \
                                                                         "in focus station"
                    return "Not Done"
                else:
                    status = ui_plc_communication.plc_control_class.plc_initialize()
                    if status == "Passed":
                        time.sleep(0.25)
                    else:
                        self.validation_done = False
                        self.overall_result_list["Fixture offset remarks"] = "Plc init failed in loading station"
                        return "Not Done"

            else:
                self.start_ip_check = False
                if self.loading_station_status != "Done":
                    logger.error("loading station failed.")
                    self.validation_done = False
                    self.overall_result_list["Fixture offset remarks"] = "Loading station failed"
                    return "Loading station failed"
                if self.focus_station_status != "Done":
                    if ui_plc_communication.x_moved != "Passed":
                        logger.error("X-axis movement failed.")
                        self.validation_done = False
                        self.overall_result_list["Fixture offset remarks"] = "X-axis movement failed"
                        return "X-axis movement failed"
                    if ui_plc_communication.y_moved != "Passed":
                        logger.error("Y-axis movement failed.")
                        self.validation_done = False
                        self.overall_result_list["Fixture offset remarks"] = "Y-axis movement failed"
                        return "Y-axis movement failed"
                if self.relay_z_movement_status != "Done":
                    logger.error("relay Z-axis movement failed.")
                    self.validation_done = False
                    self.overall_result_list["Fixture offset remarks"] = "Relay Z-axis movement failed"
                    return "Relay Z-axis movement failed"
                if self.gluing_z_movement_status != "Done":
                    logger.error("gluing Z-axis movement failed.")
                    self.validation_done = False
                    self.overall_result_list["Fixture offset remarks"] = "Gluing Z-axis movement failed"
                    return "Gluing Z-axis movement failed"
                if self.gluing_y_movement_status != "Done":
                    logger.error("gluing Y-axis movement failed.")
                    self.validation_done = False
                    self.overall_result_list["Fixture offset remarks"] = "Gluing Y-axis movement failed"
                    return "Gluing Y-axis movement failed"
                if self.set_lux_status != "Done":
                    logger.error("Failed to set lux value")
                    self.validation_done = False
                    self.overall_result_list["Fixture offset remarks"] = "Failed to set lux value"
                    return "Failed to set lux value"
                if self.curing_z_movement_status != "Done":
                    logger.error("curing Z-axis movement failed.")
                    self.validation_done = False
                    self.overall_result_list["Fixture offset remarks"] = "Curing Z-axis movement failed"
                    return "Curing Z-axis movement failed"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at loading_to_focusing_station function : {}|{}|{}|{}".format(exc_type, func_name,
                                                                                     exc_tb.tb_lineno,
                                                                                     e))
            self.overall_result_list["Fixture offset remarks"] = "Error at thread loading func"
            return "Not Done"

    def thread_front_door_tower_light(self):
        try:
            """
              This method is used to parallel access for front door and tower light.
              param lists: None
              return: None
            """
            self.start_ip_check = False
            t1 = threading.Thread(target=ui_plc_communication.tower_light_thread, args=("Port 1", "Green"))
            t2 = threading.Thread(target=self.front_door_close_open, args=("close",))
            t3 = threading.Thread(target=self.connect_device)
            t1.start()
            t2.start()
            t3.start()
            t1.join()
            t2.join()
            if ui_plc_communication.towerlight_status == "Passed" and self.front_door_status == "Passed":
                return "Passed"
            else:
                if ui_plc_communication.towerlight_status != "Passed":
                    logger.error("error to set tower light change")
                    return "Passed"

                if self.front_door_status != "Passed":
                    logger.error("Front door open failed.")
                    return "Front door close failed"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at thread_front_door_tower_light function : {}|{}|{}|{}".format(exc_type, func_name,
                                                                                       exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at door&tower light func"
            return "Not Done"

    def plc_init_func(self):
        try:
            """
              This method is used to initialize the plc
              param lists: None
              return: None
            """
            status = ui_plc_communication.plc_control_class.plc_initialize()
            if status == "Passed":
                self.plc_init_status = "Done"
                return "Done"
            else:
                self.plc_init_status = "Not Done"
                return "Not Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at plc_init_func function : {}|{}|{}|{}".format(exc_type, func_name,
                                                                       exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at plc_init_status func"
            return "Not Done"

    def front_door_close_open(self, command="close"):
        try:
            """
              This method is used to open or close the front door based on argument type.
              param lists: command is str
              return: None
            """
            count = 0
            while count < 2:
                if command == "close":
                    status = ui_plc_communication.plc_control_class.front_door_close()
                    if status == "Passed" or ui.bypass_option["Front door close"]:
                        self.front_door_status = "Passed"
                        return "Passed"
                    else:
                        count += 1
                        time.sleep(0.15)
                        logger.error("Error in front door {}: {}".format(command, status))
                else:
                    status = ui_plc_communication.plc_control_class.front_door_open()
                    if status == "Passed" or ui.bypass_option["Front door open"]:
                        self.front_door_status = "Passed"
                        return "Passed"
                    else:
                        count += 1
                        time.sleep(0.15)
                        logger.error("Error in front door {}: {}".format(command, status))
            else:
                self.signals.update_statusbar.emit("Error occurred in PLC")
                self.front_door_status = "Not Done"
                return self.front_door_status

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at front door open close function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno,
                                                                               e))
            self.overall_result_list["Fixture offset remarks"] = "Error at front door func"
            return "Not Done"

    def check_input_manually(self, port_option="Port 2"):
        try:
            """
              This method is used to check the ip status.
              param lists: port_option is str, which port to access
              return: None
            """
            while True:
                status_input = self.verify_input_status(port=port_option)
                if status_input == "Sequence abort":
                    self.validation_done = False
                    ui.validation_clicked = False
                    gc.collect()
                    return False

                elif status_input == "Done":
                    return True

                elif status_input != "Done" and status_input != "Unable to read input status":
                    catch_error = self.catch_and_clear_error(status=status_input)
                    if catch_error == "Not Done":
                        return False
                    elif catch_error == "Done":
                        time.sleep(1)
                    else:
                        return False

                elif status_input == "Unable to read input status":
                    time.sleep(1)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at check_input_manually function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno,
                                                                              e))
            self.overall_result_list["Fixture offset remarks"] = "Error at input status"
            return "Not Done"

    def check_input(self, port_option):
        try:
            """
              This method is used to check the ip status.
              param lists: port_option is str, which port to access
              return: None
            """
            while self.start_ip_check:
                self.status_input = self.verify_input_status(port=port_option)
                if self.status_input == "Done":
                    self.ip_status = True
                    time.sleep(1)

                elif self.status_input != "Done" and self.status_input != "Unable to read input status":
                    self.start_ip_check = False
                    self.ip_status = False

                elif self.status_input == "Unable to read input status":
                    time.sleep(1)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at check_input function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at check ip func"
            return "Not Done"

    def loading_station(self):
        try:
            """
              This method is used to slider, gripper and gluing y movement.
              param lists: None
              return: None
            """
            if self.loading_station_status == "" or self.loading_station_status == "Not Done":
                self.start_ip_check = False
                start_now = datetime.datetime.now()
                start_time = start_now.strftime("%H:%M:%S")
                logger.info("Loading station start time: {}".format(start_time))
                status = ui_plc_communication.plc_control_class.slider(port_number="Port 2",
                                                                       slider=float(
                                                                           ui.excel["Slider"]["Loading station"]))
                if status == "Passed":
                    pass
                else:
                    self.loading_station_status = "Not done"
                    return

                self.start_ip_check = False
                status = ui_plc_communication.plc_control_class.gripper(
                    gripper=float(ui.excel["Gripper"]["Loading station"]))
                if status == "Passed":
                    self.signals.update_statusbar.emit("Slider and Gripper moved")
                    self.overall_result_list["loading_station"] = "Passed"
                else:
                    self.loading_station_status = "Not done"
                    return

                time.sleep(0.15)
                if (self.gluing_y_movement_status == "" or self.gluing_y_movement_status == "Not Done" or
                        self.curing_door_open_status == "" or self.curing_door_open_status == "Not Done"):
                    t1 = threading.Thread(target=self.gluing_y_movement)
                    t2 = threading.Thread(target=self.uv_door_open_command)
                    t1.start()
                    t2.start()
                    t1.join()
                    t2.join()
                    if self.gluing_y_movement_status == "Done" and self.curing_door_open_status == "Done":
                        self.loading_station_status = "Done"
                        end_now = datetime.datetime.now()
                        end_time = end_now.strftime("%H:%M:%S")
                        logger.info("Loading station end time: {}".format(end_time))
                        diff = end_now - start_now
                        logger.info("Overall loading station taken time is: {} seconds\n".format(diff.total_seconds()))
                        return "Done"

                    else:
                        self.loading_station_status = "Done"
                        return "Done"
                else:
                    self.gluing_y_movement_status = "Done"
                    return "Done"
            else:
                self.loading_station_status = "Done"
                return "Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at loading_station function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at loading func"
            return "Not Done"

    def gluing_y_movement(self):
        """
          This method is used to gluing y movement.
          param lists: None
          return: None
        """
        if bool(ui.excel["Gluing Status"]["Gluing station"]):
            status = ui_plc_communication.plc_control_class.glue_manual_move_recipe(y_manual=20)
            if status == "Passed":
                self.gluing_y_movement_status = "Done"
                self.signals.update_statusbar.emit('gluing y moved.')
                return "Done"
            else:
                self.emergency_pressed = True
                self.signals.update_statusbar.emit('Gluing Y movement failed.')
                self.gluing_y_movement_status = "Not Done"
                return "Done"
        else:
            self.gluing_y_movement_status = "Done"
            return "Done"

    def uv_door_open_command(self):
        try:
            """
              This method is used to uv door open.
              param lists: None
              return: None
            """
            if bool(ui.excel["Curing Status"]["Curing station"]):
                status = ui_plc_communication.plc_control_class.uv_door_open()
                if status == "Passed":
                    self.curing_door_open_status = "Done"
                    logger.info('UV door opened.')
                    return "Done"
                else:
                    self.curing_door_open_status = "Not Done"
                    logger.info('Failed to UV door open.')
                    return "Not Done"
            else:
                self.curing_door_open_status = "Done"
                return "Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at uv_door_open_command function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at uv_door_open_command func"
            return "Not Done"

    def check_center_offset(self, station="Relay station", validation='before'):
        """
          This method is used to correct the fixture using offset calculation.
          param lists: station and validation is str
          return: None
        """
        time.sleep(0.15)
        check = self.check_input_manually()
        if not check:
            logger.info("User clicked no in offset correction")
            self.validation_done = False
            self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence in offset correction"
            return "Not Done"
        self.list_dx = []
        self.list_dy = []
        try:
            if ui.excel["Fixture offset"][station]:
                start_now = datetime.datetime.now()
                start_time = start_now.strftime("%H:%M:%S")
                logger.info("fixture offset validating start time: {}".format(start_time))
                gr_fr_rec = 0
                iteration_count = 0
                null_offset = 0
                ret_false = 0
                cap_failed = 0
                j = 0
                if station == "Relay station":
                    x_actuator = "X-Actuator Relay"
                    y_actuator = "Y-Actuator Relay"
                else:
                    x_actuator = "X-Actuator Collimator"
                    y_actuator = "Y-Actuator Collimator"
                if validation == 'before':
                    ui.excel[y_actuator][station] = ui.focus_station_y_value
                    ui.excel[x_actuator][station] = ui.focus_station_x_value
                for i in range(2):
                    _, __ = self.cap.read()

                while True:
                    if ui.abort_auto_sequence_clicked:
                        self.validation_done = False
                        self.start_ip_check = False
                        ui.validation_clicked = False
                        self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                             "abort button."
                        gc.collect()
                        return "Not Done"

                    if self.cap.isOpened():
                        ret, frame = self.cap.read()
                        if ret:
                            if np.sum(frame) != 0:
                                if self.format_type == "UYVY":
                                    frame = cv2.cvtColor(frame, cv2.COLOR_YUV2BGR_UYVY)

                                if self.format_type == "YUY2":
                                    frame = cv2.cvtColor(frame, cv2.COLOR_YUV2BGR_YUY2)

                                elif self.format_type == 'Y8':
                                    if ui.mtf_excel["Raw FW"].split(",")[1] == "Monochrome":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)

                                    elif ui.mtf_excel["Raw FW"].split(",")[1] == 'No':
                                        green_only = np.zeros((frame.shape[0] // 2, frame.shape[1] // 2),
                                                              dtype=np.uint8)
                                        for y in range(frame.shape[0]):
                                            if y % 2 == 0:
                                                green_only[y // 2, :] = frame[y, 1:][::2]

                                        frame = cv2.cvtColor(green_only, cv2.COLOR_GRAY2BGR)
                                        del green_only

                                    elif ui.mtf_excel["Raw FW"].split(",")[1] == "RG":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)

                                    elif ui.mtf_excel["Raw FW"].split(",")[1] == "BG":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)

                                    elif ui.mtf_excel["Raw FW"].split(",")[1] == "GR":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)

                                    elif ui.mtf_excel["Raw FW"].split(",")[1] == "GB":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)

                                elif self.format_type == 'Y16':
                                    frame = cv2.convertScaleAbs(frame, 0.000000065)

                                elif self.format_type == "Y12":
                                    raw_bytes = frame.tobytes()
                                    filtered_bytes = np.frombuffer(raw_bytes, dtype=np.uint8)
                                    filtered_bytes = np.reshape(filtered_bytes, (-1, 3))
                                    filtered_bytes = np.delete(filtered_bytes, 2, 1)
                                    filtered_bytes = np.reshape(filtered_bytes, -1)
                                    y8_frame = np.zeros(shape=(int(ui.resolution[1]), int(ui.resolution[0])),
                                                        dtype=np.uint8)
                                    m = 0
                                    for i in range(0, int(ui.resolution[1])):
                                        y8_frame[i, :] = filtered_bytes[m:m + int(ui.resolution[0])]
                                        m += int(ui.resolution[0])

                                    if ui.mtf_excel["Raw FW"].split(",")[1] == "Monochrome":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_GRAY2BGR)

                                    elif ui.mtf_excel["Raw FW"].split(",")[1] == 'No':
                                        green_only = np.zeros((y8_frame.shape[0] // 2, y8_frame.shape[1] // 2),
                                                              dtype=np.uint8)
                                        for y in range(y8_frame.shape[0]):
                                            if y % 2 == 0:
                                                green_only[y // 2, :] = y8_frame[y, 1:][::2]

                                        frame = cv2.cvtColor(green_only, cv2.COLOR_GRAY2BGR)
                                        del green_only

                                    elif ui.mtf_excel["Raw FW"].split(",")[1] == "RG":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_GRAY2BGR)

                                    elif ui.mtf_excel["Raw FW"].split(",")[1] == "BG":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_GRAY2BGR)

                                    elif ui.mtf_excel["Raw FW"].split(",")[1] == "GR":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_GRAY2BGR)

                                    elif ui.mtf_excel["Raw FW"].split(",")[1] == "GB":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_GRAY2BGR)

                                    del y8_frame
                                    del filtered_bytes

                                if frame is not None:
                                    offset_image, dx, dy = self.lens_offset.validate_lens_offset(image=frame,
                                                                                                 roi_width=500)
                                    logger.debug(f"The current offset dx: {dx} and dy: {dy}")
                                    if dx == "NA" and dy == "NA":
                                        null_offset += 1
                                        time.sleep(1)
                                        if null_offset == 10:
                                            self.signals.call_MsgBox.emit("Alert!",
                                                                          "Unable to detect the SFR reg ROIs.",
                                                                          "Critical_peak")
                                            logger.debug("Unable to detect the SFR reg ROIs.")
                                            del frame
                                            gc.collect()
                                            self.validation_done = False
                                            self.thread_stop = True
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "Chart not detected in " \
                                                                            "Fixture offset"
                                            break  # break the while loop
                                    else:
                                        display_image = cv2.resize(offset_image, self.dim, interpolation=cv2.INTER_AREA)
                                        height, width, channel = display_image.shape
                                        step = channel * width
                                        qt_img = QImage(display_image.data, width, height, step, QImage.Format_RGB888)
                                        self.signals.call_updateLbl.emit(qt_img)

                                        px_in_mm = float(ui.excel["Pixel in mm"][station])
                                        if (abs(dx) <= int(ui.excel["dx tolerance"][station]) and
                                                abs(dy) <= int(ui.excel["dy tolerance"][station])):
                                            logger.info(
                                                "The fixture placed in the acceptable chart center position: dx {} dy"
                                                " {}.".format(dx, dy))
                                            end_now = datetime.datetime.now()
                                            end_time = end_now.strftime("%H:%M:%S")
                                            logger.info("fixture offset validating end time: {}".format(end_time))
                                            diff = end_now - start_now
                                            logger.info(
                                                "Overall fixture offset validation taken time is: {} seconds\n".format(
                                                    diff.total_seconds()))
                                            self.thread_stop = True
                                            return "Done"

                                        else:
                                            iteration_count += 1
                                            if iteration_count == 10:
                                                logger.debug("Unable to adjust the fixture in the chart center: dx {}"
                                                             " dy {} iteration value {}".format(dx, dy,
                                                                                                iteration_count))
                                                self.validation_done = "Failed"
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "Fixture offset failed after 10 iter"
                                                self.thread_stop = True
                                                return "Failed"

                                            if ui.excel["Chart orientation"][station] == "Horizontal":
                                                if abs(dx) >= int(ui.excel["dx tolerance"][station]):
                                                    x_factor = px_in_mm * abs(dx)
                                                    if dx > 0:
                                                        if int(x_factor) >= 19:
                                                            x_factor = 18
                                                        x_value = abs(float(ui.excel[x_actuator][station]) - x_factor)
                                                        logger.info(
                                                            "X-actuator try to moving position is : "
                                                            "{} and x-factor {}".format(x_value, x_factor))
                                                        status = ui_plc_communication.modbus_class.actuator_movement(5,
                                                                                                                     float(
                                                                                                                         x_value))
                                                    else:
                                                        x_value = abs(float(ui.excel[x_actuator][station]) + x_factor)
                                                        if x_value >= 19:
                                                            x_value = 18
                                                        logger.info(
                                                            "X-actuator try to moving position is : {}".format(x_value))
                                                        status = ui_plc_communication.modbus_class.actuator_movement(5,
                                                                                                                     float(
                                                                                                                         x_value))

                                                    if status == "Passed":
                                                        ui.excel[x_actuator][station] = x_value
                                                        logger.info("X-actuator moved position is : {}".format(x_value))
                                                    else:
                                                        self.thread_stop = True
                                                        logger.error("Error in x-axis movement: {}".format(status))
                                                        alarm_check = ui_plc_communication.modbus_class.alarm_display(5)
                                                        if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                                                            while True:
                                                                if not ui.error_msg_response:
                                                                    ui.error_msg_response = True
                                                                    self.signals.call_MsgBox.emit("Alert",
                                                                                                  f"{alarm_check}",
                                                                                                  "Auto_sequence")
                                                                    logger.error(
                                                                        f"Error occurred while x-axis movement in while offset"
                                                                        f"correction :{status}")
                                                                    self.overall_result_list[
                                                                        "Fixture offset remarks"] = f"{alarm_check}"
                                                                    self.validation_done = "Failed"
                                                                    self.thread_stop = True
                                                                    return "Not Done"

                                                        elif alarm_check != "Passed":
                                                            catch_error = self.catch_and_clear_error(status=alarm_check)
                                                            if catch_error == "Not Done":
                                                                logger.error("User cancelled the sequence "
                                                                             "in while offset correction")
                                                                self.overall_result_list[
                                                                    "Fixture offset remarks"] = "User cancelled the sequence " \
                                                                                                "in while offset correction"
                                                                self.validation_done = False
                                                                self.thread_stop = True
                                                                return "Not Done"

                                                            elif catch_error == "Done":
                                                                time.sleep(0.05)

                                                if abs(dy) >= int(ui.excel["dy tolerance"][station]):
                                                    y_factor = px_in_mm * abs(dy)
                                                    if dy > 0:
                                                        y_value = abs(float(ui.excel[y_actuator][station]) + y_factor)
                                                        logger.info(
                                                            "Y-actuator try to moving position is : {}".format(y_value))
                                                        status = ui_plc_communication.modbus_class.actuator_movement(1,
                                                                                                                     float(
                                                                                                                         y_value),
                                                                                                                     speed=15000)
                                                    else:
                                                        y_value = abs(float(ui.excel[y_actuator][station]) - y_factor)
                                                        logger.info(
                                                            "Y-actuator try to moving position is : {}".format(y_value))
                                                        status = ui_plc_communication.modbus_class.actuator_movement(1,
                                                                                                                     float(
                                                                                                                         y_value),
                                                                                                                     speed=15000)
                                                    if status == "Passed":
                                                        ui.excel[y_actuator][station] = y_value
                                                        logger.info("Y-actuator moved position is : {}".format(y_value))

                                                    else:
                                                        self.thread_stop = True
                                                        logger.error("Error in y-axis movement: {}".format(status))
                                                        alarm_check = ui_plc_communication.modbus_class.alarm_display(1)
                                                        if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                                                            while True:
                                                                if not ui.error_msg_response:
                                                                    ui.error_msg_response = True
                                                                    self.signals.call_MsgBox.emit("Alert",
                                                                                                  f"{alarm_check}",
                                                                                                  "Auto_sequence")
                                                                    logger.error(
                                                                        f"Error occurred while y-axis movement in "
                                                                        f"while offset correction :{status}")
                                                                    self.overall_result_list[
                                                                        "Fixture offset remarks"] = f"{alarm_check}"
                                                                    self.validation_done = "Failed"
                                                                    self.thread_stop = True
                                                                    return "Not Done"

                                                        elif alarm_check != "Passed":
                                                            catch_error = self.catch_and_clear_error(status=alarm_check)
                                                            if catch_error == "Not Done":
                                                                self.overall_result_list[
                                                                    "Fixture offset remarks"] = "User cancelled the sequence " \
                                                                                                "in while offset correction"
                                                                self.validation_done = False
                                                                self.thread_stop = True
                                                                return "Not Done"

                                                            elif catch_error == "Done":
                                                                time.sleep(0.15)
                                            else:
                                                if abs(dx) > 10:
                                                    y_factor = px_in_mm * abs(dx)
                                                    if dx > 0:
                                                        y_value = abs(float(ui.excel[y_actuator][station]) - y_factor)
                                                        logger.info(
                                                            "Y-actuator try to moving position is : {}".format(y_value))
                                                        status = ui_plc_communication.modbus_class.actuator_movement(1,
                                                                                                                     float(
                                                                                                                         y_value),
                                                                                                                     speed=15000)
                                                    else:
                                                        y_value = abs(float(ui.excel[y_actuator][station]) + y_factor)
                                                        logger.info(
                                                            "Y-actuator try to moving position is : {}".format(y_value))
                                                        status = ui_plc_communication.modbus_class.actuator_movement(1,
                                                                                                                     float(
                                                                                                                         y_value),
                                                                                                                     speed=15000)
                                                    if status == "Passed":
                                                        ui.excel[y_actuator][station] = y_value
                                                        logger.info("Y-actuator moved position is : {}".format(y_value))

                                                    else:
                                                        self.thread_stop = True
                                                        logger.error("Error in y-axis movement: {}".format(status))
                                                        alarm_check = ui_plc_communication.modbus_class.alarm_display(1)
                                                        if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                                                            while True:
                                                                if not ui.error_msg_response:
                                                                    ui.error_msg_response = True
                                                                    self.signals.call_MsgBox.emit("Alert",
                                                                                                  f"{alarm_check}",
                                                                                                  "Auto_sequence")
                                                                    logger.error(
                                                                        f"Error occurred while y-axis movement in while"
                                                                        f"offset correction :{status}")
                                                                    self.overall_result_list[
                                                                        "Fixture offset remarks"] = f"{alarm_check}"
                                                                    self.validation_done = "Failed"
                                                                    self.thread_stop = True
                                                                    return "Not Done"

                                                        elif alarm_check != "Passed":
                                                            catch_error = self.catch_and_clear_error(status=alarm_check)
                                                            if catch_error == "Not Done":
                                                                logger.error("User cancelled the sequence "
                                                                             "in while offset correction")
                                                                self.overall_result_list[
                                                                    "Fixture offset remarks"] = "User cancelled the sequence " \
                                                                                                "in while offset correction"
                                                                self.validation_done = False
                                                                self.thread_stop = True
                                                                return "Not Done"

                                                            elif catch_error == "Done":
                                                                time.sleep(0.05)

                                                if abs(dy) > 10:
                                                    x_factor = px_in_mm * abs(dy)
                                                    if dy > 0:
                                                        if int(x_factor) >= 19:
                                                            x_factor = 18
                                                        value = abs(float(ui.excel[x_actuator][station]) - x_factor)
                                                        logger.info(
                                                            "X-actuator try to moving position is : {}".format(value))
                                                        status = ui_plc_communication.modbus_class.actuator_movement(5,
                                                                                                                     float(
                                                                                                                         value))
                                                    else:
                                                        value = abs(float(ui.excel[x_actuator][station]) + x_factor)
                                                        if value >= 19:
                                                            value = 18
                                                        logger.info(
                                                            "X-actuator try to moving position is : {}".format(value))
                                                        status = ui_plc_communication.modbus_class.actuator_movement(5,
                                                                                                                     float(
                                                                                                                         value))
                                                    if status == "Passed":
                                                        ui.excel[x_actuator][station] = value
                                                        logger.info("X-actuator moved position is : {}".format(value))
                                                    else:
                                                        self.thread_stop = True
                                                        logger.error("Error in x-axis movement: {}".format(status))
                                                        alarm_check = ui_plc_communication.modbus_class.alarm_display(5)
                                                        if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                                                            while True:
                                                                if not ui.error_msg_response:
                                                                    ui.error_msg_response = True
                                                                    self.signals.call_MsgBox.emit("Alert",
                                                                                                  f"{alarm_check}",
                                                                                                  "Auto_sequence")
                                                                    logger.error(
                                                                        f"Error occurred while x-axis movement in "
                                                                        f"while offset correction :{status}")
                                                                    self.overall_result_list[
                                                                        "Fixture offset remarks"] = f"{alarm_check}"
                                                                    self.validation_done = "Failed"
                                                                    self.thread_stop = True
                                                                    return "Not Done"

                                                        elif alarm_check != "Passed":
                                                            catch_error = self.catch_and_clear_error(status=alarm_check)
                                                            if catch_error == "Not Done":
                                                                self.overall_result_list[
                                                                    "Fixture offset remarks"] = "User cancelled the sequence " \
                                                                                                "in while offset correction"
                                                                self.validation_done = False
                                                                self.thread_stop = True
                                                                return "Not Done"

                                                            elif catch_error == "Done":
                                                                time.sleep(0.15)
                                                else:
                                                    j += 1
                                                    if j == 5:
                                                        logger.debug(
                                                            "Unable to adjust the fixture in the chart center: dx {}"
                                                            " dy {} and x-actuator value {} and iteration value {}".format(
                                                                dx, dy, value, j))
                                                        self.signals.call_MsgBox.emit("Alert", "The offset is high, "
                                                                                               "So Unable to adjust fixture offset",
                                                                                      "Warning")
                                                        self.validation_done = "Failed"
                                                        self.overall_result_list[
                                                            "Fixture offset remarks"] = "The offset is hight, Unable to move"
                                                        self.thread_stop = True
                                                        return "Failed"
                                else:
                                    logger.debug("frame is None")

                            else:
                                self.signals.update_statusbar.emit('Frame not received')
                                logger.error('Frame not received')
                                gr_fr_rec += 1
                                time.sleep(1)
                                if gr_fr_rec == 10:
                                    self.signals.call_MsgBox.emit("Alert", "Frame not received", "Warning")
                                    self.validation_done = False
                                    self.overall_result_list["Fixture offset remarks"] = "Frame not received"
                                    self.thread_stop = True
                                    break
                        else:
                            ret_false += 1
                            time.sleep(1)
                            if ret_false == 10:
                                self.signals.call_MsgBox.emit("Alert", "Unable to get the frames.", "Warning")
                                self.validation_done = False
                                self.thread_stop = True
                                self.overall_result_list["Fixture offset remarks"] = "Unable to get the frames."
                                logger.error('ret false while offset check')
                                break

                    else:
                        cap_failed += 1
                        time.sleep(1)
                        if cap_failed == 10:
                            self.signals.call_MsgBox.emit("Alert", "Unable to get the frames.", "Warning")
                            self.validation_done = False
                            self.thread_stop = True
                            self.overall_result_list[
                                "Fixture offset remarks"] = "Unable to get the frames."
                            logger.error('cap open failed while offset check')
                            break

            else:
                self.thread_stop = True
                return "Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at check_center_offset function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at offset correct func"
            return "Not Done"

    def height_adjustment(self):
        try:
            """
              This method is used to adjustment the lens height using config file.
              param lists: None
              return: None
            """
            start_now = datetime.datetime.now()
            start_time = start_now.strftime("%H:%M:%S")
            logger.info("Height sensor station start time: {}".format(start_time))
            self.loading_list = []
            while "y_moved to height_sensor_station" not in self.loading_list:
                status = self.parallel_x_y(position_x=ui.excel["X-Actuator Displacement"]["Displacement sensor"],
                                           position_y=ui.excel["Y-Actuator Displacement"]["Displacement sensor"])
                if status == "Done":
                    break

                else:
                    if status == "x_failed":
                        alarm_check = ui_plc_communication.modbus_class.alarm_display(5)
                    else:
                        alarm_check = ui_plc_communication.modbus_class.alarm_display(1)
                    logger.error("Error in actuator movement: {}".format(alarm_check))

                    if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                        while True:
                            if not ui.error_msg_response:
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert", f"{alarm_check}", "Auto_sequence")
                                logger.error(
                                    f"Error occurred while actuator movement in height sensor station :{status}")
                                self.overall_result_list["Fixture offset remarks"] = f"{alarm_check}"
                                return "Not Done"

                    elif alarm_check != "Passed":
                        catch_error = self.catch_and_clear_error(status=alarm_check)
                        if catch_error == "Not Done":
                            self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence " \
                                                                                 "in height sensor station"
                            return "Not Done"

                        elif catch_error == "Done":
                            time.sleep(0.15)
            else:
                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        self.signals.call_MsgBox.emit("Alert", "Error occurred in actuator movement", "Auto_sequence")
                        self.overall_result_list[
                            "Fixture offset remarks"] = "Error occurred in actuator movement"
                        return "Not Done"

            count = 0
            while "height_adjustment" not in self.loading_list and count < 3:
                status = ui_plc_communication.height_adjustment(int(ui.excel["Height value"]["Displacement sensor"]))
                if status == "Passed":
                    self.signals.update_statusbar.emit("Height adjustment is completed")
                    self.loading_list.append("height_adjustment")
                    end_now = datetime.datetime.now()
                    end_time = end_now.strftime("%H:%M:%S")
                    logger.info("Height sensor station end time: {}".format(end_time))
                    diff = end_now - start_now
                    logger.info(
                        "Overall height sensor station taken time is: {} seconds\n".format(diff.total_seconds()))
                    self.overall_result_list["height_sensor_station"] = "Passed"
                    self.achieve_min_focus = False
                    return "Done"

                else:
                    logger.error("Error in rotating lens while height adjustment: {}".format(status))
                    status_input = self.verify_input_status()
                    if status_input == "Done":
                        count += 1

                        while count < 3:
                            if not ui.error_msg_response:
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Question", f"{status}\nDo you want to proceed",
                                                              "Question")

                            if ui.user_call_init_yes:
                                ui.error_msg_response = False
                                break

                            elif ui.user_call_init_no:
                                ui.error_msg_response = False
                                break

                        if ui.user_call_init_yes:
                            ui.user_call_init_yes = False
                            logger.info("User clicked yes in height adjustment in focus station")

                        elif ui.user_call_init_no:
                            ui.user_call_init_no = False
                            logger.info("User clicked no in height adjustment station")
                            self.overall_result_list["Fixture offset remarks"] = ("User clicked no in height "
                                                                                  "adjustment station")
                            self.validation_done = False
                            return "Not Done"

                        else:
                            count = 4

                    elif status_input != "Done" and status_input != "Unable to read input status":
                        catch_error = self.catch_and_clear_error(status=status_input)
                        if catch_error == "Not Done":
                            logger.info("User cancelled the sequence in height adjustment station")
                            self.overall_result_list["Fixture offset remarks"] = ("User cancelled the sequence "
                                                                                  "in height adjustment station")
                            self.validation_done = False
                            return "Not Done"

                        elif catch_error == "Done":
                            time.sleep(0.15)

                    else:
                        while True:
                            if not ui.error_msg_response:
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert", "Unable to read input status",
                                                              "Auto_sequence")
                                self.overall_result_list["Fixture offset remarks"] = "Unable to read input status"
                                self.validation_done = False
                                return "Not Done"
            else:
                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        self.signals.call_MsgBox.emit("Alert", "height adjustment is failed", "Auto_sequence")
                        self.overall_result_list["Fixture offset remarks"] = "height adjustment is failed"
                        self.validation_done = False
                        return "Not Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at height_adjustment function : {}|{}|{}|{}".format(exc_type, func_name,
                                                                                    exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at height adjust"
            return "Not Done"

    def verify_input_status(self, port="Port 2"):
        try:
            """
              This method is used to check the ip status.
              param lists: port is str
              return: None
            """
            status = ui_plc_communication.plc_control_class.check_input_status(port)
            if status == "Status updated":
                value = ui_plc_communication.plc_control_class.input_status
                if value["EMO"]:
                    self.emergency_pressed = True
                    return "Emergency pressed"
                elif not value["Air Pressure"]:
                    return "Air Pressure is low"
                elif not value["EMS"]:
                    return "Earth leakage"
                elif not value["Left Door"] and not ui.bypass_option["Left door"]:
                    return "Left side door is opened"
                elif not value["Right Door"] and not ui.bypass_option["Right door"]:
                    return "Right side door is opened"
                else:
                    return "Done"
            else:
                return "Unable to read input status"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at verify_input_status function : {}|{}|{}|{}".format(exc_type, func_name,
                                                                                      exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at Ip check"
            return "Not Done"

    def parallel_x_y(self, position_x, position_y):
        try:
            """
              This method is used to parallel movement thread for X and Y axis actuator.
              param lists: position_x, position_y is float datatype
              return: None
            """
            t1 = threading.Thread(target=ui_plc_communication.x_parallel, args=(position_x,))
            t2 = threading.Thread(target=ui_plc_communication.y_parallel, args=(position_y,))
            t1.start()
            t2.start()
            t1.join()
            t2.join()
            if ui_plc_communication.x_moved == "Passed" and ui_plc_communication.y_moved == "Passed":
                self.focus_station_status = "Done"
                return "Done"

            else:
                if ui_plc_communication.x_moved != "Passed":
                    self.focus_station_status = "Not Done"
                    logger.info("X movement failed when parallel movement")
                    return "x_failed"

                if ui_plc_communication.y_moved != "Passed":
                    self.focus_station_status = "Not Done"
                    logger.info("Y movement failed when parallel movement")
                    return "y_failed"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at parallel_x_y function : {}|{}|{}|{}".format(exc_type, func_name,
                                                                               exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at parallel x & y"
            return "Not Done"

    def relay_z_movement(self):
        try:
            """
              This method is used to move the relay z-axis.
              param lists: None
              return: None
            """
            if ui.setup_type == "Relay station":
                if self.relay_z_movement_status == "" or self.relay_z_movement_status == "Not Done":
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(2)
                    logger.info("Relay current position is {}".format(actual_value))
                    if actual_value == float(ui.focus_station_z_value):
                        self.signals.update_statusbar.emit("Relay Z-axis is moved")
                        self.relay_z_movement_status = "Done"
                        return "Done"
                    else:
                        self.signals.update_statusbar.emit("Relay Z-axis is moving..")
                        status = ui_plc_communication.modbus_class.actuator_movement(2,
                                                                                     float(ui.excel["Z-Actuator Relay"][
                                                                                               "Relay station"]))
                        if status == "Passed":
                            self.signals.update_statusbar.emit("Relay Z-axis is moved")
                            self.relay_z_movement_status = "Done"
                            return "Done"
                        else:
                            self.signals.update_statusbar.emit("Relay Z-axis movement failed")
                            logger.info("Relay Z-axis movement failed")
                            self.relay_z_movement_status = "Not Done"
                            return "Not Done"
                else:
                    self.relay_z_movement_status = "Done"
                    return "Done"
            else:
                self.relay_z_movement_status = "Done"
                return "Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at relay_z_movement function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at relay z func"
            return "Not Done"

    def set_relay_lux(self, station):
        try:
            """
              This method is used to set the lux and distance for relay panel and collimator.
              param lists: station is str
              return: None
            """
            if self.set_lux_status == "" or self.set_lux_status == "Not Done":
                if station == "Collimator station":
                    self.signals.update_station_position.emit(3)
                    self.signals.update_statusbar.emit("Set dst & lux is in progress..")
                    status = ui_plc_communication.collimator_class.change_collimator_light(
                        light=ui.collimator_list_items, light_type=ui.collimator_light_type,
                        collimator_list=[1, 2, 3, 4, 5])
                    if status == "Passed":
                        self.signals.update_statusbar.emit("Collimator lux is set.")
                        status = ui_plc_communication.collimator_class.change_collimator_distance(
                            int(ui.excel["Collimator chart distance"]["Collimator station"]), [1, 2, 3, 4, 5])
                        if status == "Passed":
                            self.signals.update_statusbar.emit("Collimator distance is set.")
                            self.set_lux_status = "Done"
                            return "Done"
                        else:
                            self.signals.update_statusbar.emit("Failed to set collimator distance.")
                            logger.info("Failed to set collimator distance.")
                            self.set_lux_status = "Not Done"
                            return "Not Done"
                    else:
                        self.signals.update_statusbar.emit("Failed to set collimator lux.")
                        self.set_lux_status = "Not Done"
                        logger.info("Failed to set collimator lux.")
                        return "Not Done"

                elif station == "Relay station":
                    self.signals.update_station_position.emit(4)
                    self.signals.update_statusbar.emit("Set lux value is in progress..")
                    status = ui_plc_communication.plc_control_class.light_panel_lux(
                        int(ui.excel["Light panel intensity"]["Relay station"]))
                    if status == "Passed":
                        self.signals.update_statusbar.emit("Lux value is set.")
                        self.set_lux_status = "Done"
                        return "Done"
                    else:
                        self.set_lux_status = "Not Done"
                        self.signals.update_statusbar.emit("Failed to set lux value")
                        logger.info("Failed to set lux value")
                        return "Not Done"
            else:
                self.set_lux_status = "Done"
                return "Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at set_relay_lux function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at set lux z func"
            return "Not Done"

    def gluing_z_movement(self):
        try:
            """
              This method is used to move the gluing z-axis move.
              param lists: None
              return: None
            """
            if bool(ui.excel["Gluing Status"]["Gluing station"]):
                if self.gluing_z_movement_status == "" or self.gluing_z_movement_status == "Not Done":
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(3)
                    logger.info("Gluing Z-axis current position is {}".format(actual_value))
                    if actual_value == float(ui.gluing_z_value):
                        self.signals.update_statusbar.emit("Gluing Z-axis moved.")
                        self.gluing_z_movement_status = "Done"
                        return "Done"
                    else:
                        self.signals.update_statusbar.emit("Gluing Z-axis is moving..")
                        status = ui_plc_communication.modbus_class.actuator_movement(3,
                                                                                     float(
                                                                                         ui.excel["Z-Actuator Gluing"][
                                                                                             "Gluing station"]))
                        if status == "Passed":
                            self.signals.update_statusbar.emit("Gluing Z-axis moved.")
                            self.gluing_z_movement_status = "Done"
                            return "Done"
                        else:
                            self.gluing_z_movement_status = "Not Done"
                            self.signals.update_statusbar.emit("Gluing z-axis movement failed.")
                            return "Not Done"
                else:
                    self.gluing_z_movement_status = "Done"
                    return "Done"
            else:
                self.gluing_z_movement_status = "Done"
                return "Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at gluing_z_movement function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at gluing z func"
            return "Not Done"

    def curing_z_movement(self):
        try:
            """
              This method is used to move the curing z-axis move.
              param lists: None
              return: None
            """
            if bool(ui.excel["Curing Status"]["Curing station"]):
                if self.curing_z_movement_status == "" or self.curing_z_movement_status == "Not Done":
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(4)
                    logger.info("Curing Z-axis current position is {}".format(actual_value))
                    if actual_value == float(ui.curing_z_value):
                        self.signals.update_statusbar.emit("Curing Z-axis moved.")
                        self.curing_z_movement_status = "Done"
                        return "Done"
                    else:
                        self.signals.update_statusbar.emit("Curing Z-axis is moving..")
                        status = ui_plc_communication.modbus_class.actuator_movement(4, float(
                            ui.excel["Z-Actuator Curing"][
                                "Curing station"]))
                        if status == "Passed":
                            self.signals.update_statusbar.emit("Curing Z-axis moved.")
                            self.curing_z_movement_status = "Done"
                            return "Done"
                        else:
                            self.signals.update_statusbar.emit("Curing Z-axis moved.")
                            self.curing_z_movement_status = "Not Done"
                            return "Not Done"
                else:
                    self.curing_z_movement_status = "Done"
                    return "Done"
            else:
                self.curing_z_movement_status = "Done"
                return "Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at curing_z_movement function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at curing z func"
            return "Not Done"

    def gluing_station(self):
        try:
            """
              This method is used to complete gluing station.
              param lists: None
              return: None
            """
            self.start_ip_check = False
            start_now = datetime.datetime.now()
            start_time = start_now.strftime("%H:%M:%S")
            logger.info("Gluing station start time: {}".format(start_time))
            self.loading_list = []
            count = 0
            self.signals.update_statusbar.emit("Moving to gluing station")
            if ui.abort_auto_sequence_clicked:
                self.validation_done = False
                ui.validation_clicked = False
                self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                     "abort button."
                gc.collect()
                return "Not Done"

            while "X-axis moved" not in self.loading_list and count < 3:
                status = self.parallel_x_y(position_x=float(ui.excel["X-Actuator Gluing"]["Gluing station"]),
                                           position_y=float(ui.excel["Y-Actuator Gluing"]["Gluing station"]))
                if status == "Done":
                    self.start_ip_check = False
                    self.loading_list.append("X-axis moved")
                    self.signals.update_station_position.emit(5)
                    break
                else:
                    self.start_ip_check = False
                    if status == "x_failed":
                        alarm_check = ui_plc_communication.modbus_class.alarm_display(5)
                    else:
                        alarm_check = ui_plc_communication.modbus_class.alarm_display(1)

                    logger.error("Error in actuator movement: {}".format(alarm_check))
                    if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                        while True:
                            if not ui.error_msg_response:
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert", f"{status}", "Auto_sequence")
                                logger.error(
                                    f"Error occurred while parallel x and y movement in gluing station :{status}")
                                self.overall_result_list["Fixture offset remarks"] = f"{status}"
                                self.validation_done = False
                                return "Not Done"

                    elif alarm_check != "Passed":
                        catch_error = self.catch_and_clear_error(status=alarm_check)
                        if catch_error == "Not Done":
                            logger.info("User clicked no in actuator movement in gluing station")
                            self.validation_done = False
                            self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence " \
                                                                                 "in gluing station"
                            return "Not Done"

                        elif catch_error == "Done":
                            time.sleep(0.15)
            else:
                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        self.signals.call_MsgBox.emit("Alert", "Error occurred in actuator movement in "
                                                               "gluing station", "Auto_sequence")
                        self.validation_done = False
                        self.overall_result_list["Fixture offset remarks"] = ("Error occurred in actuator movement in "
                                                                              "gluing station")
                        logger.error("Error occurred in actuator movement in gluing station")
                        return "Not Done"

            if self.gluing_z_movement_status == "Done":
                self.start_ip_check = False
                pass
            else:
                count = 0
                self.signals.update_statusbar.emit("Gluing Z-axis moving...")
                while "z-axis moved" not in self.loading_list and count < 3:
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(3)
                    logger.info("Gluing current position is: {}".format(actual_value))
                    if actual_value == float(ui.gluing_z_value):
                        self.start_ip_check = False
                        self.thread_stop = True
                        self.loading_list.append("z-axis moved")
                        self.signals.update_statusbar.emit("Z-axis moved to gluing position")
                        break

                    else:
                        if ui.abort_auto_sequence_clicked:
                            self.validation_done = False
                            ui.validation_clicked = False
                            self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                                 "abort button."
                            gc.collect()
                            return "Not Done"

                        status = ui_plc_communication.modbus_class.actuator_movement(3,
                                                                                     ui.excel["Z-Actuator Gluing"][
                                                                                         "Gluing station"])
                        if status == "Passed":
                            self.start_ip_check = False
                            self.thread_stop = True
                            self.loading_list.append("z-axis moved")
                            self.signals.update_statusbar.emit("Z-axis moved to gluing position")
                            break

                        else:
                            self.thread_stop = True
                            self.start_ip_check = False
                            alarm_check = ui_plc_communication.modbus_class.alarm_display(3)
                            logger.error("Error in gluing z-axis movement: {}".format(alarm_check))
                            if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                                while True:
                                    if not ui.error_msg_response:
                                        ui.error_msg_response = True
                                        self.signals.call_MsgBox.emit("Alert", f"{alarm_check}", "Auto_sequence")
                                        logger.error(
                                            f"Error occurred while z-axis movement in gluing station :{status}")
                                        self.overall_result_list["Fixture offset remarks"] = f"{alarm_check}"
                                        self.validation_done = False
                                        return "Not Done"

                            elif alarm_check != "Passed":
                                catch_error = self.catch_and_clear_error(status=alarm_check)
                                if catch_error == "Not Done":
                                    logger.info("User clicked no in gluing z-axis movement")
                                    self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence " \
                                                                                         "in gluing station"
                                    self.validation_done = False
                                    return "Not Done"

                                elif catch_error == "Done":
                                    time.sleep(0.15)
                else:
                    while True:
                        if not ui.error_msg_response:
                            ui.error_msg_response = True
                            self.signals.call_MsgBox.emit("Alert", "Error occurred in gluing z-axis movement",
                                                          "Auto_sequence")
                            self.overall_result_list[
                                "Fixture offset remarks"] = "Error occurred in gluing z-axis movement"
                            logger.info("Error occurred in gluing z-axis movement")
                            self.validation_done = False
                            return "Not Done"

            check = self.check_input_manually()
            if not check:
                logger.info("User clicked no in gluing station")
                self.validation_done = False
                self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence " \
                                                                     "in gluing station"
                return "Not Done"

            if self.emergency_pressed:
                self.signals.update_statusbar.emit("Gluing homing is in progress...")
                self.emergency_pressed = False
                while "Emergency gluing init" not in self.loading_list:
                    status = ui_plc_communication.plc_control_class.gluing_init()
                    if status == "Passed":
                        self.start_ip_check = False
                        time.sleep(0.15)
                        self.signals.update_statusbar.emit('gluing y moving....')
                        status = ui_plc_communication.plc_control_class.glue_manual_move_recipe(y_manual=20)
                        if status == "Passed":
                            self.gluing_y_movement_status = "Done"
                            self.signals.update_statusbar.emit('gluing y moved.')
                            self.loading_list.append("Emergency gluing init")
                            break
                        else:
                            logger.error("Error in spot glue movement: {}".format(status))
                            self.start_ip_check = False
                            time.sleep(0.15)
                            status_input = self.verify_input_status()
                            if status_input == "Done":
                                time.sleep(0.15)
                                status = ui_plc_communication.plc_control_class.gluing_init()
                                if status == "Passed":
                                    self.signals.update_statusbar.emit('gluing y moving....')
                                    status = ui_plc_communication.plc_control_class.glue_manual_move_recipe(y_manual=20)
                                    if status == "Passed":
                                        self.signals.update_statusbar.emit('gluing y moved.')
                                        self.gluing_y_movement_status = "Done"
                                        self.loading_list.append("Emergency gluing init")
                                        break
                                    else:
                                        self.validation_done = False
                                        self.overall_result_list["Fixture offset remarks"] = "Gluing y movement failed."
                                        return "Not Done"
                                else:
                                    self.validation_done = False
                                    self.overall_result_list["Fixture offset remarks"] = "Gluing init failed"
                                    return "Not Done"

                            elif status_input != "Done" and status_input != "Unable to read input status":
                                time.sleep(0.15)
                                catch_error = self.catch_and_clear_error(status=status_input)
                                if catch_error == "Not Done":
                                    self.validation_done = False
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "User cancelled the sequence in gluing station"
                                    return "Not Done"

                                elif catch_error == "Done":
                                    status = ui_plc_communication.plc_control_class.gluing_init()
                                    if status == "Passed":
                                        self.signals.update_statusbar.emit('gluing y moving....')
                                        time.sleep(0.15)
                                        status = ui_plc_communication.plc_control_class.glue_manual_move_recipe(
                                            y_manual=20)
                                        if status == "Passed":
                                            self.signals.update_statusbar.emit('gluing y moved.')
                                            self.gluing_y_movement_status = "Done"
                                            self.loading_list.append("Emergency gluing init")
                                            break
                                        else:
                                            self.validation_done = False
                                            logger.info("Gluing y movement failed.")
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "Gluing y movement failed."
                                            return "Not Done"

                                    else:
                                        self.validation_done = False
                                        logger.info("Gluing init failed while gluing init condition")
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "Gluing initialization failed"
                                        return "Not Done"
                            else:
                                while True:
                                    if not ui.error_msg_response:
                                        ui.error_msg_response = True
                                        self.signals.call_MsgBox.emit("Alert", "Unable to read input status",
                                                                      "Auto_sequence")
                                        self.validation_done = False
                                        logger.info("Unable to read input status in gluing station")
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "Unable to read input status" \
                                                                        "in gluing station"
                                        return "Not Done"
                    else:
                        logger.error("Error in gluing init: {}".format(status))
                        self.start_ip_check = False
                        time.sleep(0.15)
                        status_input = self.verify_input_status()
                        if status_input == "Done":
                            time.sleep(0.15)
                            status = ui_plc_communication.plc_control_class.gluing_init()
                            if status == "Passed":
                                self.signals.update_statusbar.emit('gluing y moving....')
                                time.sleep(0.05)
                                status = ui_plc_communication.plc_control_class.glue_manual_move_recipe(y_manual=20)
                                if status == "Passed":
                                    self.signals.update_statusbar.emit('gluing y moved.')
                                    self.gluing_y_movement_status = "Done"
                                    self.loading_list.append("Emergency gluing init")
                                    break
                                else:
                                    self.validation_done = False
                                    self.overall_result_list["Fixture offset remarks"] = "Gluing y movement failed."
                                    return "Not Done"
                            else:
                                self.validation_done = False
                                self.overall_result_list["Fixture offset remarks"] = "Gluing init failed"
                                return "Not Done"

                        elif status_input != "Done" and status_input != "Unable to read input status":
                            time.sleep(0.05)
                            catch_error = self.catch_and_clear_error(status=status_input)
                            if catch_error == "Not Done":
                                self.validation_done = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User cancelled the sequence in gluing station"
                                return "Not Done"

                            elif catch_error == "Done":
                                status = ui_plc_communication.plc_control_class.gluing_init()
                                if status == "Passed":
                                    self.signals.update_statusbar.emit('gluing y moving....')
                                    status = ui_plc_communication.plc_control_class.glue_manual_move_recipe(y_manual=20)
                                    if status == "Passed":
                                        self.signals.update_statusbar.emit('gluing y moved.')
                                        self.gluing_y_movement_status = "Done"
                                        self.loading_list.append("Emergency gluing init")
                                        break
                                    else:
                                        self.validation_done = False
                                        logger.info("Gluing y movement failed.")
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "Gluing y movement failed."
                                        return "Not Done"

                                else:
                                    self.validation_done = False
                                    logger.info("Gluing init failed while gluing init condition")
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "Gluing initialization failed"
                                    return "Not Done"
                        else:
                            while True:
                                if not ui.error_msg_response:
                                    ui.error_msg_response = True
                                    self.signals.call_MsgBox.emit("Alert", "Unable to read input status",
                                                                  "Auto_sequence")
                                    self.validation_done = False
                                    logger.info("Unable to read input status in gluing station")
                                    self.overall_result_list["Fixture offset remarks"] = "Unable to read input status" \
                                                                                         "in gluing station"
                                    return "Not Done"
                else:
                    while True:
                        if not ui.error_msg_response:
                            ui.error_msg_response = True
                            self.signals.call_MsgBox.emit("Alert", "Error occurred while gluing init", "Auto_sequence")
                            logger.info("Unable to do gluing init after 3 iteration.")
                            self.overall_result_list[
                                "Fixture offset remarks"] = "Unable to do gluing init"
                            self.validation_done = False
                            return "Not Done"

            self.start_ip_check = False
            time.sleep(0.05)
            self.signals.update_statusbar.emit("Glue apply is in progress..")
            if ui.abort_auto_sequence_clicked:
                self.validation_done = False
                ui.validation_clicked = False
                self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                     "abort button."
                gc.collect()
                return "Not Done"
            if ui.excel["Glue Type"]["Gluing station"] == "Spot glue":
                while "spot glue movement" not in self.loading_list:
                    status = self.spot_glue_parallel()
                    if status == "Passed":
                        self.loading_list.append("spot glue movement")
                        break
                    else:
                        logger.error("Error in spot glue movement: {}".format(status))
                        status_input = self.verify_input_status()
                        if status_input == "Done":
                            status = ui_plc_communication.plc_control_class.gluing_init()
                            if status == "Passed":
                                status = ui_plc_communication.plc_control_class.glue_manual_move_recipe(y_manual=20)
                                if status == "Passed":
                                    time.sleep(0.15)
                                else:
                                    while True:
                                        if not ui.error_msg_response:
                                            ui.error_msg_response = True
                                            self.signals.call_MsgBox.emit("Alert", "spot glue movement failed",
                                                                          "Auto_sequence")
                                            self.validation_done = False
                                            logger.info("spot glue movement failed")
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "spot glue movement failed"
                                            return "Not Done"
                            else:
                                while True:
                                    if not ui.error_msg_response:
                                        ui.error_msg_response = True
                                        self.signals.call_MsgBox.emit("Alert", "Gluing init failed while spot glue "
                                                                               "movement",
                                                                      "Auto_sequence")
                                        self.validation_done = False
                                        logger.info("Gluing init failed while spot glue movement")
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "Gluing init failed while spot glue movement"
                                        return "Not Done"

                        elif status_input != "Done" and status_input != "Unable to read input status":
                            time.sleep(0.05)
                            catch_error = self.catch_and_clear_error(status=status_input)
                            if catch_error == "Not Done":
                                logger.info("User cancelled the sequence in gluing station")
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User cancelled the sequence in gluing station"
                                self.validation_done = False
                                return "Not Done"

                            elif catch_error == "Done":
                                status = ui_plc_communication.plc_control_class.gluing_init()
                                if status == "Passed":
                                    time.sleep(0.05)
                                    status = ui_plc_communication.plc_control_class.glue_manual_move_recipe(y_manual=20)
                                    if status == "Passed":
                                        time.sleep(0.15)
                                    else:
                                        while True:
                                            if not ui.error_msg_response:
                                                ui.error_msg_response = True
                                                self.signals.call_MsgBox.emit("Alert", "spot glue movement failed",
                                                                              "Auto_sequence")
                                                self.validation_done = False
                                                logger.info("spot glue movement failed")
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "spot glue movement failed"
                                                return "Not Done"

                                else:
                                    while True:
                                        if not ui.error_msg_response:
                                            ui.error_msg_response = True
                                            self.signals.call_MsgBox.emit("Alert",
                                                                          "Gluing init failed while spot glue movement",
                                                                          "Auto_sequence")
                                            self.validation_done = False
                                            logger.info("Gluing init failed while spot glue movement")
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "Gluing init failed while spot glue movement"
                                            return "Not Done"
                        else:
                            while True:
                                if not ui.error_msg_response:
                                    ui.error_msg_response = True
                                    self.signals.call_MsgBox.emit("Alert", "Unable to read input status",
                                                                  "Auto_sequence")
                                    self.validation_done = False
                                    logger.info("Unable to read input status in spot glue movement")
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "Unable to read input status in spot glue movement"
                                    return "Not Done"
                else:
                    while True:
                        if not ui.error_msg_response:
                            ui.error_msg_response = True
                            self.signals.call_MsgBox.emit("Alert", "Error occurred while spot glue movement",
                                                          "Auto_sequence")
                            logger.info("Unable to move spot glue after 3 iteration.")
                            self.overall_result_list[
                                "Fixture offset remarks"] = "Unable to move spot glue"
                            self.validation_done = False
                            return "Not Done"

                time.sleep(0.05)
                check = self.check_input_manually()
                if not check:
                    logger.info("User clicked no in gluing station")
                    self.validation_done = False
                    self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence " \
                                                                         "in gluing station"
                    return "Not Done"

                while "spot glue apply" not in self.loading_list:
                    status = ui_plc_communication.plc_control_class.glue_dispenser_timer(
                        timer=float(ui.excel["Glue time"]["Gluing station"]), x1_value=float(ui.excel["Gluing x1"]
                                                                                             ["Gluing station"]))
                    if status == "Passed":
                        self.loading_list.append("spot glue apply")
                        break

                    elif status == "Error in glue cartridge 1 empty" or status == "Error in glue cartridge 2 empty":
                        while True:
                            if not ui.error_msg_response:
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert", f"{status}", "Auto_sequence")
                                self.validation_done = False
                                self.overall_result_list["Fixture offset remarks"] = status
                                return "Not Done"

                    else:
                        logger.error("Error in spot glue apply: {}".format(status))
                        status_input = self.verify_input_status()
                        if status_input == "Done":
                            while True:
                                if not ui.error_msg_response:
                                    ui.error_msg_response = True
                                    self.signals.call_MsgBox.emit("Alert", 'Error occurred while spot glue apply\n'
                                                                           'So abort the sequence', "Auto_sequence")
                                    self.validation_done = False
                                    return "Not Done"

                        elif status_input != "Done" and status_input != "Unable to read input status":
                            catch_error = self.catch_and_clear_error(status=status_input, retry_skip="Yes")
                            logger.info('Error occurred while spot glue apply')
                            self.validation_done = False
                            self.overall_result_list["Fixture offset remarks"] = 'Error occurred while spot ' \
                                                                                 'glue apply'
                            return "Not Done"

                        else:
                            while True:
                                if not ui.error_msg_response:
                                    ui.error_msg_response = True
                                    self.signals.call_MsgBox.emit("Alert", "Unable to read input status",
                                                                  "Auto_sequence")
                                    self.validation_done = False
                                    self.overall_result_list["Fixture offset remarks"] = "Unable to get input status"
                                    logger.error("Unable to get input status in gluing station")
                                    return "Not Done"

                else:
                    while True:
                        if not ui.error_msg_response:
                            ui.error_msg_response = True
                            self.signals.call_MsgBox.emit("Alert", 'Error occurred while spot glue apply',
                                                          "Auto_sequence")
                            self.validation_done = False
                            self.overall_result_list[
                                "Fixture offset remarks"] = 'Error occurred while spot glue apply'
                            logger.error('Error occurred while spot glue apply')
                            return "Not Done"

                if self.gluing_z_movement_status == "Done":
                    self.thread_stop = True
                    self.start_ip_check = False
                    self.signals.update_statusbar.emit("Gluing Z-axis moved up")
                    end_now = datetime.datetime.now()
                    end_time = end_now.strftime("%H:%M:%S")
                    logger.info("Gluing station end time: {}".format(end_time))
                    diff = end_now - start_now
                    logger.info("Overall gluing station taken time is: {} seconds\n".format(diff.total_seconds()))
                    self.overall_result_list["gluing_station"] = "Passed"
                    return "Done"
                else:
                    while "gluing z-axis reverse movement" not in self.loading_list:
                        actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(3)
                        logger.info("Gluing current position for reverse is {}".format(actual_value))
                        if actual_value == float(ui.gluing_z_reverse_value):
                            self.thread_stop = True
                            self.start_ip_check = False
                            self.signals.update_statusbar.emit("Gluing Z-axis moved up")
                            end_now = datetime.datetime.now()
                            end_time = end_now.strftime("%H:%M:%S")
                            logger.info("Gluing station end time: {}".format(end_time))
                            diff = end_now - start_now
                            logger.info(
                                "Overall gluing station taken time is: {} seconds\n".format(diff.total_seconds()))
                            self.overall_result_list["gluing_station"] = "Passed"
                            return "Done"

                        else:
                            if ui.abort_auto_sequence_clicked:
                                self.validation_done = False
                                ui.validation_clicked = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                "abort button."
                                gc.collect()
                                return "Not Done"
                            self.start_ip_check = False
                            time.sleep(0.05)
                            status = ui_plc_communication.modbus_class.actuator_movement(
                                3, float(ui.excel["Z-Actuator reverse"]["Gluing station"]))

                            if status == "Passed":
                                self.thread_stop = True
                                self.start_ip_check = False
                                self.signals.update_statusbar.emit("Gluing Z-axis moved up")
                                end_now = datetime.datetime.now()
                                end_time = end_now.strftime("%H:%M:%S")
                                logger.info("Gluing station end time: {}".format(end_time))
                                diff = end_now - start_now
                                logger.info(
                                    "Overall gluing station taken time is: {} seconds\n".format(diff.total_seconds()))
                                self.overall_result_list["gluing_station"] = "Passed"
                                return "Done"

                            else:
                                self.thread_stop = True
                                self.start_ip_check = False
                                alarm_check = ui_plc_communication.modbus_class.alarm_display(3)
                                logger.error("Error in gluing z-axis reverse movement: {}".format(alarm_check))
                                if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                                    while True:
                                        if not ui.error_msg_response:
                                            ui.error_msg_response = True
                                            self.signals.call_MsgBox.emit("Alert", f"{alarm_check}", "Auto_sequence")
                                            logger.error(
                                                f"Error occurred while z-axis movement in gluing station :{status}")
                                            self.overall_result_list["Fixture offset remarks"] = f"{alarm_check}"
                                            self.validation_done = False
                                            return "Not Done"

                                elif alarm_check != "Passed":
                                    catch_error = self.catch_and_clear_error(status=alarm_check)
                                    if catch_error == "Not Done":
                                        logger.info("User clicked no in gluing z-axis reverse movement")
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "User cancelled the sequence" \
                                                                        "in gluing station"
                                        self.validation_done = False
                                        return "Not Done"

                                    elif catch_error == "Done":
                                        time.sleep(0.15)

                    else:
                        while True:
                            if not ui.error_msg_response:
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert",
                                                              "Error occurred in gluing z-axis reverse movement",
                                                              "Auto_sequence")
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "Error occurred in gluing z-axis reverse movement"
                                logger.info("Error occurred in gluing z-axis movement")
                                self.validation_done = False
                                return "Not Done"

            else:
                if ui.abort_auto_sequence_clicked:
                    self.validation_done = False
                    ui.validation_clicked = False
                    self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                         "abort button."
                    gc.collect()
                    return "Not Done"

                count = 0
                if ui.glue_offset_write:
                    while "glue offset write" not in self.loading_list and count < 2:
                        status = ui_plc_communication.plc_control_class.write_values_glue_offset(
                            c1_manual=float(ui.excel["Gluing x1"]["Gluing station"]),
                            c2_manual=float(ui.excel["Gluing x2"]["Gluing station"]))
                        if status == "Passed":
                            self.signals.update_statusbar.emit("Gluing offset write")
                            ui.glue_offset_write = False
                            self.loading_list.append("glue offset write")
                            break

                        else:
                            logger.error("Error in gluing offset write: {}".format(status))
                            while True:
                                if not ui.error_msg_response:
                                    ui.error_msg_response = True
                                    self.signals.call_MsgBox.emit("Alert", "Error occurred in glue offset write\n"
                                                                           "So aborted the process", "Auto_sequence")
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "Error occurred while glue offset write"
                                    self.validation_done = False
                                    return "Not Done"

                count = 0
                while "glue apply" not in self.loading_list and count < 3:
                    if pd.isna(ui.excel["Glue on time_delay"]["Gluing station"]) and \
                            pd.isna(ui.excel["Glue off time_delay"]["Gluing station"]):
                        status = ui_plc_communication.plc_control_class.apply_glue(
                            speed=ui.excel["Glue speed"]["Gluing station"],
                            diameter=ui.excel["Glue Diameter"]["Gluing station"],  # if on_delay & off_delay is None
                            glue_type=ui.excel["Glue Type"]["Gluing station"])

                    elif not pd.isna(ui.excel["Glue on time_delay"]["Gluing station"]) and not \
                            pd.isna(ui.excel["Glue off time_delay"]["Gluing station"]):
                        status = ui_plc_communication.plc_control_class.apply_glue(
                            speed=ui.excel["Glue speed"]["Gluing station"],
                            diameter=ui.excel["Glue Diameter"]["Gluing station"],
                            glue_type=ui.excel["Glue Type"]["Gluing station"],  # if on_delay & off_delay is not None
                            on_delay=float(ui.excel["Glue on time_delay"]["Gluing station"]),
                            off_delay=float(ui.excel["Glue off time_delay"]["Gluing station"]))

                    elif not pd.isna(ui.excel["Glue on time_delay"]["Gluing station"]):
                        status = ui_plc_communication.plc_control_class.apply_glue(
                            speed=ui.excel["Glue speed"]["Gluing station"],
                            diameter=ui.excel["Glue Diameter"]["Gluing station"],
                            glue_type=ui.excel["Glue Type"]["Gluing station"],  # if on_delay is Not none
                            on_delay=float(ui.excel["Glue on time_delay"]["Gluing station"]))  # and off_delay is None

                    elif not pd.isna(ui.excel["Glue off time_delay"]["Gluing station"]):
                        status = ui_plc_communication.plc_control_class.apply_glue(
                            speed=ui.excel["Glue speed"]["Gluing station"],
                            diameter=ui.excel["Glue Diameter"]["Gluing station"],
                            glue_type=ui.excel["Glue Type"]["Gluing station"],  # if off_delay is Not none
                            off_delay=float(ui.excel["Glue off time_delay"]["Gluing station"]))  # and on_delay is None
                    else:
                        logger.error("Invalid glue type values")
                        self.overall_result_list["Fixture offset remarks"] = "Invalid glue type values"
                        self.validation_done = False
                        return "Not Done"

                    if not self.ip_status:
                        self.start_ip_check = False
                        catch_error = self.catch_and_clear_error(status=self.status_input)
                        if catch_error == "Not Done":
                            gc.collect()
                            self.ip_status = False
                            ui.validation_clicked = False
                            self.overall_result_list[
                                "Fixture offset remarks"] = "User cancelled the sequence in while rotation"
                            return

                        elif catch_error == "Done":
                            time.sleep(1)
                            self.ip_status = True

                        else:
                            gc.collect()
                            self.ip_status = False
                            ui.validation_clicked = False
                            self.overall_result_list[
                                "Fixture offset remarks"] = "Error occurred in catch & clear else case in streaming"
                            return

                    elif status == "Passed":
                        self.start_ip_check = False
                        self.signals.update_statusbar.emit("Glue successfully applied")
                        self.loading_list.append("glue apply")
                        break

                    elif status == "Error in glue cartridge 1 empty" or "Error in glue cartridge 2 empty":
                        self.start_ip_check = False
                        self.overall_result_list["Fixture offset remarks"] = f"{status}"
                        self.validation_done = False
                        return "Not Done"

                    else:
                        self.start_ip_check = False
                        logger.error("Error in continuous glue apply: {}".format(status))
                        status_input = self.verify_input_status()
                        if status_input == "Done":
                            self.overall_result_list[
                                "Fixture offset remarks"] = 'Error occurred while continuous glue apply'
                            self.validation_done = False
                            return "Not Done"

                time.sleep(0.05)
                check = self.check_input_manually()
                if not check:
                    logger.info("User clicked no in gluing station")
                    self.validation_done = False
                    self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence " \
                                                                         "in gluing station"
                    return "Not Done"

                if self.gluing_z_movement_status == "Done":
                    self.thread_stop = True
                    self.start_ip_check = False
                    self.signals.update_statusbar.emit("Gluing Z-axis moved up")
                    end_now = datetime.datetime.now()
                    end_time = end_now.strftime("%H:%M:%S")
                    logger.info("Gluing station end time: {}".format(end_time))
                    diff = end_now - start_now
                    logger.info("Overall gluing station taken time is: {} seconds\n".format(diff.total_seconds()))
                    self.overall_result_list["gluing_station"] = "Passed"
                    return "Done"

                else:
                    while "gluing z-axis reverse movement" not in self.loading_list:
                        actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(3)
                        if actual_value == float(ui.gluing_z_reverse_value):
                            self.thread_stop = True
                            self.start_ip_check = False
                            self.signals.update_statusbar.emit("Gluing Z-axis moved up")
                            end_now = datetime.datetime.now()
                            end_time = end_now.strftime("%H:%M:%S")
                            logger.info("Gluing station end time: {}".format(end_time))
                            diff = end_now - start_now
                            logger.info(
                                "Overall gluing station taken time is: {} seconds\n".format(diff.total_seconds()))
                            self.overall_result_list["gluing_station"] = "Passed"
                            return "Done"

                        else:
                            if ui.abort_auto_sequence_clicked:
                                self.validation_done = False
                                ui.validation_clicked = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                "abort button."
                                gc.collect()
                                return "Not Done"
                            self.start_ip_check = False
                            status = ui_plc_communication.modbus_class.actuator_movement(
                                3, float(ui.excel["Z-Actuator reverse Gluing"]["Gluing station"]))
                            if status == "Passed":
                                self.thread_stop = True
                                self.signals.update_statusbar.emit("Gluing Z-axis moved up")
                                end_now = datetime.datetime.now()
                                end_time = end_now.strftime("%H:%M:%S")
                                logger.info("Gluing station end time: {}".format(end_time))
                                diff = end_now - start_now
                                logger.info("Overall gluing station taken time is: {} seconds\n".format(
                                    diff.total_seconds()))
                                self.overall_result_list["gluing_station"] = "Passed"
                                return "Done"

                            else:
                                self.thread_stop = True
                                alarm_check = ui_plc_communication.modbus_class.alarm_display(3)
                                logger.error("Error in gluing z-axis reverse movement: {}".format(alarm_check))
                                if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                                    while True:
                                        if not ui.error_msg_response:
                                            ui.error_msg_response = True
                                            self.signals.call_MsgBox.emit("Alert", f"{alarm_check}", "Auto_sequence")
                                            logger.error(
                                                f"Error occurred while z-axis movement in gluing station :{status}")
                                            self.overall_result_list["Fixture offset remarks"] = f"{alarm_check}"
                                            self.validation_done = False
                                            return "Not Done"

                                elif alarm_check != "Passed":
                                    catch_error = self.catch_and_clear_error(status=alarm_check)
                                    if catch_error == "Not Done":
                                        logger.info("User clicked no in gluing z-axis reverse movement")
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "User cancelled the sequence " \
                                                                        "in gluing station"
                                        self.validation_done = False

                                    elif catch_error == "Done":
                                        time.sleep(0.15)

                    else:
                        while True:
                            if not ui.error_msg_response:
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert",
                                                              "Error occurred in gluing z-axis reverse movement",
                                                              "Auto_sequence")
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "Error occurred in gluing z-axis reverse movement"
                                logger.info("Error occurred in gluing z-axis movement")
                                self.validation_done = False
                                return "Not Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at gluing_station function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at gluing func"
            return "Not Done"

    def spot_glue_x1(self):
        try:
            """
              This method is used to move gluing X1-actuator.
              param lists: None
              return: None
            """
            if self.gluing_y_movement_status == "Done":
                status = ui_plc_communication.plc_control_class.gluing_x1_move(port_number="Port 1",
                                                                               x1_manual=float(ui.excel["Gluing x1"]
                                                                                               ["Gluing station"]))
                if status == "Passed":
                    self.gluing_x1_movement_status = "Done"
                    return
                else:
                    self.gluing_x1_movement_status = "Not Done"
                    return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at spot_glue_x1 function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at spot_glue_x1 func"
            return "Not Done"

    def spot_glue_x2(self):
        try:
            """
              This method is used to move gluing X2-actuator.
              param lists: None
              return: None
            """
            if self.gluing_y_movement_status == "Done":
                status = ui_plc_communication.plc_control_class.glue_manual_move_recipe(port_number="Port 2",
                                                                                        x2_manual=float(
                                                                                            ui.excel["Gluing x2"]
                                                                                            ["Gluing station"]))
                if status == "Passed":
                    self.gluing_x2_movement_status = "Done"
                    return
                else:
                    self.gluing_x2_movement_status = "Not Done"
                    return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at spot_glue_x2 function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lin, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at spot_glue_x2 func"
            return "Not Done"

    def spot_glue_parallel(self):
        try:
            """
              This method is used to start the thread for gluing x1 and x2 actuator.
              param lists: None
              return: None
            """
            self.start_ip_check = False
            t1 = threading.Thread(target=self.spot_glue_x1)
            t2 = threading.Thread(target=self.spot_glue_x2)
            t1.start()
            t2.start()
            t1.join()
            t2.join()
            if self.gluing_x1_movement_status == "Done" and self.gluing_x2_movement_status == "Done":
                self.start_ip_check = False
                return "Passed"
            else:
                self.start_ip_check = False
                return "Failed"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at spot_glue_parallel function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lin, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at spot glue parallel func"
            return "Not Done"

    def catch_and_clear_error(self, status='', retry_skip=''):
        try:
            """
              This method is used to clear the error cases.
              param lists: status and retry_skip are str
              return: None
            """
            logger.debug("Error occurred reason {}".format(status))
            if status == "Emergency pressed" or status == "Air Pressure is low" or status == "Release EMO":
                while True:
                    if status == "Release EMO":
                        break

                    time.sleep(0.05)
                    messages = ui_plc_communication.plc_control_class.serial_port.read(
                        ui_plc_communication.plc_control_class.serial_port.inWaiting()).decode('utf-8', 'ignore')

                    if status == "Emergency pressed":
                        if "K:EMO\r\n" in messages:
                            logger.debug("Release the Emergency button")
                            self.signals.close_MsgBox.emit()
                            break

                        else:
                            if not ui.error_msg_response:
                                self.signals.call_MsgBox.emit("Critical", "Emergency button is pressed",
                                                              "Auto_sequence")
                                ui.error_msg_response = True

                    elif status == "Air Pressure is low":
                        if "K:AIR\r\n" in messages:
                            self.signals.close_MsgBox.emit()
                            break

                        else:
                            if not ui.error_msg_response:
                                self.signals.call_MsgBox.emit("Critical", "Air Pressure is low", "Auto_sequence")
                                ui.error_msg_response = True

                    elif status == "Earth leakage":
                        if "K:EMS\r\n" in messages:
                            self.signals.close_MsgBox.emit()
                            break

                        else:
                            if not ui.error_msg_response:
                                self.signals.call_MsgBox.emit("Critical", "Earth leakage is high", "Auto_sequence")
                                ui.error_msg_response = True

                while True:
                    time.sleep(0.05)
                    message = ui_plc_communication.plc_control_class.serial_port.read(
                        ui_plc_communication.plc_control_class.serial_port.inWaiting()).decode('utf-8', 'ignore')

                    if "K:RST\r\n" in message:
                        self.signals.close_MsgBox.emit()
                        break

                    else:
                        if not ui.error_msg_response:
                            self.signals.call_MsgBox.emit("Critical", "Press the reset button", "Auto_sequence")
                            ui.error_msg_response = True

                if retry_skip == '':
                    while True:
                        if not ui.error_msg_response:
                            ui.error_msg_response = True
                            self.signals.call_MsgBox.emit("Question", "Do you want to proceed", "Question")

                        if ui.user_call_init_yes:
                            ui.error_msg_response = False
                            self.signals.close_MsgBox.emit()
                            break

                        elif ui.user_call_init_no:
                            ui.error_msg_response = False
                            self.signals.close_MsgBox.emit()
                            break

                    if ui.user_call_init_yes:
                        ui.user_call_init_yes = False

                        logger.info("User clicked yes in error catch cases")
                        return "Done"

                    elif ui.user_call_init_no:
                        ui.user_call_init_no = False
                        logger.info("User clicked no in error catch cases")
                        return "Not Done"
                else:
                    return "Done"

            elif status == "Left side door is opened" or status == "Right side door is opened" or \
                    status == "Control panel door is opened":

                while True:
                    time.sleep(0.05)
                    messages = ui_plc_communication.plc_control_class.serial_port.read(
                        ui_plc_communication.plc_control_class.serial_port.inWaiting()).decode('utf-8', 'ignore')

                    if status == "Left side door is opened":
                        if "K:LSD\r\n" in messages:
                            self.signals.close_MsgBox.emit()
                            break

                        else:
                            if not ui.error_msg_response:
                                self.signals.call_MsgBox.emit("Critical", "Please close the left side door",
                                                              "Auto_sequence")
                                ui.error_msg_response = True

                    elif status == "Right side door is opened":
                        if "K:RSD\r\n" in messages:
                            self.signals.close_MsgBox.emit()
                            break

                        else:
                            if not ui.error_msg_response:
                                self.signals.call_MsgBox.emit("Critical", "Please close the right side door",
                                                              "Auto_sequence")
                                ui.error_msg_response = True

                    elif status == "Control panel door is opened":
                        if "K:CPD\r\n" in messages:
                            self.signals.close_MsgBox.emit()
                            break

                        else:
                            if not ui.error_msg_response:
                                self.signals.call_MsgBox.emit("Critical", "Please close the control panel door",
                                                              "Auto_sequence")
                                ui.error_msg_response = True

                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        self.signals.call_MsgBox.emit("Question", "Do you want to proceed", "Question")

                    if ui.user_call_init_yes:
                        break
                    elif ui.user_call_init_no:
                        break

                if ui.user_call_init_yes:
                    ui.user_call_init_yes = False
                    self.signals.close_MsgBox.emit()
                    logger.info("User clicked yes in error catch(door open) cases")
                    return "Done"

                elif ui.user_call_init_no:
                    ui.user_call_init_no = False
                    logger.info("User clicked no in error catch(door open) cases")
                    self.signals.close_MsgBox.emit()
                    return "Not Done"
            else:
                return "Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at catch_and_clear_error function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at catch & clear func"
            return "Not Done"

    def curing_station(self):
        try:
            """
              This method is used to complete curing station.
              param lists: None
              return: None
            """
            self.start_ip_check = False
            start_now = datetime.datetime.now()
            start_time = start_now.strftime("%H:%M:%S")
            logger.info("Curing station start time: {}".format(start_time))
            self.loading_list = []
            self.signals.update_statusbar.emit("Moving to curing station")
            if ui.abort_auto_sequence_clicked:
                self.validation_done = False
                ui.validation_clicked = False
                self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                     "abort button."
                gc.collect()
                return "Not Done"

            if self.curing_door_open_status == "Done":
                pass
            else:
                while "uv door open" not in self.loading_list:
                    status = ui_plc_communication.plc_control_class.uv_door_open()
                    if status == "Passed" or ui.bypass_option["UV door cylinder open"]:
                        self.loading_list.append("uv door open")
                        self.signals.update_statusbar.emit("UV door is opened")
                        break
                    else:
                        logger.error("Error in uv door open: {}".format(status))
                        time.sleep(0.05)
                        status_input = self.verify_input_status()
                        if status_input == "Done":
                            status = ui_plc_communication.plc_control_class.uv_door_open()
                            if status == "Passed" or ui.bypass_option["UV door cylinder open"]:
                                self.loading_list.append("uv door open")
                                self.signals.update_statusbar.emit("UV door is opened")
                                break
                            else:
                                self.validation_done = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "UV door open failed"
                                return "Not Done"

                        elif status_input != "Done" and status_input != "Unable to read input status":
                            catch_error = self.catch_and_clear_error(status=status_input)
                            if catch_error == "Not Done":
                                self.validation_done = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User cancelled the sequence in curing station"
                                return "Not Done"

                            elif catch_error == "Done":
                                time.sleep(0.15)

                        else:
                            while True:
                                if not ui.error_msg_response:
                                    ui.error_msg_response = True
                                    self.signals.call_MsgBox.emit("Alert", "Unable to read input status",
                                                                  "Auto_sequence")
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "Unable to get input status"
                                    self.validation_done = False
                                    return "Not Done"

            count = 0
            while "x_moved to curing station" not in self.loading_list and count < 3:
                status = self.parallel_x_y(position_x=float(ui.excel["X-Actuator Curing"]["Curing station"]),
                                           position_y=float(ui.excel["Y-Actuator Curing"]["Curing station"]))
                if status == "Done":
                    self.loading_list.append("x_moved to curing station")
                    self.start_ip_check = False
                    self.signals.update_station_position.emit(6)
                    break

                else:
                    self.start_ip_check = False
                    if status == "x_failed":
                        alarm_check = ui_plc_communication.modbus_class.alarm_display(5)
                    else:
                        alarm_check = ui_plc_communication.modbus_class.alarm_display(1)

                    logger.error("Error in actuator movement: {}".format(status))
                    if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                        while True:
                            if not ui.error_msg_response:
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert", f"{status}", "Auto_sequence")
                                logger.error(
                                    f"Error occurred while parallel x and y movement in curing station :{status}")
                                self.overall_result_list["Fixture offset remarks"] = f"{status}"
                                self.validation_done = False
                                return "Not Done"

                    elif alarm_check != "Passed":
                        catch_error = self.catch_and_clear_error(status=alarm_check)
                        if catch_error == "Not Done":
                            logger.info("User cancelled the sequence in curing station")
                            self.validation_done = False
                            self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence " \
                                                                                 "in curing station"
                            return "Not Done"

                        elif catch_error == "Done":
                            time.sleep(0.05)
            else:
                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        self.signals.call_MsgBox.emit("Alert", "Error occurred in actuator movement", "Auto_sequence")
                        self.overall_result_list["Fixture offset remarks"] = "Error occurred in actuator movement"
                        self.validation_done = False
                        return "Not Done"

            if self.curing_z_movement_status == "Done":
                pass
            else:
                self.signals.update_statusbar.emit("Curing z-axis is moving..")
                count = 0
                while "curing z-axis moved" not in self.loading_list and count < 3:
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(4)
                    logger.info('Read curing z axis value: {}'.format(actual_value))
                    if actual_value == float(ui.curing_z_value):
                        self.thread_stop = True
                        self.signals.update_statusbar.emit("UV Z-axis movement is completed")
                        self.loading_list.append("curing z-axis moved")
                        break

                    else:
                        if ui.abort_auto_sequence_clicked:
                            self.validation_done = False
                            ui.validation_clicked = False
                            self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                                 "abort button."
                            gc.collect()
                            return "Not Done"
                        status = ui_plc_communication.modbus_class.actuator_movement(4, float(
                            ui.excel["Z-Actuator Curing"][
                                "Curing station"]))
                        if status == "Passed":
                            self.thread_stop = True
                            self.signals.update_statusbar.emit("UV Z-axis movement is completed")
                            self.loading_list.append("curing z-axis moved")
                            break

                        else:
                            self.thread_stop = True
                            alarm_check = ui_plc_communication.modbus_class.alarm_display(4)
                            logger.error("Error in curing z-axis movement: {}".format(status))
                            if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                                while True:
                                    if not ui.error_msg_response:
                                        ui.error_msg_response = True
                                        self.signals.call_MsgBox.emit("Alert", f"{alarm_check}", "Auto_sequence")
                                        logger.error(
                                            f"Error occurred while curing z-axis movement: {status}")
                                        self.overall_result_list["Fixture offset remarks"] = f"{alarm_check}"
                                        self.validation_done = False
                                        return "Not Done"

                            elif alarm_check != "Passed":
                                catch_error = self.catch_and_clear_error(status=alarm_check)
                                if catch_error == "Not Done":
                                    self.validation_done = False
                                    logger.info("User clicked no in curing z-axis movement in curing station")
                                    self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence " \
                                                                                         "in curing station"
                                    return "Not Done"

                                elif catch_error == "Done":
                                    time.sleep(0.15)
                else:
                    while True:
                        if not ui.error_msg_response:
                            ui.error_msg_response = True
                            self.signals.call_MsgBox.emit("Alert", "Error occurred in curing z-axis", "Auto_sequence")
                            self.overall_result_list[
                                "Fixture offset remarks"] = "Error occurred in curing z-axis movement"
                            self.validation_done = False
                            return "Not Done"

            check = self.check_input_manually()
            if not check:
                logger.info("User clicked no in curing station")
                self.validation_done = False
                self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence " \
                                                                     "in curing station"
                return "Not Done"

            while "uv door close" not in self.loading_list:
                status = ui_plc_communication.plc_control_class.uv_door_close()
                if status == "Passed" or ui.bypass_option["UV door cylinder close"]:
                    self.signals.update_statusbar.emit("UV door & cylinder is closed")
                    self.loading_list.append("uv door close")
                    break
                else:
                    logger.error("Error in uv door close: {}".format(status))
                    time.sleep(0.05)
                    status_input = self.verify_input_status()
                    if status_input == "Done":
                        time.sleep(0.25)
                        status = ui_plc_communication.plc_control_class.uv_door_close()
                        if status == "Passed" or ui.bypass_option["UV door cylinder close"]:
                            self.signals.update_statusbar.emit("UV door & cylinder is closed")
                            self.loading_list.append("uv door close")
                            break
                        else:
                            self.validation_done = False
                            self.overall_result_list["Fixture offset remarks"] = "UV door closed failed"
                            return "Not Done"

                    elif status_input != "Done" and status_input != "Unable to read input status":
                        catch_error = self.catch_and_clear_error(status=status_input)
                        if catch_error == "Not Done":
                            self.validation_done = False
                            self.overall_result_list[
                                "Fixture offset remarks"] = "User cancelled the sequence in curing station"
                            return "Not Done"

                        elif catch_error == "Done":
                            time.sleep(0.15)

                    else:
                        while True:
                            if not ui.error_msg_response:
                                self.validation_done = False
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert", "Unable to read input status", "Auto_sequence")
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "Unable to get input status"
                                return "Not Done"
            else:
                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        self.signals.call_MsgBox.emit("Alert", "Error occurred in PLC", "Auto_sequence")
                        self.validation_done = False
                        self.overall_result_list[
                            "Fixture offset remarks"] = "Unable to move uv door close after 3 iter"
                        return "Not Done"

            status = ui_plc_communication.uv_control_class.write_values(int(ui.excel["UV intensity"]["Curing station"]),
                                                                        int(ui.excel["Curing Time"]["Curing station"]))
            logger.info(
                "Writing uv intensity is {} and delay is {}".format(int(ui.excel["UV intensity"]["Curing station"]),
                                                                    int(ui.excel["Curing Time"]["Curing station"])))
            if status == "Passed":
                logger.info("Uv values write successful")
                status = ui_plc_communication.uv_control_class.read_values()
                if status == "Passed":
                    logger.info("read the uv values")
                else:
                    logger.error("Error to read the uv values")
                    self.validation_done = False
                    self.overall_result_list["Fixture offset remarks"] = "Error to read the uv values"
                    return "Not Done"
            else:
                logger.error("Error in uv write values")
                self.validation_done = False
                self.overall_result_list["Fixture offset remarks"] = "Error in uv write values"
                return "Not Done"

            status = ui_plc_communication.uv_control_class.uv_power_on()
            if status == "Passed":
                self.signals.update_statusbar.emit("UV light is ON")
                logger.info("Uv power on successful")
                for x in reversed(range(int(ui.excel["Curing Time"]["Curing station"]) + 1)):
                    self.signals.update_statusbar.emit(f"{x} seconds left..")
                    time.sleep(1)

                self.signals.update_statusbar.emit("Uv curing is done.")

            else:
                logger.info("Uv power on failed")
                self.validation_done = False
                self.overall_result_list["Fixture offset remarks"] = "UV power on is failed."
                return "Not Done"

            while "uv door open reverse" not in self.loading_list:
                status = ui_plc_communication.plc_control_class.uv_door_open()
                if status == "Passed" or ui.bypass_option["UV door cylinder open"]:
                    self.signals.update_statusbar.emit("UV cylinder & door is opened")
                    self.loading_list.append("uv door open reverse")
                    break

                else:
                    logger.error("Error in uv door open: {}".format(status))
                    time.sleep(0.05)
                    status_input = self.verify_input_status()
                    if status_input == "Done":
                        status = ui_plc_communication.plc_control_class.uv_door_open()
                        if status == "Passed" or ui.bypass_option["UV door cylinder open"]:
                            self.signals.update_statusbar.emit("UV cylinder & door is opened")
                            self.loading_list.append("uv door open reverse")
                            break
                        else:
                            self.validation_done = False
                            self.overall_result_list[
                                "Fixture offset remarks"] = "Uv door open failed"
                            return "Not Done"

                    elif status_input != "Done" and status_input != "Unable to read input status":
                        catch_error = self.catch_and_clear_error(status=status_input)
                        if catch_error == "Not Done":
                            self.validation_done = False
                            self.overall_result_list[
                                "Fixture offset remarks"] = "User cancelled the sequence in curing station"
                            return "Not Done"

                        elif catch_error == "Done":
                            time.sleep(0.15)

                    else:
                        while True:
                            if not ui.error_msg_response:
                                self.validation_done = False
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert", "Unable to read input status", "Auto_sequence")
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "Unable to get input status"
                                return "Not Done"

            else:
                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        self.signals.call_MsgBox.emit("Alert", "Error occurred in PLC", "Auto_sequence")
                        self.overall_result_list[
                            "Fixture offset remarks"] = "Unable to move gripper after 3 iter"
                        self.validation_done = False
                        return "Not Done"

            time.sleep(0.05)
            check = self.check_input_manually()
            if not check:
                logger.info("User clicked no in curing station")
                self.validation_done = False
                self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence " \
                                                                     "in curing station"
                return "Not Done"

            if self.curing_z_movement_status == "Done":
                self.thread_stop = True
                self.signals.update_statusbar.emit("Curing z-axis movement is completed")
                self.loading_list.append("curing z-axis reverse")
                end_now = datetime.datetime.now()
                end_time = end_now.strftime("%H:%M:%S")
                logger.info("Curing station end time: {}".format(end_time))
                diff = end_now - start_now
                logger.info("Overall curing station taken time is: {} seconds\n".format(diff.total_seconds()))
                self.overall_result_list["curing_station"] = "Passed"
                return "Done"
            else:
                count = 0
                while "curing z-axis reverse" not in self.loading_list and count < 3:
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(4)
                    logger.info('Read curing z axis value: {}'.format(actual_value))
                    if actual_value == float(ui.curing_z_reverse_value):
                        self.thread_stop = True
                        self.signals.update_statusbar.emit("Curing z-axis movement is completed")
                        self.loading_list.append("curing z-axis reverse")
                        end_now = datetime.datetime.now()
                        end_time = end_now.strftime("%H:%M:%S")
                        logger.info("Curing station end time: {}".format(end_time))
                        diff = end_now - start_now
                        logger.info("Overall curing station taken time is: {} seconds\n".format(diff.total_seconds()))
                        self.overall_result_list["curing_station"] = "Passed"
                        return "Done"
                    else:
                        if ui.abort_auto_sequence_clicked:
                            self.validation_done = False
                            ui.validation_clicked = False
                            self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                                 "abort button."
                            gc.collect()
                            return "Not Done"
                        status = ui_plc_communication.modbus_class.actuator_movement(4,
                                                                                     float(ui.excel[
                                                                                               "Z-Actuator reverse Curing"][
                                                                                               "Curing station"]))
                        if status == "Passed":
                            self.thread_stop = True
                            self.signals.update_statusbar.emit("Curing z-axis movement is completed")
                            self.loading_list.append("curing z-axis reverse")
                            end_now = datetime.datetime.now()
                            end_time = end_now.strftime("%H:%M:%S")
                            logger.info("Curing station end time: {}".format(end_time))
                            diff = end_now - start_now
                            logger.info(
                                "Overall curing station taken time is: {} seconds\n".format(diff.total_seconds()))
                            self.overall_result_list["curing_station"] = "Passed"
                            return "Done"

                        else:
                            self.thread_stop = True
                            alarm_check = ui_plc_communication.modbus_class.alarm_display(4)
                            logger.error("Error in curing z-axis reverse movement: {}".format(status))
                            if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                                while True:
                                    if not ui.error_msg_response:
                                        ui.error_msg_response = True
                                        self.signals.call_MsgBox.emit("Alert", f"{alarm_check}", "Auto_sequence")
                                        logger.error(
                                            f"Error occurred while z-axis movement in curing station :{status}")
                                        self.overall_result_list["Fixture offset remarks"] = f"{alarm_check}"
                                        self.validation_done = False
                                        return "Not Done"

                            elif alarm_check != "Passed":
                                catch_error = self.catch_and_clear_error(status=alarm_check)
                                if catch_error == "Not Done":
                                    logger.info("User clicked no in curing z-axis reverse movement")
                                    self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence " \
                                                                                         "in curing station"
                                    self.validation_done = False
                                    return "Not Done"

                                elif catch_error == "Done":
                                    time.sleep(0.15)
                else:
                    while True:
                        if not ui.error_msg_response:
                            ui.error_msg_response = True
                            self.signals.call_MsgBox.emit("Alert", "Error occurred in curing z-axis reverse movement",
                                                          "Auto_sequence")
                            self.overall_result_list[
                                "Fixture offset remarks"] = "Error occurred in curing z-axis reverse movement"
                            logger.info("Error occurred in curing z-axis movement")
                            self.validation_done = False
                            return "Not Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at curing_station function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at curing"
            return "Not Done"

    def go_to_focus_station(self, station="Relay station"):
        try:
            """
              This method is used to complete recheck focus station.
              param lists: None
              return: None
            """
            start_now = datetime.datetime.now()
            start_time = start_now.strftime("%H:%M:%S")
            logger.info("Recheck focus station start time: {}".format(start_time))
            self.loading_list = []
            self.signals.update_statusbar.emit("Moving to {} station".format(station))
            count = 0
            if station == "Relay station":
                x_actuator = "X-Actuator Relay"
                y_actuator = "Y-Actuator Relay"
            else:
                x_actuator = "X-Actuator Collimator"
                y_actuator = "Y-Actuator Collimator"

            if ui.abort_auto_sequence_clicked:
                self.validation_done = False
                ui.validation_clicked = False
                self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                     "abort button."
                gc.collect()
                return "Not Done"

            while "y_moved to focus_station" not in self.loading_list and count < 3:
                status = self.parallel_x_y(position_x=float(ui.excel[x_actuator][station]),
                                           position_y=float(ui.excel[y_actuator][station]))
                if status == "Done":
                    self.loading_list.append("y_moved to focus_station")
                    if station == "Relay":
                        self.signals.update_station_position.emit(4)
                    else:
                        self.signals.update_station_position.emit(3)

                    end_now = datetime.datetime.now()
                    end_time = end_now.strftime("%H:%M:%S")
                    logger.info("Recheck Focus station end time: {}".format(end_time))
                    diff = end_now - start_now
                    logger.info("Time taken to reach recheck focus station: {} seconds\n".format(
                        diff.total_seconds()))
                    break

                else:
                    if status == "x_failed":
                        alarm_check = ui_plc_communication.modbus_class.alarm_display(5)
                    else:
                        alarm_check = ui_plc_communication.modbus_class.alarm_display(1)

                    logger.error("Error in actuator movement: {}".format(alarm_check))
                    if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                        while True:
                            if not ui.error_msg_response:
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert", f"{status}", "Auto_sequence")
                                logger.error(
                                    f"Error occurred while parallel x and y movement in focus recheck station :{status}")
                                self.overall_result_list["Fixture offset remarks"] = f"{status}"
                                self.validation_done = False
                                return "Not Done"

                    elif alarm_check != "Passed":
                        catch_error = self.catch_and_clear_error(status=alarm_check)
                        if catch_error == "Not Done":
                            logger.info("User clicked no in parallel x and y movement in focus recheck station")
                            self.validation_done = False
                            self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence " \
                                                                                 "in focus recheck station"
                            return "Not Done"

                        elif catch_error == "Done":
                            time.sleep(0.15)
            else:
                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        self.signals.call_MsgBox.emit("Alert", "Error occurred in actuator "
                                                               "movement in focus recheck station",
                                                      "Auto_sequence")
                        self.validation_done = False
                        self.overall_result_list[
                            "Fixture offset remarks"] = "Error occurred in x&y movement in focus recheck station"
                        logger.error("Error occurred in actuator movement in focus recheck station")
                        return "Not Done"

            if ui.excel["Fixture offset"][station]:
                status = self.check_center_offset(station, validation='after')
                if status == "Done":
                    return "Done"

                else:
                    self.signals.update_statusbar.emit("Unable to adjust offset")
                    return "Failed"
            else:
                return "Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at go_to_focus_station function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                      exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at go to focus"
            return "Not Done"

    def unloading(self):
        try:
            """
              This method is used to unload the module.
              param lists: None
              return: None
            """
            self.start_ip_check = False
            start_now = datetime.datetime.now()
            start_time = start_now.strftime("%H:%M:%S")
            logger.info("Unloading start time: {}".format(start_time))
            self.loading_list = []
            count = 0
            ui.main_page_abort_btn.setEnabled(False)
            while "unload_y_moved" not in self.loading_list and count < 3:
                unload_x_y_status = self.parallel_x_y(
                    position_x=float(ui.excel["X-Actuator Loading"]["Loading station"]),
                    position_y=float(ui.excel["Y-Actuator Loading"]["Loading station"]))
                if unload_x_y_status == "Done":
                    self.start_ip_check = False
                    self.loading_list.append("unload_y_moved")
                    self.signals.update_station_position.emit(1)
                    break

                else:
                    count += 1
                    self.start_ip_check = False
                    if unload_x_y_status == "x_failed":
                        alarm_check = ui_plc_communication.modbus_class.alarm_display(5)
                    else:
                        alarm_check = ui_plc_communication.modbus_class.alarm_display(1)
                    logger.error("Error in actuator movement: {}".format(alarm_check))
                    if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                        while True:
                            if not ui.error_msg_response:
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert", f"{unload_x_y_status}", "Auto_sequence")
                                logger.error(
                                    f"Error occurred while parallel x and y movement in unloading station :{unload_x_y_status}")
                                self.overall_result_list["Fixture offset remarks"] = f"{unload_x_y_status}"
                                return "Not Done"

                    elif alarm_check != "Passed":
                        catch_error = self.catch_and_clear_error(alarm_check, retry_skip="Yes")
                        if catch_error == "Done":
                            time.sleep(0.15)
            else:
                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        self.signals.call_MsgBox.emit("Alert",
                                                      "Error occurred in actuator movement in unloading station",
                                                      "Auto_sequence")
                        self.overall_result_list[
                            "Fixture offset remarks"] = "Error occurred in actuator movement in unloading station"
                        logger.error("Error occurred in actuator movement in unloading station")
                        return "Not Done"

            count = 0
            self.start_ip_check = False
            time.sleep(0.15)
            while "plc init done" not in self.loading_list and count < 3:
                t1 = threading.Thread(target=self.plc_init_func)
                t2 = threading.Thread(target=self.front_door_close_open, args=("open",))
                t3 = threading.Thread(target=self.update_all_results)
                t1.start()
                t2.start()
                t3.start()
                t1.join()
                t2.join()
                if self.plc_init_status == "Done" and self.front_door_status == "Passed":
                    self.loading_list.append("plc init done")
                    return "Done"

                else:
                    count += 1
                    if self.plc_init_status != "Done":
                        logger.error("Plc init failed")

                    if self.front_door_status != "Passed":
                        logger.error("Front door open failed")
            else:
                self.overall_result_list["Fixture offset remarks"] = "Plc init failed"
                logger.error("Plc init failed")
                return "Not Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at unloading function: {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at unloading func"
            return "Not Done"

    def update_all_results(self):
        try:
            """
              This method is used to emit the mtf results and images.
              param lists: None
              return: None
            """
            if not self.is_result_updated:
                seq_end_now = datetime.datetime.now()
                end_time = seq_end_now.strftime("%H:%M:%S")
                if self.camera_connected:
                    if self.validation_done == "Failed" or not self.validation_done:
                        self.overall_result_list["result"] = "Failed"
                    else:
                        self.overall_result_list["result"] = "Passed"

                    if self.overall_result_list["Fixture offset remarks"] != "":
                        self.signals.cycle_result.emit(self.overall_result_list["result"])
                        self.signals.update_excel.emit(self.overall_info, end_time, self.overall_result_list,
                                                       self.validation_done)
                        self.signals.update_statusbar.emit(self.overall_result_list["Fixture offset remarks"])
                else:
                    self.signals.cycle_result.emit("Failed")
                    self.overall_result_list["Fixture offset remarks"] = "Camera not connected."
                    self.overall_result_list["result"] = "Failed"
                    self.signals.update_excel.emit(self.overall_info, end_time, self.overall_result_list,
                                                   self.validation_done)
                    self.signals.update_statusbar.emit("Camera not connected")

                logger.info("Auto sequence end-time: {}".format(end_time))
                diff = seq_end_now - ui.start_val_time_now
                logger.info("Overall auto sequence taken time is: {} seconds".format(diff.total_seconds()))
                logger.info("Overall auto sequence taken time is: {} minutes {:.2f} seconds\n".
                            format(diff.total_seconds() // 60, diff.total_seconds() % 60))
                self.signals.close_graph.emit()
                self.signals.close_MsgBox.emit()
                self.signals.call_ResetPreview.emit("Yes")
                self.is_result_updated = True
            else:
                return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at update_all_results function: {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def cure_glue_unloading(self):
        try:
            """
              This method is used to unload the module.
              param lists: None
              return: None
            """
            self.start_ip_check = False
            self.loading_list = []
            ui.main_page_abort_btn.setEnabled(False)
            while "uv door and light out" not in self.loading_list:
                status = ui_plc_communication.plc_control_class.uv_door_open()
                if status == "Passed" or ui.bypass_option["UV door cylinder open"]:
                    self.loading_list.append("uv door and light out")
                    self.signals.update_statusbar.emit("UV cylinder position is opened")
                    self.signals.update_station_position.emit(6)
                    break

                else:
                    logger.error("Error in uv_light out {}".format(status))
                    time.sleep(0.05)
                    status_input = self.verify_input_status()
                    if status_input == "Done":
                        status = ui_plc_communication.plc_control_class.uv_door_open()
                        if status == "Passed" or ui.bypass_option["UV door cylinder open"]:
                            self.loading_list.append("uv door and light out")
                            self.signals.update_statusbar.emit("UV cylinder position is opened")
                            self.signals.update_station_position.emit(6)
                            break
                        else:
                            logger.error("Uv door open failed while unloading.")
                            self.overall_result_list["Fixture offset remarks"] = "Uv door open failed while unloading."
                            return "Not Done"

                    elif status_input != "Done" and status_input != "Unable to read input status":
                        catch_error = self.catch_and_clear_error(status=status_input, retry_skip="yes")
                        if catch_error == "Done":
                            time.sleep(0.15)

                    else:
                        while True:
                            if not ui.error_msg_response:
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert", "Unable to read input status", "Auto_sequence")
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "Unable to get input status"
                                return "Not Done"
            else:
                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        logger.error("Error occurred in while UV light out")
                        self.signals.call_MsgBox.emit("Alert", "Error occurred in while UV light out", "Auto_sequence")
                        self.overall_result_list[
                            "Fixture offset remarks"] = "Error occurred in while UV light out"
                        return "Not Done"

            self.loading_list = []
            self.signals.update_statusbar.emit("Gluing init is in progress")
            self.signals.update_station_position.emit(5)
            while "gluing init" not in self.loading_list:
                status = ui_plc_communication.plc_control_class.gluing_init()
                if status == "Passed":
                    self.loading_list.append("gluing init")
                    self.signals.update_statusbar.emit("Gluing init completed")
                    break

                else:
                    logger.error("Error in uv_light out {}".format(status))
                    time.sleep(0.05)
                    status_input = self.verify_input_status()
                    if status_input == "Done":
                        time.sleep(0.25)
                        status = ui_plc_communication.plc_control_class.gluing_init()
                        if status == "Passed":
                            self.loading_list.append("gluing init")
                            self.signals.update_statusbar.emit("Gluing init completed")
                            break
                        else:
                            logger.info("Gluing init failed while unloading")
                            self.overall_result_list["Fixture offset remarks"] = "Gluing init failed while unloading"
                            return "Not Done"

                    elif status_input != "Done" and status_input != "Unable to read input status":
                        catch_error = self.catch_and_clear_error(status=status_input, retry_skip="yes")
                        if catch_error == "Done":
                            time.sleep(0.15)

                    else:
                        while True:
                            if not ui.error_msg_response:
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert", "Unable to read input status",
                                                              "Auto_sequence")
                                return "Not Done"
            else:
                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        self.signals.call_MsgBox.emit("Alert", "Error occurred in PLC", "Auto_sequence")
                        return "Not Done"
            count = 0
            while "unload_y_moved" not in self.loading_list and count < 3:
                status = self.parallel_x_y(position_x=ui.excel["X-Actuator Loading"]["Loading station"],
                                           position_y=ui.excel["Y-Actuator Loading"]["Loading station"])
                if status == "Done":
                    self.signals.update_station_position.emit(5)
                    self.loading_list.append("unload_y_moved")
                    self.signals.update_station_position.emit(1)
                    break

                else:
                    if status == "x_failed":
                        alarm_check = ui_plc_communication.modbus_class.alarm_display(5)
                    else:
                        alarm_check = ui_plc_communication.modbus_class.alarm_display(1)

                    logger.error("Error in actuator movement: {}".format(alarm_check))
                    if alarm_check != "Passed" and alarm_check != "Emergency pressed":
                        while True:
                            if not ui.error_msg_response:
                                ui.error_msg_response = True
                                self.signals.call_MsgBox.emit("Alert", f"{alarm_check}", "Auto_sequence")
                                logger.error(
                                    f"Error occurred while actuator movement in unloading station :{status}")
                                self.overall_result_list["Fixture offset remarks"] = f"{alarm_check}"
                                return "Not done"

                    elif alarm_check != "Passed":
                        catch_error = self.catch_and_clear_error(status=alarm_check, retry_skip="yes")
                        if catch_error == "Done":
                            time.sleep(0.05)

            count = 0
            self.start_ip_check = False
            time.sleep(0.15)
            while "plc init done" not in self.loading_list and count < 3:
                t1 = threading.Thread(target=self.plc_init_func)
                t2 = threading.Thread(target=self.front_door_close_open, args=("open",))
                t3 = threading.Thread(target=self.update_all_results)
                t1.start()
                t2.start()
                t3.start()
                t1.join()
                t2.join()
                if self.plc_init_status == "Done" and self.front_door_status == "Passed":
                    self.loading_list.append("plc init done")
                    return "Done"

                else:
                    count += 1
                    time.sleep(0.15)
                    if self.plc_init_status != "Done":
                        logger.error("Plc init failed")

                    if self.front_door_status != "Passed":
                        logger.error("Front door open failed")
            else:
                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        self.signals.call_MsgBox.emit("Alert", "Plc init failed", "Auto_sequence")
                        self.overall_result_list["Fixture offset remarks"] = "Plc init failed"
                        logger.error("Plc init failed")
                        return "Not Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at cure_glue_unloading function: {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.overall_result_list["Fixture offset remarks"] = "Error at cure unloading"
            return "Not Done"

    @staticmethod
    def adjust_gamma(image, gamma=1.0):
        try:
            """
              This method is used to adjust the gamma correction.
              param lists: image is object and gamma is float
              return: None
            """
            inv_gamma = 1.0 / gamma
            table = np.array([((i / 255.0) ** inv_gamma) * 255 for i in np.arange(0, 256)]).astype("uint8")
            return cv2.LUT(image, table)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at adjust_gamma function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))
            return None

    def connect_device(self):
        try:
            """
              This method is used to connect the camera.
              param lists: None
              return: None
            """
            logger.debug('clicked the get device button')
            self.signals.update_statusbar.emit('Camera is connecting...')
            ret, device_count = self.cap.getDevices()
            if not ret:
                logger.error("cap.getDevices Failed")
                self.camera_connected = False
                return

            logger.debug(f"Total Number of devices:{device_count}")
            if device_count == 0:
                t_end = time.time() + 10
                while time.time() < t_end:
                    ret, device_count = self.cap.getDevices()
                    if device_count != 0:
                        break
                else:
                    self.camera_connected = False
                    return

            for i in range(device_count):
                ret, device_name, vid, pid, device_path = self.cap.getDeviceInfo(i)
                logger.debug("Device name: {}; Camera name: {}".format(device_name, ui.camera_name))
                if not ret:
                    logger.error("cap.getDeviceInfo Failed")
                    self.camera_connected = False
                    return

                elif device_name == ui.camera_name:
                    self.cap = cv2.VideoCapture(0)
                    t_end = time.time() + 15
                    while time.time() < t_end:
                        try:
                            start = time.time()
                            ret, verify_frame = self.cap.read()
                            end = time.time()
                            if end - start < 0.25:
                                self.camera_connected = True
                                break
                        except Exception as e:
                            print(e)
                    else:
                        self.camera_connected = False
                        return

                    if self.camera_connected:
                        self.eCAM_dll = ctypes.cdll.LoadLibrary("eCAMFwSw.dll")
                        if not self.eCAM_dll:
                            logger.error("eCAM_dll is not working")
                            self.signals.call_MsgBox.emit("Enumeration Failed!", "eCAM_dll is not working",
                                                          "Critical")
                            self.camera_connected = False
                            return

                        else:
                            self.eCAM_dll.InitExtensionUnit(device_path)
                        ret, total_formats = self.cap.getFormats()
                        if not ret:
                            logger.error("cap.getFormats Failed")
                            self.camera_connected = False
                            return

                        for cnt in range(total_formats):
                            ret, self.format_type, width, height, self.fps = self.cap.getFormatType(cnt)
                            if not ret:
                                logger.error("cap.getFormatType Failed")
                                self.camera_connected = False
                                return

                            else:
                                if width == int(ui.resolution[0]) and height == int(ui.resolution[1]) and \
                                        self.format_type in ["UYVY", "YUY2", "Y16", "Y12"]:
                                    if not self.cap.setFormatType(cnt):
                                        logger.error("cap.setFormatType Failed")
                                        self.camera_connected = False
                                        return

                                    if not self.cap.set(cv2.CAP_PROP_CONVERT_RGB, 0):
                                        logger.error("Failed to set CAP_PROP_CONVERT_RGB to False")
                                        self.camera_connected = False
                                        return

                                    else:
                                        time.sleep(0.5)
                                        if ui.expo == 'Auto':
                                            if self.cap.set(cv2.CAP_PROP_EXPOSURE, 1):
                                                logger.debug('exposure value: Auto')
                                            else:
                                                logger.error('CAP_PROP_EXPOSURE is Failed')
                                                self.camera_connected = False
                                                return
                                        else:
                                            if ui.camera_name == "See3CAM_CU81":
                                                hdr = self.eCAM_dll.SetCAMModeCU81(2)
                                                if not hdr:
                                                    logger.error("SetCAMModeCU81 failed")
                                                    self.camera_connected = False
                                                    return
                                                else:
                                                    logger.info(f"\n\t SetCAMModeCU81 succeeded")
                                            if self.cap.set(cv2.CAP_PROP_EXPOSURE, int(ui.expo), 2):
                                                logger.debug(
                                                    'exposure value: {}'.format(
                                                        self.cap.get(cv2.CAP_PROP_EXPOSURE)))
                                            else:
                                                logger.error('CAP_PROP_EXPOSURE is Failed')
                                                self.camera_connected = False
                                                return

                                        self.camera_connected = True
                                        return

                                elif width == int(ui.resolution[0]) and height == int(ui.resolution[1]) \
                                        and self.format_type == 'Y8':
                                    if not self.cap.setFormatType(cnt):
                                        logger.error("cap.setFormatType Failed")
                                        self.camera_connected = False
                                        return

                                    self.cap.set(cv2.CAP_PROP_CONVERT_RGB, 1)

                                    if ui.expo == 'Auto':
                                        if self.cap.set(cv2.CAP_PROP_EXPOSURE, 1):
                                            logger.debug('exposure value: Auto')
                                        else:
                                            logger.error('CAP_PROP_EXPOSURE is Failed')
                                            self.camera_connected = False
                                            return
                                    else:
                                        if self.cap.set(cv2.CAP_PROP_EXPOSURE, int(ui.expo), 2):
                                            logger.debug(
                                                'exposure value: {}'.format(self.cap.get(cv2.CAP_PROP_EXPOSURE)))
                                        else:
                                            logger.error('CAP_PROP_EXPOSURE is Failed')
                                            self.camera_connected = False
                                            return

                                    self.camera_connected = True
                                    return
                        else:
                            logger.info("Expected Format or resolution is not available")
                            self.camera_connected = False
                            return
            else:
                logger.info("Expected device is not connected")
                self.camera_connected = False
                return

        except cv2.error as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at connect_device function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.camera_connected = False
            return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at connect_device function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.camera_connected = False
            self.validation_done = False
            ui.validation_clicked = False
            self.overall_result_list["Fixture offset remarks"] = "Error at connect device"
            return

    def calculation(self):
        try:
            """
              This method is used to calculate the median.
              param lists: None
              return: None
            """
            average_results = []
            max_results = []
            min_results = []
            median = []
            for i in range(len(self.final_outputs[0])):
                dummy = []
                for j in range(len(self.final_outputs)):
                    dummy.append(self.final_outputs[j][i])
                dummy.sort()

                median.append(np.median(dummy))
                max_results.append(np.max(dummy))
                min_results.append(np.min(dummy))
                average_results.append(np.mean(dummy))
            self.final_outputs = []
            return median

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at calculation function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.validation_done = False
            ui.validation_clicked = False
            self.overall_result_list["Fixture offset remarks"] = "Error at MTF calculation"
            return

    def thread_median_cal(self, frame):
        try:
            """
              This method is used to mtf Roi selection.
              param lists: None
              return: None
            """
            result = []
            try:
                # Another config
                self.black_threshold, self.white_threshold = (int(ui.mtf_excel["Clipping"].split(',')[0]),
                                                              int(ui.mtf_excel["Clipping"].split(',')[1]))
            except:
                self.black_threshold, self.white_threshold = ui.mtf_excel["Clipping"].split(',')[0], \
                    ui.mtf_excel["Clipping"].split(',')[1]
            self.image_roi = mtf.ROISelection(input_image=self.processed_frame, cropped_area_coordinate=ui.rois,
                                              setup=ui.setup_type, roi_frame=frame)

            roi_count = 0
            for r, s in self.image_roi.cropped_roi.items():
                roi_count += 1
                if s:
                    if not self.black_threshold == 'NA' and not self.white_threshold == 'NA':
                        if not self.check_clipping:
                            for region in self.image_roi.cropped_roi.keys():
                                for roi in range(len(self.image_roi.cropped_roi[region])):
                                    if np.min(self.image_roi.cropped_roi[region][roi][
                                                  'roi_img']) < self.black_threshold or np.max(
                                        self.image_roi.cropped_roi['C'][roi]['roi_img']) > self.white_threshold:

                                        """Add popup"""
                                        self.check_clipping = True
                                        ui.validation_clicked = False
                                        self.validation_done = False
                                        self.overall_result_list["Fixture offset remarks"] = ("Found clipping on the "
                                                                                              "frame, plz adjust the "
                                                                                              "lux&exposure.")
                                        while True:
                                            if not ui.error_msg_response:
                                                ui.error_msg_response = True
                                                self.signals.call_MsgBox.emit("Alert",
                                                                              "Found clipping on the frame, Kindly adjust the lux and exposure values accordingly. ",
                                                                              "Auto_sequence")
                                                return
                                    else:
                                        self.check_clipping = True

                    self.final_result = mtf.MTFCalculation(ui.mtf_excel["Raw FW"].split(",")[0],
                                                           roi_list=self.image_roi.cropped_roi,
                                                           all_channel=False)  # Another config
                    break

                else:
                    logger.error('MTF ROI are not detected')
                    display_image = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)

            try:
                roi_list = ["TL", "TR", "C", "BL", "BR"]
                length_roi_list = [len(self.final_result.roi_mtf_value[i]) for i in roi_list]
                tl = [round(self.final_result.roi_mtf_value['TL'][i]['roi_lum']['mtf50'], 3) for i in
                      range(length_roi_list[0])]
                tr = [round(self.final_result.roi_mtf_value['TR'][i]['roi_lum']['mtf50'], 3) for i in
                      range(length_roi_list[1])]
                c = [round(self.final_result.roi_mtf_value['C'][i]['roi_lum']['mtf50'], 3) for i in
                     range(length_roi_list[2])]
                bl = [round(self.final_result.roi_mtf_value['BL'][i]['roi_lum']['mtf50'], 3) for i in
                      range(length_roi_list[3])]
                br = [round(self.final_result.roi_mtf_value['BR'][i]['roi_lum']['mtf50'], 3) for i in
                      range(length_roi_list[4])]
                for i in tl, tr, c, bl, br:
                    result.append(i)
                result_to_avg = sum(result, [])
                self.final_outputs.append(result_to_avg)
                result = []

            except Exception as e:
                pass

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at thread_median_cal function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.validation_done = False
            ui.validation_clicked = False
            self.overall_result_list["Fixture offset remarks"] = "Error at MTF calculation"
            return

    def channel_normalization(self, y8_frame):
        try:
            """Read RGB values as list from config file
            self.rgb_values[0] - R, self.rgb_values[1] - G, self.rgb_valuFes[2] - B and get Bayer pattern as input"""

            blue_ratio = float(float(ui.rgb_values[1]) / float(ui.rgb_values[2]))
            red_ratio = float(float(ui.rgb_values[1]) / float(ui.rgb_values[0]))
            if ui.mtf_excel["Raw FW"].split(",")[1] == "GB":  # Another config
                """GRBG"""
                for y in range(y8_frame.shape[0]):
                    if y % 2 == 0:
                        y8_frame[y, 1:][::2] = (y8_frame[y, 1:][::2] * red_ratio).clip(0, 255)
                    elif y % 2 != 0:
                        y8_frame[y, :][::2] = (y8_frame[y, :][::2] * blue_ratio).clip(0, 255)

            elif ui.mtf_excel["Raw FW"].split(",")[1] == "BG":  # Another config
                """RGGB"""
                for y in range(y8_frame.shape[0]):
                    if y % 2 == 0:
                        y8_frame[y, :][::2] = (y8_frame[y, :][::2] * red_ratio).clip(0, 255)
                    elif y % 2 != 0:
                        y8_frame[y, 1:][::2] = (y8_frame[y, 1:][::2] * blue_ratio).clip(0, 255)
            return y8_frame

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at channel normalization function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.validation_done = False
            ui.validation_clicked = False
            self.overall_result_list["Fixture offset remarks"] = "Error at MTF calculation"
            return

    def read_frames(self):
        try:
            """
              This method is used to read the frames.
              param lists: None
              return: None
            """
            if self.cap.isOpened():
                ret, frame = self.cap.read()
                if ret:
                    if np.sum(frame) != 0:
                        self.gr_fr_rec = 0

                        if self.format_type == "UYVY":
                            frame = cv2.cvtColor(frame, cv2.COLOR_YUV2BGR_UYVY)

                        elif self.format_type == "YUY2":
                            frame = cv2.cvtColor(frame, cv2.COLOR_YUV2BGR_YUY2)

                        elif self.format_type == 'Y8':
                            self.withoutdb8bit = frame
                            if int(ui.mtf_excel["Black level sub"]) != 0:  # Another config
                                frame = self.black_level_subtraction(frame)
                            self.frame_to_cn = frame.copy()
                            """Add Black Level Subtraction before DB/CN for before option also add if condition for before and after
                            BLS."""
                            if ui.mtf_excel["Raw FW"].split(",")[0] == "CN":  # Another config
                                self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)

                            elif ui.mtf_excel["Raw FW"].split(",")[1] == "Monochrome":  # Another config
                                self.processed_frame = frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)

                            elif ui.mtf_excel["Raw FW"].split(",")[1] == 'No':  # Another config
                                green_only = np.zeros((frame.shape[0] // 2, frame.shape[1] // 2),
                                                      dtype=np.uint8)
                                for y in range(frame.shape[0]):
                                    if y % 2 == 0:
                                        green_only[y // 2, :] = frame[y, 1:][::2]

                                frame = cv2.cvtColor(green_only, cv2.COLOR_GRAY2BGR)
                                del green_only

                            elif ui.mtf_excel["Raw FW"].split(",")[1] == "RG":  # Another config
                                self.processed_frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_RG2BGR)

                            elif ui.mtf_excel["Raw FW"].split(",")[1] == "BG":  # Another config
                                self.processed_frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_BG2BGR)

                            elif ui.mtf_excel["Raw FW"].split(",")[1] == "GR":  # Another config
                                self.processed_frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_GR2BGR)

                            elif ui.mtf_excel["Raw FW"].split(",")[1] == "GB":  # Another config
                                self.processed_frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_GB2BGR)

                            if ui.mtf_excel["Raw FW"].split(",")[0] != "CN" and \
                                    ui.mtf_excel["Raw FW"].split(",")[1] != "Monochrome":  # Another config
                                frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)

                        elif self.format_type == 'Y16':
                            frame = cv2.convertScaleAbs(frame, 0.000000065)

                        elif self.format_type == "Y12":
                            raw_bytes = frame.tobytes()
                            filtered_bytes = np.frombuffer(raw_bytes, dtype=np.uint8)
                            filtered_bytes = np.reshape(filtered_bytes, (-1, 3))
                            filtered_bytes = np.delete(filtered_bytes, 2, 1)
                            filtered_bytes = np.reshape(filtered_bytes, -1)
                            y8_frame = np.zeros(shape=(int(ui.resolution[1]), int(ui.resolution[0])),
                                                dtype=np.uint8)
                            m = 0
                            for i in range(0, int(ui.resolution[1])):
                                y8_frame[i, :] = filtered_bytes[m:m + int(ui.resolution[0])]
                                m += int(ui.resolution[0])

                            self.withoutdb8bit = y8_frame
                            if int(ui.mtf_excel["Black level sub"]) != 0:  # Another config
                                frame = self.black_level_subtraction(y8_frame)

                            self.frame_to_cn = frame.copy()
                            """Add Black Level Subtraction before DB/CN for before option also add if condition for before and after
                            BLS."""
                            if ui.mtf_excel["Raw FW"].split(",")[0] == "CN":  # Another config
                                self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)

                            elif ui.mtf_excel["Raw FW"].split(",")[1] == "Monochrome":  # Another config
                                self.processed_frame = frame = cv2.cvtColor(y8_frame, cv2.COLOR_GRAY2BGR)

                            elif ui.mtf_excel["Raw FW"].split(",")[1] == 'No':
                                green_only = np.zeros((y8_frame.shape[0] // 2, y8_frame.shape[1] // 2),
                                                      dtype=np.uint8)
                                for y in range(y8_frame.shape[0]):
                                    if y % 2 == 0:
                                        green_only[y // 2, :] = y8_frame[y, 1:][::2]

                                frame = cv2.cvtColor(green_only, cv2.COLOR_GRAY2BGR)
                                del green_only

                            elif ui.mtf_excel["Raw FW"].split(",")[1] == "RG":  # Another config
                                self.processed_frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_RG2BGR)

                            elif ui.mtf_excel["Raw FW"].split(",")[1] == "BG":  # Another config
                                self.processed_frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_BG2BGR)

                            elif ui.mtf_excel["Raw FW"].split(",")[1] == "GR":  # Another config
                                self.processed_frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_GR2BGR)

                            elif ui.mtf_excel["Raw FW"].split(",")[1] == "GB":  # Another config
                                self.processed_frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_GB2BGR)

                            if ui.mtf_excel["Raw FW"].split(",")[0] != "CN" and \
                                    ui.excel["Raw FW"]["Loading"].split(",")[1] != "Monochrome":  # Another config
                                frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)
                            del y8_frame
                            del filtered_bytes

                        self.image = frame.copy()
                        if frame is not None:
                            return True, frame

                    else:
                        self.signals.update_statusbar.emit('Frame not received')
                        logger.error('Frame not received at read frames function, frame average is 0')
                        self.gr_fr_rec += 1
                        return "", ""

                else:
                    logger.error('Frame not received at read frames function ret false')
                    self.validation_done = False
                    self.overall_result_list["Fixture offset remarks"] = "Frame not received"
                    return False, ""

            else:
                logger.error('Frame not received at read frames function cap opened failed')
                self.validation_done = False
                self.overall_result_list["Fixture offset remarks"] = "Frame not received"
                return False, ""

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at read frames function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.validation_done = False
            ui.validation_clicked = False
            self.overall_result_list["Fixture offset remarks"] = "Error at read frames"
            return

    def black_level_subtraction(self, image):
        try:
            """
              This method is used to subtract the black level.
              param lists: image is object
              return: None
            """
            black_level = int(ui.mtf_excel["Black level sub"])  # Another config
            black_level_ratio = 255 / (255 - black_level)

            table = []
            for i in range(256):
                if (i - black_level) <= 0:
                    table.append(0)
                else:
                    table.append((i - black_level) * black_level_ratio)
            table = np.array(table, np.uint8)
            return cv2.LUT(image, table)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at black_level_subtraction function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.validation_done = False
            ui.validation_clicked = False
            self.overall_result_list["Fixture offset remarks"] = "Error at MTF calculation"
            return

    def streaming(self):
        """
          This method is used to rotation logic.
          param lists: None
          return: None
        """
        self.final_outputs = []
        self.gr_fr_rec = 0
        found_iteration_count = 0
        rotation_flag = None
        found_threshold = False
        self.getting_peak = False
        self.difference_stop = False
        regions_dict = {"C": [], "TL": [], "TR": [], "BL": [], "BR": []}
        getpeak_dict = {"C": 0, "TL": 0, "TR": 0, "BL": 0, "BR": 0}
        final_index = [None, None, None, None, None]
        check = []
        finetuning_threshold = float(ui.rotation_excel["MTF Tolerance to achieve peak"])  # Another config
        threshold_acheive_peak_rotation = False
        initial_mtf = 0
        calculate_rotation_time = time.time()
        if ui.setup_type == "Relay station":
            self.signals.update_station_position.emit(4)
        else:
            self.signals.update_station_position.emit(3)
        self.plc_thread()
        ret_false_count = 0
        find_empty_frame = 0
        try:
            while True:
                ret, frame = self.read_frames()
                if ret:
                    ret_false_count = 0
                    if ui.timer is False or ui.abort_auto_sequence_clicked:
                        self.validation_done = False
                        self.start_ip_check = False
                        ui.validation_clicked = False
                        self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                             "abort button."
                        del frame
                        gc.collect()
                        return "Not Done"

                    if not self.ip_status:
                        self.start_ip_check = False
                        if self.status_input == "Sequence abort":
                            self.validation_done = False
                            ui.validation_clicked = False
                            self.overall_result_list["Fixture offset remarks"] = "User cancelled the sequence using " \
                                                                                 "abort button."
                            del frame
                            gc.collect()
                            return "Not Done"

                        catch_error = self.catch_and_clear_error(status=self.status_input)
                        if catch_error == "Not Done":
                            del frame
                            gc.collect()
                            self.ip_status = False
                            ui.validation_clicked = False
                            self.overall_result_list[
                                "Fixture offset remarks"] = "User cancelled the sequence in while rotation"
                            return

                        elif catch_error == "Done":
                            time.sleep(1)
                            self.ip_status = True
                            self.plc_thread()

                        else:
                            del frame
                            gc.collect()
                            self.ip_status = False
                            ui.validation_clicked = False
                            self.overall_result_list[
                                "Fixture offset remarks"] = "Error occurred in catch & clear else case in streaming"
                            return

                    if ui.validation_clicked:
                        if initial_mtf < ui.c_mtf_threshold or not self.completed_basic_rotation:
                            caluclatable_frames = 1
                            if found_threshold:
                                caluclatable_frames = int(ui.mtf_excel["Median frames count"])  # Another config
                        else:
                            caluclatable_frames = int(ui.mtf_excel["Live Median frames count"])  # Another config

                        try:
                            self.frames_append = []
                            for nof_calculatableFrames in range(caluclatable_frames):
                                if ret:
                                    self.frames_append.append(frame)
                            for i in range(caluclatable_frames):
                                self.thread_median_cal(self.frames_append[i])

                        except Exception as e:
                            logger.debug("error caught and skipped in thread median time")
                            find_empty_frame += 1
                            for i in range(int(self.fps)):
                                _, __ = self.cap.read()
                            if find_empty_frame == 10:
                                self.start_ip_check = False
                                ui.validation_clicked = False
                                self.validation_done = False
                                excel_info = []
                                for label in ui.rois.keys():
                                    if self.before_glue[label] == 0:
                                        excel_info.append('NA')
                                    else:
                                        excel_info.append(self.before_glue[label])

                                if self.before_glue['All'] == 0:
                                    excel_info.append("NA")
                                else:
                                    excel_info.append(self.before_glue['All'])

                                self.overall_info.append(excel_info)
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "Error at MTF calculation"
                                self.signals.call_MsgBox.emit("Alert!", "Error at MTF calculation",
                                                              "Critical_peak")
                                logger.debug("We can't able to detect the SFR reg ROIs.")
                                del frame
                                gc.collect()
                                return  # break the while loop
                            continue

                        try:
                            median = self.calculation()
                            roi_list = ["TL", "TR", "C", "BL", "BR"]
                            length_roi_list = [len(self.final_result.roi_mtf_value[i]) for i in roi_list]
                            length = 0
                            for index, i in enumerate(length_roi_list):
                                for j in range(i):
                                    self.final_result.roi_mtf_value[roi_list[index]][j]['roi_lum']['mtf50'] = \
                                        median[length]
                                    length += 1

                        except Exception as e:
                            logger.debug("error caught and skipped in calculation time")
                            find_empty_frame += 1
                            for i in range(int(self.fps)):
                                _, __ = self.cap.read()
                            if find_empty_frame == 10:
                                self.start_ip_check = False
                                ui.validation_clicked = False
                                self.validation_done = False
                                excel_info = []
                                for label in ui.rois.keys():
                                    if self.before_glue[label] == 0:
                                        excel_info.append('NA')
                                    else:
                                        excel_info.append(self.before_glue[label])

                                if self.before_glue['All'] == 0:
                                    excel_info.append("NA")
                                else:
                                    excel_info.append(self.before_glue['All'])

                                self.overall_info.append(excel_info)
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "We can't able to detect the SFR reg ROIs."
                                self.signals.call_MsgBox.emit("Alert!", "We can't able to detect the SFR reg ROIs.",
                                                              "Critical_peak")
                                logger.debug("We can't able to detect the SFR reg ROIs.")
                                del frame
                                gc.collect()
                                return  # break the while loop
                            continue

                        if self.image_roi.image.shape[0] > 1440:
                            overall_avg = []
                            for roi_position, regions in self.final_result.roi_mtf_value.items():
                                if regions:
                                    roi_avg = []
                                    for i in range(len(regions)):
                                        try:
                                            roi_avg.append(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3))
                                            cv2.putText(self.image_roi.image, 'Reg:{}'.format(i + 1),
                                                        (
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][1] + 0),
                                                        cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0),
                                                        2, cv2.LINE_AA)
                                            cv2.putText(self.image_roi.image, '{}'.format(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3)),
                                                        (
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][1] + 45),
                                                        cv2.FONT_HERSHEY_SIMPLEX, 1.2,
                                                        (0, 255, 0), 2,
                                                        cv2.LINE_AA)
                                        except KeyError:
                                            logger.debug("MTF50 value is empty")

                                    if len(roi_avg) != 0:
                                        cv2.putText(self.image_roi.image, 'Avg: {}'.format(
                                            round(sum(roi_avg) / len(roi_avg), 3)),
                                                    (ui.rois[roi_position][3] - 220,
                                                     ui.rois[roi_position][0] + 45),
                                                    cv2.FONT_HERSHEY_SIMPLEX, 1.2,
                                                    (0, 255, 0), 2, cv2.LINE_AA)

                                        overall_avg.append(round(sum(roi_avg) / len(roi_avg), 3))
                                        self.mtf_roi_avg[roi_position].append(
                                            round(sum(roi_avg) / len(roi_avg), 3))

                                    else:
                                        self.mtf_roi_avg[roi_position].append(0)
                                else:
                                    self.mtf_roi_avg[roi_position].append(0)

                            if len(overall_avg) != 0:
                                self.mtf_roi_avg['All'].append(
                                    round(sum(overall_avg) / len(overall_avg), 3))
                                cv2.putText(self.image_roi.image, 'Overall Avg: {}'.format(
                                    round(sum(overall_avg) / len(overall_avg), 3)),
                                            (25, 45), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 2,
                                            cv2.LINE_AA)
                                display_image = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)

                            else:
                                self.mtf_roi_avg['All'].append(0)

                        else:
                            overall_avg = []
                            for roi_position, regions in self.final_result.roi_mtf_value.items():
                                if regions:
                                    roi_avg = []
                                    for i in range(len(regions)):
                                        try:
                                            roi_avg.append(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3))
                                            cv2.putText(self.image_roi.image, 'Reg:{}'.format(i + 1),
                                                        (
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][1] + 0),
                                                        cv2.FONT_HERSHEY_SIMPLEX, .5, (0, 255, 0),
                                                        2,
                                                        cv2.LINE_AA)
                                            cv2.putText(self.image_roi.image, '{}'.format(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3)),
                                                        (
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][1] + 45),
                                                        cv2.FONT_HERSHEY_SIMPLEX, .7, (0, 255, 0),
                                                        2,
                                                        cv2.LINE_AA)
                                        except KeyError:
                                            logger.debug("MTF50 value is empty")

                                    if len(roi_avg) != 0:
                                        cv2.putText(self.image_roi.image, 'Avg: {}'.format(
                                            round(sum(roi_avg) / len(roi_avg), 3)),
                                                    (ui.rois[roi_position][3] - 150,
                                                     ui.rois[roi_position][0] + 35),
                                                    cv2.FONT_HERSHEY_SIMPLEX, .9, (0, 255, 0), 2,
                                                    cv2.LINE_AA)
                                        overall_avg.append(round(sum(roi_avg) / len(roi_avg), 3))
                                        self.mtf_roi_avg[roi_position].append(round(sum(roi_avg) / len(roi_avg), 3))

                                    else:
                                        self.mtf_roi_avg[roi_position].append(0)

                                else:
                                    self.mtf_roi_avg[roi_position].append(0)

                            if len(overall_avg) != 0:
                                self.mtf_roi_avg['All'].append(
                                    round(sum(overall_avg) / len(overall_avg), 3))
                                cv2.putText(self.image_roi.image, 'Overall Avg: {}'.format(
                                    round(sum(overall_avg) / len(overall_avg), 3)),
                                            (25, 45), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 2,
                                            cv2.LINE_AA)
                                display_image = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)

                            else:
                                self.mtf_roi_avg['All'].append(0)

                        logger.debug("MTF average C list: {}".format(self.mtf_roi_avg["C"]))
                        logger.debug("MTF average TL list: {}".format(self.mtf_roi_avg["TL"]))
                        logger.debug("MTF average TR list: {}".format(self.mtf_roi_avg["TR"]))
                        logger.debug("MTF average BL list: {}".format(self.mtf_roi_avg["BL"]))
                        logger.debug("MTF average BR list: {}".format(self.mtf_roi_avg["BR"]))

                        """Below condition is to break the loop when the mtF value is in between 0.0 to 0.01"""
                        if 0 <= self.mtf_roi_avg["C"][-1] <= 0.01:
                            self.start_ip_check = False
                            ui.validation_clicked = False
                            self.validation_done = False
                            excel_info = []
                            for label in ui.rois.keys():
                                if self.before_glue[label] == 0:
                                    excel_info.append('NA')
                                else:
                                    excel_info.append(self.before_glue[label])

                            if self.before_glue['All'] == 0:
                                excel_info.append("NA")
                            else:
                                excel_info.append(self.before_glue['All'])
                            self.overall_info.append(excel_info)
                            self.overall_result_list[
                                "Fixture offset remarks"] = "We can't able to detect the SFR reg ROIs."
                            self.signals.call_MsgBox.emit("Alert!", "We can't able to detect the SFR reg ROIs.",
                                                          "Critical_peak")
                            logger.debug("We can't able to detect the SFR reg ROIs.")
                            del frame
                            gc.collect()
                            break  # break the while loop

                        """Below condition is to break the loop after the give time when the peak is not achieved"""
                        if int(time.time()) - int(calculate_rotation_time) >= int(
                                ui.rotation_excel["Rotation break time"]):  # Another config
                            excel_info = []
                            for label in ui.rois.keys():
                                if self.before_glue[label] == 0:
                                    excel_info.append('NA')
                                else:
                                    excel_info.append(self.before_glue[label])

                            if self.before_glue['All'] == 0:
                                excel_info.append("NA")
                            else:
                                excel_info.append(self.before_glue['All'])
                            self.overall_info.append(excel_info)
                            self.overall_result_list["Fixture offset remarks"] = "We can't able to get the peak."
                            logger.debug("We can't able to detect the SFR reg ROIs.")
                            self.signals.call_MsgBox.emit("Alert!", "We can't able to get the peak", "Critical_peak")
                            logger.debug("Time out for rotation")
                            self.validation_done = False
                            self.start_ip_check = False
                            ui.validation_clicked = False
                            del frame
                            gc.collect()
                            break  # break the while loop

                            """Below condition is used to find minimum focus"""
                        elif len(self.mtf_roi_avg["C"]) != 0 and self.achieve_min_focus:
                            if not self.find_clkwise:
                                if self.clockwise.upper() == "YES":

                                    self.rotation_dir = "clockwise"

                                elif self.clockwise.upper() == "NO":
                                    self.rotation_dir = "anticlockwise"
                                else:
                                    self.rotation_dir = "clockwise"
                                self.rotation = float(
                                    ui.rotation_excel["Basic clockwise rotation"])  # Another config

                            if len(self.mtf_roi_avg["C"]) > 1 and self.mtf_roi_avg["C"][-2] > self.mtf_roi_avg["C"][-1]:

                                if 0.05 < self.mtf_roi_avg["C"][-1] < 0.1:
                                    self.achieve_min_focus = False

                                elif self.mtf_roi_avg["C"][-1] < 0.05 and self.mtf_roi_avg["C"][-2] > \
                                        self.mtf_roi_avg["C"][-1]:
                                    if self.clockwise.upper() == "YES":
                                        self.rotation_dir = "anticlockwise"
                                    elif self.clockwise.upper() == "NO":
                                        self.rotation_dir = "clockwise"
                                    else:
                                        self.rotation_dir = "anticlockwise"
                                    self.find_clkwise = True

                            elif len(self.mtf_roi_avg["C"]) > 1 and self.find_clkwise and self.mtf_roi_avg["C"][-2] < \
                                    self.mtf_roi_avg["C"][-1] and 0.05 < self.mtf_roi_avg["C"][-1] < 0.07:
                                self.achieve_min_focus = False

                        if self.mtf_roi_avg["C"][
                            -1] < ui.c_mtf_threshold and not self.achieve_min_focus and not self.completed_basic_rotation:
                            if self.clockwise.upper() == "YES":
                                self.rotation_dir = "anticlockwise"
                            elif self.clockwise.upper() == "NO":
                                self.rotation_dir = "clockwise"
                            else:
                                self.rotation_dir = "anticlockwise"
                            self.rotation = float(
                                ui.rotation_excel["Basic anticlockwise rotation"])  # Another config

                        """Below condition is to rotate for the given region."""
                        if ui.consider_focus_chart_flag:  # Another config
                            if ui.c_mtf_threshold < self.mtf_roi_avg[ui.consider_focus_chart][-1] and len(
                                    self.mtf_roi_avg[ui.consider_focus_chart]) > 1 and not self.achieve_min_focus:
                                """Set peak"""
                                self.completed_basic_rotation = True
                                found_iteration_count += 1
                                self.enter_threshold = True

                                if self.mtf_roi_avg[ui.consider_focus_chart][-1] > self.get_peak_value:
                                    self.get_peak_value = self.mtf_roi_avg[ui.consider_focus_chart][-1]
                                    self.rotation = float(
                                        ui.rotation_excel["Threshold anticlockwise rotation"])  # Another config
                                    if self.rotation_dir == "clockwise":
                                        rotation_flag = True
                                        self.rotation_dir = "clockwise"

                                    else:
                                        rotation_flag = False
                                        self.rotation_dir = "anticlockwise"

                                else:
                                    """Get back to peak"""
                                    if abs(self.get_peak_value - self.mtf_roi_avg[ui.consider_focus_chart][
                                        -1]) >= float(
                                        ui.rotation_excel["MTF Tolerance tofind peak"]):  # Another config
                                        found_threshold = True

                                    else:
                                        if not found_threshold:

                                            self.rotation = float(
                                                ui.rotation_excel["Threshold anticlockwise rotation"])  # Another config
                                            if self.rotation_dir == "clockwise":
                                                rotation_flag = True
                                                self.rotation_dir = "clockwise"
                                            else:
                                                rotation_flag = False
                                                self.rotation_dir = "anticlockwise"

                                            if self.mtf_roi_avg[ui.consider_focus_chart][-1] > self.get_peak_value:
                                                self.get_peak_value = self.mtf_roi_avg[ui.consider_focus_chart][-1]

                                "Below condition is used to freeze once the MTF reach the maximum with the given tolerance."
                                if found_threshold:
                                    self.rotation = float(
                                        ui.rotation_excel["Threshold clockwise rotation"])  # Another config
                                    if rotation_flag:
                                        self.rotation_dir = "anticlockwise"
                                    else:
                                        self.rotation_dir = "clockwise"

                                    if abs(self.get_peak_value - self.mtf_roi_avg[ui.consider_focus_chart][
                                        -1]) <= float(
                                        ui.rotation_excel["MTF Tolerance to achieve peak"]):  # Another config
                                        self.freezed_frame = self.frames_append
                                        self.start_ip_check = False
                                        ui.validation_clicked = False
                                        ui.get_result_clicked = True
                                        self.signals.update_live_graph.emit(self.mtf_roi_avg, "save")

                            """Below condition is to rotate with all the region"""
                        elif bool(ui.mtf_excel["Consider all region"]):  # Another config
                            """Considering all the region peak"""
                            if (ui.c_mtf_threshold < self.mtf_roi_avg["C"][-1] and len(
                                    self.mtf_roi_avg[
                                        "C"]) > 1 and not self.achieve_min_focus) or self.completed_basic_rotation:
                                """Set peak"""
                                self.completed_basic_rotation = True
                                found_iteration_count += 1
                                self.enter_threshold = True

                                """Below is for finding the peak for all the regions."""
                                if (self.mtf_roi_avg["C"][-1] > self.get_peak_value_C or self.mtf_roi_avg["TL"][
                                    -1] > self.get_peak_value_TL or self.mtf_roi_avg["TR"][
                                    -1] > self.get_peak_value_TR or
                                        self.mtf_roi_avg["BL"][-1] > self.get_peak_value_BL or
                                        self.mtf_roi_avg["BR"][-1] > self.get_peak_value_BR):
                                    if self.mtf_roi_avg["C"][-1] > self.get_peak_value_C:
                                        self.get_peak_value_C = self.mtf_roi_avg["C"][-1]
                                    if self.mtf_roi_avg["TL"][-1] > self.get_peak_value_TL:
                                        self.get_peak_value_TL = self.mtf_roi_avg["TL"][-1]
                                    if self.mtf_roi_avg["TR"][-1] > self.get_peak_value_TR:
                                        self.get_peak_value_TR = self.mtf_roi_avg["TR"][-1]
                                    if self.mtf_roi_avg["BL"][-1] > self.get_peak_value_BL:
                                        self.get_peak_value_BL = self.mtf_roi_avg["BL"][-1]
                                    if self.mtf_roi_avg["BR"][-1] > self.get_peak_value_BR:
                                        self.get_peak_value_BR = self.mtf_roi_avg["BR"][-1]

                                    self.rotation = float(
                                        ui.rotation_excel["Threshold anticlockwise rotation"])  # Another config
                                else:
                                    """Get back to peak"""
                                    """if the below condition satisfied then that is the case we found peak for all the regions."""
                                    if abs(self.get_peak_value_C - self.mtf_roi_avg["C"][-1]) >= float(
                                            ui.rotation_excel["MTF Tolerance tofind peak"]) and abs(
                                        self.get_peak_value_TL - self.mtf_roi_avg["TL"][-1]) >= float(
                                        ui.rotation_excel["MTF Tolerance tofind peak"]) and abs(
                                        self.get_peak_value_TR - self.mtf_roi_avg["TR"][-1]) >= float(
                                        ui.rotation_excel["MTF Tolerance tofind peak"]) and abs(
                                        self.get_peak_value_BL - self.mtf_roi_avg["BL"][-1]) >= float(
                                        ui.rotation_excel["MTF Tolerance tofind peak"]) and abs(
                                        self.get_peak_value_BR - self.mtf_roi_avg["BR"][-1]) >= float(
                                        ui.rotation_excel["MTF Tolerance tofind peak"]):  # Another config
                                        found_threshold = True
                                    else:
                                        """if it is not found the peak continue the rotation to find peak in the same direction"""
                                        if not found_threshold:
                                            self.rotation = float(
                                                ui.rotation_excel["Threshold anticlockwise rotation"])  # Another config

                                            if self.clockwise.upper() == "YES":
                                                if self.rotation_dir == "clockwise":
                                                    rotation_flag = True
                                                    self.rotation_dir = "clockwise"
                                                else:
                                                    rotation_flag = False
                                                    self.rotation_dir = "anticlockwise"
                                            elif self.clockwise.upper() == "NO":
                                                if self.rotation_dir == "anticlockwise":
                                                    rotation_flag = True
                                                    self.rotation_dir = "anticlockwise"
                                                else:
                                                    rotation_flag = False
                                                    self.rotation_dir = "clockwise"
                                            else:
                                                if self.rotation_dir == "clockwise":
                                                    rotation_flag = True
                                                    self.rotation_dir = "clockwise"
                                                else:
                                                    rotation_flag = False

                                            if self.mtf_roi_avg["C"][-1] > self.get_peak_value_C:
                                                self.get_peak_value_C = self.mtf_roi_avg["C"][-1]
                                            if self.mtf_roi_avg["TL"][-1] > self.get_peak_value_TL:
                                                self.get_peak_value_TL = self.mtf_roi_avg["TL"][-1]
                                            if self.mtf_roi_avg["TR"][-1] > self.get_peak_value_TR:
                                                self.get_peak_value_TR = self.mtf_roi_avg["TR"][-1]
                                            if self.mtf_roi_avg["BL"][-1] > self.get_peak_value_BL:
                                                self.get_peak_value_BL = self.mtf_roi_avg["BL"][-1]
                                            if self.mtf_roi_avg["BR"][-1] > self.get_peak_value_BR:
                                                self.get_peak_value_BR = self.mtf_roi_avg["BR"][-1]

                                """The below dict is for appending all the mtf values once after finding the peak."""
                                regions_dict["C"].append(self.mtf_roi_avg["C"][-1])
                                regions_dict["TL"].append(self.mtf_roi_avg["TL"][-1])
                                regions_dict["TR"].append(self.mtf_roi_avg["TR"][-1])
                                regions_dict["BL"].append(self.mtf_roi_avg["BL"][-1])
                                regions_dict["BR"].append(self.mtf_roi_avg["BR"][-1])

                                """Below conditions is to replace the last value in the final index to the repestive index."""
                                if len(regions_dict["C"]) > 1 and regions_dict["C"][-1] < regions_dict["C"][-2] and not \
                                        final_index[0]:
                                    final_index[0] = len(regions_dict["C"]) - 1

                                if len(regions_dict["TL"]) > 1 and regions_dict["TL"][-1] < regions_dict["TL"][
                                    -2] and not final_index[1]:
                                    final_index[1] = len(regions_dict["TL"]) - 1

                                if len(regions_dict["TR"]) > 1 and regions_dict["TR"][-1] < regions_dict["TR"][
                                    -2] and not final_index[2]:
                                    final_index[2] = len(regions_dict["TR"]) - 1

                                if len(regions_dict["BL"]) > 1 and regions_dict["BL"][-1] < regions_dict["BL"][
                                    -2] and not final_index[3]:
                                    final_index[3] = len(regions_dict["BL"]) - 1

                                if len(regions_dict["BR"]) > 1 and regions_dict["BR"][-1] < regions_dict["BR"][
                                    -2] and not final_index[4]:
                                    final_index[4] = len(regions_dict["BR"]) - 1

                                "Below condition is used to allow the find the focus."
                                if found_threshold:
                                    logger.debug(f"Used to allow the find the focus")
                                    getpeak_dict["C"] = self.get_peak_value_C
                                    getpeak_dict["TL"] = self.get_peak_value_TL
                                    getpeak_dict["TR"] = self.get_peak_value_TR
                                    getpeak_dict["BL"] = self.get_peak_value_BL
                                    getpeak_dict["BR"] = self.get_peak_value_BR

                                    logger.debug("***** Actual peak *****")
                                    logger.debug(
                                        f"C peak - {self.get_peak_value_C} difference {abs(self.get_peak_value_C - self.mtf_roi_avg['C'][-1])}")
                                    logger.debug(
                                        f"TL peak - {self.get_peak_value_TL} difference {abs(self.get_peak_value_TL - self.mtf_roi_avg['TL'][-1])}")
                                    logger.debug(
                                        f"TR peak - {self.get_peak_value_TR} difference {abs(self.get_peak_value_TR - self.mtf_roi_avg['TR'][-1])}")
                                    logger.debug(
                                        f"BL peak - {self.get_peak_value_BL} difference {abs(self.get_peak_value_BL - self.mtf_roi_avg['BL'][-1])}")
                                    logger.debug(
                                        f"BR peak - {self.get_peak_value_BR} difference {abs(self.get_peak_value_BR - self.mtf_roi_avg['BR'][-1])}")

                                    self.rotation = float(
                                        ui.rotation_excel["Threshold clockwise rotation"])  # Another config

                                    regions_list = ["C", "TL", "TR", "BL", "BR"]
                                    """if all the regions values are less than the given threshold then proceed to find the focus"""

                                    try:
                                        logger.debug(f"regions_dict['C']: {regions_dict['C']}")
                                        logger.debug(f"regions_dict['TL']: {regions_dict['TL']}")
                                        logger.debug(f"regions_dict['TR']: {regions_dict['TR']}")
                                        logger.debug(f"regions_dict['BL']: {regions_dict['BL']}")
                                        logger.debug(f"regions_dict['BR']: {regions_dict['BR']}")
                                        logger.debug(f"final_index: {final_index}")
                                        difference = abs(
                                            regions_dict[regions_list[final_index.index(max(final_index))]][
                                                max(final_index)] - \
                                            regions_dict[regions_list[final_index.index(max(final_index))]][
                                                min(final_index)])

                                        logger.info(
                                            f"Max {regions_dict[regions_list[final_index.index(max(final_index))]][max(final_index)]},Min {regions_dict[regions_list[final_index.index(max(final_index))]][min(final_index)]}, difference : {difference}")
                                        if difference >= float(ui.rotation_excel[
                                                                   "MTF Tolerance to achieve nearest peak"]) and not self.difference_stop:  # Another config
                                            self.rotation = float(
                                                ui.rotation_excel["Basic anticlockwise rotation"])  # Another config
                                            self.difference_stop = True

                                        logger.info(
                                            f"center_peak{self.get_peak_value_C},"
                                            f"current_mtf{self.mtf_roi_avg['C'][-1]},Difference{difference}, "
                                            f"actual_diff-currentmtf{round(abs((self.get_peak_value_C - difference / int(ui.rotation_excel['Difference'])) - (self.mtf_roi_avg['C'][-1])), 3)},center-diff{(self.get_peak_value_C - difference / int(ui.rotation_excel['Difference'])),},currentmtf{(self.mtf_roi_avg['C'][-1])},threshold{finetuning_threshold}")

                                        if (finetuning_threshold > (round(abs((self.get_peak_value_C - difference / int(
                                                ui.rotation_excel["Difference"])) - (self.mtf_roi_avg["C"][-1])),
                                                                          3))):  # Another config
                                            self.freezed_frame = self.frames_append
                                            self.start_ip_check = False
                                            ui.validation_clicked = False
                                            ui.get_result_clicked = True
                                            self.signals.update_live_graph.emit(self.mtf_roi_avg, "save")

                                        if not threshold_acheive_peak_rotation and self.getting_peak == False:
                                            if self.clockwise.upper() == "YES":
                                                self.rotation_dir = "clockwise"
                                            elif self.clockwise.upper() == "NO":
                                                self.rotation_dir = "anticlockwise"
                                            else:
                                                self.rotation_dir = "clockwise"

                                    except Exception as e:
                                        print(e, "13130")

                                    else:
                                        logger.debug(
                                            f'{round(abs((self.get_peak_value_C - difference) - (self.mtf_roi_avg["C"][-1])), 3)} '
                                            f'{round(abs(self.get_peak_value_TR - self.mtf_roi_avg["TR"][-1]), 3)} '
                                            f'{round(abs(self.get_peak_value_TR - self.mtf_roi_avg["TL"][-1]), 3)} '
                                            f'{round(abs(self.get_peak_value_BL - self.mtf_roi_avg["BL"][-1]), 3)} '
                                            f'{round(abs(self.get_peak_value_BR - self.mtf_roi_avg["BR"][-1]), 3)} {finetuning_threshold}')

                                        """if the all the mtf values are not less the given threshold, 
                                        show the pop up as unable to attain the peak."""
                                        if len(check) > 0:
                                            excel_info = []
                                            for label in ui.rois.keys():
                                                if self.before_glue[label] == 0:
                                                    excel_info.append('NA')
                                                else:
                                                    excel_info.append(self.before_glue[label])

                                            if self.before_glue['All'] == 0:
                                                excel_info.append("NA")
                                            else:
                                                excel_info.append(self.before_glue['All'])
                                            self.overall_info.append(excel_info)
                                            self.start_ip_check = False
                                            ui.validation_clicked = False
                                            self.validation_done = False
                                            self.overall_result_list["Fixture offset remarks"] = (
                                                "Unable to attain the "
                                                "Center and corner peak.")
                                            self.signals.call_MsgBox.emit("Alert!", "Unable to attain the Center "
                                                                                    "and corner peak.", "Critical")
                                            logger.debug("Unable to attain the Center and corner peak.")
                                            del frame
                                            gc.collect()
                                            break  # break the while loop


                        else:
                            self.signals.call_MsgBox.emit("Permission Denied!",
                                                          "Unable to proceed the rotation, Kindly check the recipe file.",
                                                          "Critical")
                            self.start_ip_check = False
                            ui.validation_clicked = False
                            self.overall_result_list[
                                "Fixture offset remarks"] = "Please enable either center or corner rotation option"
                            return

                        if ui.validation_clicked:
                            self.plc_status = ''
                            self.plc_status = ui_plc_communication.plc_control_class.lens_rotate(
                                degree=self.rotation,
                                direction=self.rotation_dir)

                            if self.plc_status == "Connection Failed":
                                self.signals.call_MsgBox.emit("Permission Denied!",
                                                              "Port connection failed.",
                                                              "Critical")
                                logger.error("Unable to access the Port")
                                del frame
                                gc.collect()
                                break

                            elif self.plc_status == "Incorrect direction input":
                                self.signals.call_MsgBox.emit("PLC Error!", "Incorrect direction input.",
                                                              "Critical")
                                logger.error("Incorrect direction input.")
                                del frame
                                gc.collect()
                                break

                            elif self.plc_status == "Incorrect degree input":
                                self.signals.call_MsgBox.emit("PLC Error!", "Incorrect degree input.",
                                                              "Critical")
                                logger.error("Incorrect degree input.")
                                del frame
                                gc.collect()
                                break

                            elif self.plc_status == "Lens rotation Failed":
                                self.signals.call_MsgBox.emit("PLC Error!", "Lens rotation Failed.",
                                                              "Critical")
                                logger.error("Lens rotation Failed.")
                                del frame
                                gc.collect()
                                break

                            elif self.plc_status == "Passed":
                                self.signals.update_live_graph.emit(self.mtf_roi_avg, "")

                    elif ui.after_glue_clicked:
                        if not self.ip_status:
                            self.start_ip_check = False
                            catch_error = self.catch_and_clear_error(status=self.status_input)
                            if catch_error == "Not Done":
                                del frame
                                gc.collect()
                                self.ip_status = False
                                ui.validation_clicked = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User cancelled the sequence in after glue check"
                                return

                            elif catch_error == "Done":
                                time.sleep(1)
                                self.ip_status = True

                            else:
                                del frame
                                gc.collect()
                                self.ip_status = False
                                ui.validation_clicked = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "Error occurred in catch & clear else case in AFG check"
                                return
                        caluclatable_frames = int(ui.mtf_excel["Median frames count"])  # Another config
                        self.frames_append = []
                        for nof_calculatableFrames in range(caluclatable_frames):
                            ret, frame = self.read_frames()
                            if ret:
                                self.frames_append.append(frame)
                        for i in range(caluclatable_frames):
                            self.thread_median_cal(self.frames_append[i])

                        try:
                            median = self.calculation()

                            roi_list = ["TL", "TR", "C", "BL", "BR"]
                            length_roi_list = [len(self.final_result.roi_mtf_value[i]) for i in roi_list]
                            length = 0
                            for index, i in enumerate(length_roi_list):
                                for j in range(i):
                                    self.final_result.roi_mtf_value[roi_list[index]][j]['roi_lum']['mtf50'] = \
                                        median[length]
                                    length += 1

                        except Exception as e:
                            print(e, "9433")

                        if self.image_roi.image.shape[0] > 1440:
                            overall_avg = []
                            for roi_position, regions in self.final_result.roi_mtf_value.items():
                                if regions:
                                    roi_avg = []
                                    for i in range(len(regions)):
                                        try:
                                            roi_avg.append(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3))
                                            cv2.putText(self.image_roi.image, 'Reg:{}'.format(i + 1),
                                                        (
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][1] + 0),
                                                        cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0),
                                                        2,
                                                        cv2.LINE_AA)
                                            cv2.putText(self.image_roi.image, '{}'.format(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3)),
                                                        (
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][1] + 45),
                                                        cv2.FONT_HERSHEY_SIMPLEX, 1.2,
                                                        (0, 255, 0), 2,
                                                        cv2.LINE_AA)
                                        except KeyError:
                                            logger.debug("MTF50 value is empty")

                                    if len(roi_avg) != 0:
                                        cv2.putText(self.image_roi.image, 'Avg: {}'.format(
                                            round(sum(roi_avg) / len(roi_avg), 3)),
                                                    (ui.rois[roi_position][3] - 220,
                                                     ui.rois[roi_position][0] + 45),
                                                    cv2.FONT_HERSHEY_SIMPLEX, 1.2,
                                                    (0, 255, 0), 2, cv2.LINE_AA)
                                        overall_avg.append(round(sum(roi_avg) / len(roi_avg), 3))
                                        self.after_glue[roi_position] = round(
                                            sum(roi_avg) / len(roi_avg), 3)
                                    else:
                                        self.after_glue[roi_position] = 0
                                else:
                                    self.after_glue[roi_position] = 0

                            if len(overall_avg) != 0:
                                self.after_glue['All'] = round(sum(overall_avg) / len(overall_avg),
                                                               3)
                                cv2.putText(self.image_roi.image, 'Overall Avg: {}'.format(
                                    round(sum(overall_avg) / len(overall_avg), 3)),
                                            (25, 45), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 2,
                                            cv2.LINE_AA)
                                display_image = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)

                            else:
                                self.after_glue['All'] = 0

                        else:
                            overall_avg = []
                            for roi_position, regions in self.final_result.roi_mtf_value.items():
                                if regions:
                                    roi_avg = []
                                    for i in range(len(regions)):
                                        try:
                                            roi_avg.append(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3))
                                            cv2.putText(self.image_roi.image, 'Reg:{}'.format(i + 1),
                                                        (
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][1] + 0),
                                                        cv2.FONT_HERSHEY_SIMPLEX, .5, (0, 255, 0),
                                                        2,
                                                        cv2.LINE_AA)
                                            cv2.putText(self.image_roi.image, '{}'.format(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3)),
                                                        (
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][1] + 45),
                                                        cv2.FONT_HERSHEY_SIMPLEX, .7, (0, 255, 0),
                                                        2,
                                                        cv2.LINE_AA)
                                        except KeyError:
                                            logger.debug("MTF50 value is empty")
                                    if len(roi_avg) != 0:
                                        cv2.putText(self.image_roi.image, 'Avg: {}'.format(
                                            round(sum(roi_avg) / len(roi_avg), 3)),
                                                    (ui.rois[roi_position][3] - 150,
                                                     ui.rois[roi_position][0] + 35),
                                                    cv2.FONT_HERSHEY_SIMPLEX, .9, (0, 255, 0), 2,
                                                    cv2.LINE_AA)
                                        overall_avg.append(round(sum(roi_avg) / len(roi_avg), 3))
                                        self.after_glue[roi_position] = round(sum(roi_avg) / len(roi_avg), 3)
                                    else:
                                        self.after_glue[roi_position] = 0

                                else:
                                    self.after_glue[roi_position] = 0

                            if len(overall_avg) != 0:
                                self.after_glue['All'] = round(sum(overall_avg) / len(overall_avg), 3)
                                cv2.putText(self.image_roi.image, 'Overall Avg: {}'.format(
                                    round(sum(overall_avg) / len(overall_avg), 3)),
                                            (25, 45), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 2,
                                            cv2.LINE_AA)
                                display_image = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)

                            else:
                                self.after_glue['All'] = 0

                        dummy = True
                        if dummy:
                            display_image = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)
                            display_image = cv2.resize(display_image, self.dim,
                                                       interpolation=cv2.INTER_AREA)
                            height, width, channel = display_image.shape
                            step = channel * width
                            qt_img = QImage(display_image.data, width, height, step, QImage.Format_RGB888)
                            self.signals.call_updateLbl.emit(qt_img)
                            try:
                                if ui.mtf_excel["Center avg only"]:  # Another config
                                    if self.mtf_roi_avg["C"][-1] >= float(
                                            ui.mtf_excel["Center avg criteria"]):  # Another config
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "AFG MTF values achieved in " \
                                                                        "center avg criteria"
                                        self.validation_done = True

                                    else:
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "AFG MTF values less than in" \
                                                                        "center avg criteria"
                                        self.validation_done = "Failed"

                                elif ui.mtf_excel["Center and Corners each region avg"]:  # Another config
                                    if self.mtf_roi_avg["TL"][-1] >= float(
                                            ui.mtf_excel["TL avg criteria"]) and \
                                            self.mtf_roi_avg["TR"][-1] >= float(ui.mtf_excel["TR avg criteria"]) and \
                                            self.mtf_roi_avg["BL"][-1] >= float(ui.mtf_excel["BL avg criteria"]) and \
                                            self.mtf_roi_avg["BR"][-1] >= float(ui.mtf_excel["BR avg criteria"]) and \
                                            self.mtf_roi_avg["C"][-1] >= float(ui.mtf_excel["Center avg criteria"]):
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "AFG MTF values achieved in" \
                                                                        "Center & all corners region"
                                        self.validation_done = True
                                    else:
                                        if self.mtf_roi_avg["Center avg criteria"][-1] < float(
                                                ui.mtf_excel["Center avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG C MTF avg less than threshold"
                                        elif self.mtf_roi_avg["TL"][-1] < float(
                                                ui.mtf_excel["TL avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG TL MTF avg less than in" \
                                                                            "TL corner region"
                                        elif self.mtf_roi_avg["TR"][-1] < float(
                                                ui.mtf_excel["TR avg criteria"]):  # Another config
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG TR MTF avg less than in" \
                                                                            "TR corner region"
                                        elif self.mtf_roi_avg["BL"][-1] < float(
                                                ui.mtf_excel["BL avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG BL MTF avg less than in" \
                                                                            "BL corner region"
                                        elif self.mtf_roi_avg["BR"][-1] < float(
                                                ui.mtf_excel["BR avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG BR MTF avg less than in" \
                                                                            "BR corner region"
                                        self.validation_done = "Failed"

                                elif ui.mtf_excel["Corners each region avg"]:
                                    if self.mtf_roi_avg["TL"][-1] >= float(
                                            ui.mtf_excel["TL avg criteria"]) and \
                                            self.mtf_roi_avg["TR"][-1] >= float(
                                        ui.mtf_excel["TR avg criteria"]) and \
                                            self.mtf_roi_avg["BL"][-1] >= float(
                                        ui.mtf_excel["BL avg criteria"]) and \
                                            self.mtf_roi_avg["BR"][-1] >= float(
                                        ui.mtf_excel["BR avg criteria"]):  # Another config
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "AFG MTF values achieved in" \
                                                                        "all corners region"
                                        self.validation_done = True
                                    else:
                                        if self.mtf_roi_avg["TL"][-1] < float(
                                                ui.mtf_excel["TL avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG TL MTF avg less than in" \
                                                                            "TL corner region"
                                        elif self.mtf_roi_avg["TR"][-1] < float(
                                                ui.mtf_excel["TR avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG TR MTF avg less than in" \
                                                                            "TR corner region"
                                        elif self.mtf_roi_avg["BL"][-1] < float(
                                                ui.mtf_excel["BL avg criteria"]):  # Another config
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG BL MTF avg less than in" \
                                                                            "BL corner region"
                                        elif self.mtf_roi_avg["BR"][-1] < float(
                                                ui.mtf_excel["BR avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG BR MTF avg less than in" \
                                                                            "BR corner region"
                                        self.validation_done = "Failed"

                                elif ui.mtf_excel["Corners all region avg"]:
                                    if sum([self.mtf_roi_avg["TL"][-1], self.mtf_roi_avg["TR"][-1],
                                            self.mtf_roi_avg["BL"][-1], self.mtf_roi_avg["BR"][-1]]) / 4 >= float(
                                        ui.mtf_excel["Corner avg criteria"]):  # Another config
                                        logger.info("The AFG MTF values achieved Corners all region avg")
                                        self.overall_result_list["Fixture offset remarks"] = "The AFG MTF values " \
                                                                                             "achieved Corners all region avg"
                                        self.validation_done = True
                                    else:
                                        logger.info("The AFG MTF values less than Corners all region avg")
                                        self.overall_result_list["Fixture offset remarks"] = "The AFG MTF values " \
                                                                                             "lessthan Corners all region avg"
                                        self.validation_done = "Failed"

                                elif ui.mtf_excel["Center avg and Corners all region avg"]:
                                    if self.mtf_roi_avg[ui.consider_focus_chart][-1] >= float(
                                            ui.mtf_excel["Center avg criteria"]) and sum(
                                        [self.mtf_roi_avg["TL"][-1],
                                         self.mtf_roi_avg["TR"][-1],
                                         self.mtf_roi_avg["BL"][-1],
                                         self.mtf_roi_avg["BR"][
                                             -1]]) / 4 >= float(ui.mtf_excel["Corner avg criteria"]):
                                        logger.info("The AFG MTF values achieved center and corner")
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "AFG MTF values achieved in " \
                                                                        "center & corner "
                                        self.validation_done = True

                                    else:
                                        if self.mtf_roi_avg[ui.consider_focus_chart][-1] < \
                                                float(ui.mtf_excel["Center avg criteria"]):  # Another config
                                            logger.debug("The AFG MTF center value less than threshold")
                                            self.overall_result_list["Fixture offset remarks"] = "The AFG MTF center " \
                                                                                                 "value less than criteria"

                                        elif sum([self.mtf_roi_avg["TL"][-1],
                                                  self.mtf_roi_avg["TR"][-1],
                                                  self.mtf_roi_avg["BL"][-1],
                                                  self.mtf_roi_avg["BR"][-1]]) / 4 < float(
                                            ui.mtf_excel["Corner avg criteria"]):
                                            logger.debug("The AFG MTF corners value less than threshold")
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "The AFG MTF corners value " \
                                                                            "less than criteria"
                                        else:
                                            logger.debug("The AFG lens offset value is not within the "
                                                         "tolerance: dx {} and dy {}".format(dx, dy))
                                            self.overall_result_list["Fixture offset remarks"] = "AFG lens offset " \
                                                                                                 "value is out of tolerance."
                                        self.validation_done = "Failed"

                                elif ui.mtf_excel["Overall avg"]:
                                    if self.mtf_roi_avg['All'][-1] >= float(
                                            ui.mtf_excel["Overall avg criteria"]):
                                        logger.debug("The AFG overall MTF avg achieved threshold")
                                        self.overall_result_list["Fixture offset remarks"] = "The AFG overall " \
                                                                                             "MTF avg achieved threshold"
                                        self.validation_done = True
                                    else:
                                        logger.debug("The AFG overall MTF avg less than threshold")
                                        self.overall_result_list["Fixture offset remarks"] = "The AFG overall " \
                                                                                             "MTF avg less than threshold"
                                        self.validation_done = "Failed"

                            except Exception as e:
                                logger.debug("Exception occurred in after gluing result {}".format(e))
                                self.overall_result_list["Fixture offset remarks"] = "Exception occurred in " \
                                                                                     "after gluing result"
                                self.validation_done = False

                            self.signals.update_results.emit(frame, self.image_roi.image,
                                                             "after_glue", self.withoutdb8bit)
                            excel_info = []
                            for label in ui.rois.keys():
                                if self.after_glue[label] == 0:
                                    excel_info.append('NA')
                                else:
                                    excel_info.append(self.after_glue[label])
                            if self.after_glue['All'] == 0:
                                excel_info.append("NA")
                            else:
                                excel_info.append(self.after_glue['All'])
                            self.overall_info.append(excel_info)

                            ui.after_glue_clicked = False
                            del self.final_result
                            del self.image_roi
                            del frame
                            gc.collect()
                            break

                        else:
                            logger.info(f"After glue iteration: {self.after_glue_iteration}")
                            self.after_glue_iteration += 1
                            if self.after_glue_iteration >= 10:
                                logger.debug(
                                    "MTF value difference is more for after gluing validation after 10 iteration")
                                excel_info = []
                                for label in ui.rois.keys():
                                    if self.after_glue[label] == 0:
                                        excel_info.append('NA')
                                    else:
                                        excel_info.append(self.after_glue[label])
                                if self.after_glue['All'] == 0:
                                    excel_info.append("NA")
                                else:
                                    excel_info.append(self.after_glue['All'])
                                self.overall_info.append(excel_info)
                                try:
                                    if ui.mtf_excel["Center avg only"]:  # Another config
                                        if self.mtf_roi_avg["C"][-1] >= float(
                                                ui.mtf_excel["Center avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG MTF values achieved in " \
                                                                            "center avg criteria"
                                            self.validation_done = True

                                        else:
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG MTF values less than in" \
                                                                            "center avg criteria"
                                            self.validation_done = "Failed"

                                    elif ui.mtf_excel["Center and Corners each region avg"]:
                                        if self.mtf_roi_avg["TL"][-1] >= float(
                                                ui.mtf_excel["TL avg criteria"]) and \
                                                self.mtf_roi_avg["TR"][-1] >= float(
                                            ui.mtf_excel["TR avg criteria"]) and \
                                                self.mtf_roi_avg["BL"][-1] >= float(
                                            ui.mtf_excel["BL avg criteria"]) and \
                                                self.mtf_roi_avg["BR"][-1] >= float(
                                            ui.mtf_excel["BR avg criteria"]) and \
                                                self.mtf_roi_avg["C"][-1] >= float(
                                            ui.mtf_excel["Center avg criteria"]):  # Another config
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG MTF values achieved in" \
                                                                            "Center & all corners region"
                                            self.validation_done = True
                                        else:
                                            if self.mtf_roi_avg["Center avg criteria"][-1] < float(
                                                    ui.mtf_excel["Center avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFG C MTF avg less than threshold"
                                            elif self.mtf_roi_avg["TL"][-1] < float(
                                                    ui.mtf_excel["TL avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFG TL MTF avg less than in" \
                                                                                "TL corner region"
                                            elif self.mtf_roi_avg["TR"][-1] < float(
                                                    ui.mtf_excel["TR avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFG TR MTF avg less than in" \
                                                                                "TR corner region"
                                            elif self.mtf_roi_avg["BL"][-1] < float(
                                                    ui.mtf_excel["BL avg criteria"]):  # Another config
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFG BL MTF avg less than in" \
                                                                                "BL corner region"
                                            elif self.mtf_roi_avg["BR"][-1] < float(
                                                    ui.mtf_excel["BR avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFG BR MTF avg less than in" \
                                                                                "BR corner region"
                                            self.validation_done = "Failed"

                                    elif ui.mtf_excel["Corners each region avg"]:
                                        if self.mtf_roi_avg["TL"][-1] >= float(
                                                ui.mtf_excel["TL avg criteria"]) and \
                                                self.mtf_roi_avg["TR"][-1] >= float(
                                            ui.mtf_excel["TR avg criteria"]) and \
                                                self.mtf_roi_avg["BL"][-1] >= float(
                                            ui.mtf_excel["BL avg criteria"]) and \
                                                self.mtf_roi_avg["BR"][-1] >= float(
                                            ui.mtf_excel["BR avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG MTF values achieved in" \
                                                                            "all corners region"
                                            self.validation_done = True
                                        else:
                                            if self.mtf_roi_avg["TL"][-1] < float(
                                                    ui.mtf_excel["TL avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFG TL MTF avg less than in" \
                                                                                "TL corner region"
                                            elif self.mtf_roi_avg["TR"][-1] < float(
                                                    ui.mtf_excel["TR avg criteria"]):  # Another config
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFG TR MTF avg less than in" \
                                                                                "TR corner region"
                                            elif self.mtf_roi_avg["BL"][-1] < float(
                                                    ui.mtf_excel["BL avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFG BL MTF avg less than in" \
                                                                                "BL corner region"
                                            elif self.mtf_roi_avg["BR"][-1] < float(
                                                    ui.mtf_excel["BR avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFG BR MTF avg less than in" \
                                                                                "BR corner region"
                                            self.validation_done = "Failed"

                                    elif ui.mtf_excel["Corners all region avg"]:
                                        if sum([self.mtf_roi_avg["TL"][-1], self.mtf_roi_avg["TR"][-1],
                                                self.mtf_roi_avg["BL"][-1], self.mtf_roi_avg["BR"][-1]]) / 4 >= float(
                                            ui.mtf_excel["Corner avg criteria"]):
                                            logger.info("The AFG MTF values achieved Corners all region avg")
                                            self.overall_result_list["Fixture offset remarks"] = "The AFG MTF values " \
                                                                                                 "achieved Corners " \
                                                                                                 "all region avg "
                                            self.validation_done = True
                                        else:
                                            logger.info("The AFG MTF values less than Corners all region avg")
                                            self.overall_result_list["Fixture offset remarks"] = "The AFG MTF values " \
                                                                                                 "lessthan Corners all region avg"
                                            self.validation_done = "Failed"

                                    elif ui.mtf_excel["Center avg and Corners all region avg"]:
                                        if self.mtf_roi_avg[ui.consider_focus_chart][-1] >= float(
                                                ui.mtf_excel["Center avg criteria"]) and sum(
                                            [self.mtf_roi_avg["TL"][-1],
                                             self.mtf_roi_avg["TR"][-1],
                                             self.mtf_roi_avg["BL"][-1],
                                             self.mtf_roi_avg["BR"][-1]]) / 4 >= float(
                                            ui.mtf_excel["Corner avg criteria"]):  # Another config
                                            logger.info("The AFG MTF values achieved center and corner")
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFG MTF values achieved in " \
                                                                            "center & corner "
                                            self.validation_done = True

                                        else:
                                            if self.mtf_roi_avg[ui.consider_focus_chart][-1] < \
                                                    float(ui.mtf_excel["Center avg criteria"]):
                                                logger.debug("The AFG MTF center value less than threshold")
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "The AFG MTF center " \
                                                                                "value less than criteria"

                                            elif sum([self.mtf_roi_avg["TL"][-1],
                                                      self.mtf_roi_avg["TR"][-1],
                                                      self.mtf_roi_avg["BL"][-1],
                                                      self.mtf_roi_avg["BR"][-1]]) / 4 < float(
                                                ui.mtf_excel["Corner avg criteria"]):
                                                logger.debug("The AFG MTF corners value less than threshold")
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "The AFG MTF corners value " \
                                                                                "less than criteria"
                                            else:
                                                logger.debug("The AFG lens offset value is not within the "
                                                             "tolerance: dx {} and dy {}".format(dx, dy))
                                                self.overall_result_list["Fixture offset remarks"] = "AFG lens offset " \
                                                                                                     "value is out of tolerance."
                                            self.validation_done = "Failed"

                                    elif ui.mtf_excel["Overall avg"]:  # Another config
                                        if self.mtf_roi_avg['All'][-1] >= float(
                                                ui.mtf_excel["Overall avg criteria"]):
                                            logger.debug("The AFG overall MTF avg achieved threshold")
                                            self.overall_result_list["Fixture offset remarks"] = "The AFG overall " \
                                                                                                 "MTF avg achieved threshold"
                                            self.validation_done = True
                                        else:
                                            logger.debug("The AFG overall MTF avg less than threshold")
                                            self.overall_result_list["Fixture offset remarks"] = "The AFG overall " \
                                                                                                 "MTF avg less than threshold"
                                            self.validation_done = "Failed"

                                except Exception as e:
                                    logger.debug("Exception occurred in after gluing result {}".format(e))
                                    self.overall_result_list["Fixture offset remarks"] = "Exception occurred in " \
                                                                                         "after gluing result"
                                    self.validation_done = False
                                self.signals.update_results.emit(frame, self.image_roi.image,
                                                                 "after_glue", self.withoutdb8bit)

                                ui.after_glue_clicked = False
                                del self.image_roi
                                del self.final_result
                                break

                            else:
                                display_image = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)
                                display_image = cv2.resize(display_image, self.dim,
                                                           interpolation=cv2.INTER_AREA)
                                height, width, channel = display_image.shape
                                step = channel * width
                                qt_img = QImage(display_image.data, width, height, step, QImage.Format_RGB888)
                                self.signals.call_updateLbl.emit(qt_img)
                                del self.image_roi
                                del self.final_result
                                continue

                    elif ui.after_curing_clicked:
                        if not self.ip_status:
                            self.start_ip_check = False
                            catch_error = self.catch_and_clear_error(status=self.status_input)
                            if catch_error == "Not Done":
                                del frame
                                gc.collect()
                                self.ip_status = False
                                ui.validation_clicked = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User cancelled the sequence in after cure check"
                                return

                            elif catch_error == "Done":
                                time.sleep(1)
                                self.ip_status = True

                            else:
                                del frame
                                gc.collect()
                                self.ip_status = False
                                ui.validation_clicked = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "Error occurred in catch & clear else case in AFC check"
                                return

                        caluclatable_frames = int(ui.mtf_excel["Median frames count"])  # Another config
                        count_in = 0
                        final_results = []
                        self.frames_append = []
                        for nof_calculatableFrames in range(caluclatable_frames):
                            ret, frame = self.read_frames()
                            if ret:
                                self.frames_append.append(frame)

                        for i in range(caluclatable_frames):
                            self.thread_median_cal(self.frames_append[i])
                        try:
                            median = self.calculation()
                            roi_list = ["TL", "TR", "C", "BL", "BR"]
                            length_roi_list = [len(self.final_result.roi_mtf_value[i]) for i in roi_list]
                            length = 0
                            for index, i in enumerate(length_roi_list):
                                for j in range(i):
                                    self.final_result.roi_mtf_value[roi_list[index]][j]['roi_lum']['mtf50'] = \
                                        median[length]
                                    length += 1

                        except Exception as e:
                            print(e, "9433")
                        if self.image_roi.image.shape[0] > 1440:
                            overall_avg = []
                            for roi_position, regions in self.final_result.roi_mtf_value.items():
                                if regions:
                                    roi_avg = []
                                    for i in range(len(regions)):
                                        try:
                                            roi_avg.append(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3))
                                            cv2.putText(self.image_roi.image, 'Reg:{}'.format(i + 1),
                                                        (
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][1] + 0),
                                                        cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0),
                                                        2,
                                                        cv2.LINE_AA)
                                            cv2.putText(self.image_roi.image, '{}'.format(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3)),
                                                        (
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][1] + 45),
                                                        cv2.FONT_HERSHEY_SIMPLEX, 1.2,
                                                        (0, 255, 0), 2,
                                                        cv2.LINE_AA)
                                        except KeyError:
                                            logger.debug("MTF50 value is empty")

                                    if len(roi_avg) != 0:
                                        cv2.putText(self.image_roi.image, 'Avg: {}'.format(
                                            round(sum(roi_avg) / len(roi_avg), 3)),
                                                    (ui.rois[roi_position][3] - 220,
                                                     ui.rois[roi_position][0] + 45),
                                                    cv2.FONT_HERSHEY_SIMPLEX, 1.2,
                                                    (0, 255, 0), 2, cv2.LINE_AA)
                                        overall_avg.append(round(sum(roi_avg) / len(roi_avg), 3))
                                        self.after_cure[roi_position] = round(sum(roi_avg) / len(roi_avg), 3)
                                    else:
                                        self.after_cure[roi_position] = 0
                                else:
                                    self.after_cure[roi_position] = 0

                            if len(overall_avg) != 0:
                                self.after_cure['All'] = round(sum(overall_avg) / len(overall_avg), 3)
                                cv2.putText(self.image_roi.image, 'Overall Avg: {}'.format(
                                    round(sum(overall_avg) / len(overall_avg), 3)),
                                            (25, 45), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 2,
                                            cv2.LINE_AA)
                                display_image = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)

                            else:
                                self.after_cure['All'] = 0

                        else:
                            overall_avg = []
                            for roi_position, regions in self.final_result.roi_mtf_value.items():
                                if regions:
                                    roi_avg = []
                                    for i in range(len(regions)):
                                        try:
                                            roi_avg.append(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3))
                                            cv2.putText(self.image_roi.image, 'Reg:{}'.format(i + 1),
                                                        (
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][1] + 0),
                                                        cv2.FONT_HERSHEY_SIMPLEX, .5, (0, 255, 0),
                                                        2,
                                                        cv2.LINE_AA)
                                            cv2.putText(self.image_roi.image, '{}'.format(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3)),
                                                        (
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[
                                                                roi_position][i][
                                                                'roi_pt'][0][1] + 45),
                                                        cv2.FONT_HERSHEY_SIMPLEX, .7, (0, 255, 0),
                                                        2,
                                                        cv2.LINE_AA)
                                        except KeyError:
                                            logger.debug("MTF50 value is empty")
                                    if len(roi_avg) != 0:
                                        cv2.putText(self.image_roi.image, 'Avg: {}'.format(
                                            round(sum(roi_avg) / len(roi_avg), 3)),
                                                    (ui.rois[roi_position][3] - 150,
                                                     ui.rois[roi_position][0] + 35),
                                                    cv2.FONT_HERSHEY_SIMPLEX, .9, (0, 255, 0), 2,
                                                    cv2.LINE_AA)
                                        overall_avg.append(round(sum(roi_avg) / len(roi_avg), 3))
                                        self.after_cure[roi_position] = round(sum(roi_avg) / len(roi_avg), 3)
                                    else:
                                        self.after_cure[roi_position] = 0
                                else:
                                    self.after_cure[roi_position] = 0

                            if len(overall_avg) != 0:
                                self.after_cure['All'] = round(sum(overall_avg) / len(overall_avg), 3)
                                cv2.putText(self.image_roi.image, 'Overall Avg: {}'.format(
                                    round(sum(overall_avg) / len(overall_avg), 3)),
                                            (25, 45), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 2,
                                            cv2.LINE_AA)
                                display_image = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)

                            else:
                                self.after_cure['All'] = 0

                        dummy = True
                        if dummy:
                            display_image = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)
                            display_image = cv2.resize(display_image, self.dim, interpolation=cv2.INTER_AREA)
                            height, width, channel = display_image.shape
                            step = channel * width
                            qt_img = QImage(display_image.data, width, height, step, QImage.Format_RGB888)
                            self.signals.call_updateLbl.emit(qt_img)

                            try:
                                if ui.mtf_excel["Center avg only"]:
                                    if self.after_cure["C"] >= float(
                                            ui.mtf_excel["Afc Center avg criteria"]):  # Another config
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "AFC MTF values achieved in " \
                                                                        "center avg criteria"
                                        self.validation_done = True

                                    else:
                                        self.overall_result_list["Fixture offset remarks"] = "AFC MTF values less than" \
                                                                                             "center avg criteria"
                                        self.validation_done = "Failed"

                                elif ui.mtf_excel["Center and Corners each region avg"]:  # Another config
                                    if self.after_cure["TL"] >= float(
                                            ui.mtf_excel["Afc TL avg criteria"]) and \
                                            self.after_cure["TR"] >= float(ui.mtf_excel["Afc TR avg criteria"]) and \
                                            self.after_cure["BL"] >= float(ui.mtf_excel["Afc BL avg criteria"]) and \
                                            self.after_cure["BR"] >= float(ui.mtf_excel["Afc BR avg criteria"]) and \
                                            self.after_cure["C"] >= float(ui.mtf_excel["Afc Center avg criteria"]):
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "AFC MTF values achieved in" \
                                                                        "Center & all corners region"
                                        self.validation_done = True
                                    else:
                                        if self.after_cure["C"] < float(ui.mtf_excel["Afc Center avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC C MTF avg less than threshold"
                                        elif self.after_cure["TL"] < float(ui.mtf_excel["Afc TL avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC TL MTF avg less than threshold"
                                        elif self.after_cure["TR"] < float(ui.mtf_excel["Afc TR avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC TR MTF avg less than threshold"
                                        elif self.after_cure["BL"] < float(
                                                ui.mtf_excel["Afc BL avg criteria"]):  # Another config
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC BL MTF avg less than threshold"
                                        elif self.after_cure["BR"] < float(ui.mtf_excel["Afc BR avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC BR MTF avg less than threshold"
                                        self.validation_done = "Failed"

                                elif ui.mtf_excel["Corners each region avg"]:  # Another config
                                    if self.after_cure["TL"] >= float(ui.mtf_excel["Afc TL avg criteria"]) and \
                                            self.after_cure["TR"] >= float(ui.mtf_excel["Afc TR avg criteria"]) and \
                                            self.after_cure["BL"] >= float(ui.mtf_excel["Afc BL avg criteria"]) and \
                                            self.after_cure["BR"] >= float(ui.mtf_excel["Afc BR avg criteria"]):
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "AFC MTF values achieved in" \
                                                                        "all corners region"
                                        self.validation_done = True
                                    else:
                                        # Another config
                                        if self.after_cure["TL"] < float(ui.mtf_excel["Afc TL avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC TL MTF avg less than threshold"
                                        elif self.after_cure["TR"] < float(ui.mtf_excel["Afc TR avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC TR MTF avg less than threshold"
                                        elif self.after_cure["BL"] < float(ui.mtf_excel["Afc BL avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC BL MTF avg less than threshold"
                                        elif self.after_cure["BR"] < float(ui.mtf_excel["Afc BR avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC BR MTF avg less than threshold"
                                        self.validation_done = "Failed"

                                elif ui.mtf_excel["Corners all region avg"]:
                                    if sum([self.after_cure["TL"], self.after_cure["TR"],
                                            self.after_cure["BL"], self.after_cure["BR"]]) / 4 >= float(
                                        ui.mtf_excel["Afc Corner avg criteria"]):
                                        logger.info("The AFC MTF values achieved Corners all region avg")
                                        self.overall_result_list["Fixture offset remarks"] = "The AFC MTF values " \
                                                                                             "achieved Corners all region avg"
                                        self.validation_done = True
                                    else:
                                        logger.info("The AFC MTF values less than Corners all region avg")
                                        self.overall_result_list["Fixture offset remarks"] = "The AFC MTF values " \
                                                                                             "lessthan Corners all region avg"
                                        self.validation_done = "Failed"

                                elif ui.mtf_excel["Center avg and Corners all region avg"]:  # Another config
                                    if self.after_cure[ui.consider_focus_chart] >= float(
                                            ui.mtf_excel["Afc Center avg criteria"]) and sum(
                                        [self.after_cure["TL"],
                                         self.after_cure["TR"],
                                         self.after_cure["BL"],
                                         self.after_cure["BR"]]) / 4 >= float(ui.mtf_excel["Afc Corner avg criteria"]):
                                        logger.info("The AFC MTF values achieved center and corner")
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "AFC MTF values achieved in " \
                                                                        "center & corner"
                                        self.validation_done = True

                                    else:
                                        if self.after_cure[ui.consider_focus_chart] < \
                                                float(ui.mtf_excel["Center avg criteria"]):
                                            logger.debug("The AFC MTF center value less than threshold")
                                            self.overall_result_list["Fixture offset remarks"] = "The AFC MTF center " \
                                                                                                 "value less than criteria"

                                        elif sum([self.after_cure["TL"],
                                                  self.after_cure["TR"],
                                                  self.after_cure["BL"],
                                                  self.after_cure["BR"]]) / 4 < float(
                                            ui.mtf_excel["Afc Corner avg criteria"]):  # Another config
                                            logger.debug("The AFC MTF corners value less than threshold")
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "The AFC MTF corners value " \
                                                                            "less than criteria"
                                        else:
                                            logger.debug("The AFC lens offset value is not within the "
                                                         "tolerance: dx {} and dy {}".format(dx, dy))
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "Before-glue lens offset " \
                                                                            "value is out of tolerance."
                                        self.validation_done = "Failed"

                                elif ui.mtf_excel["Overall avg"]:  # Another config
                                    if self.after_cure['All'] >= float(
                                            ui.mtf_excel["Afc Overall avg criteria"]):
                                        logger.debug("The AFC overall MTF avg achieved threshold")
                                        self.overall_result_list["Fixture offset remarks"] = "The AFC overall " \
                                                                                             "MTF avg achieved threshold"
                                        self.validation_done = True

                                    else:
                                        logger.debug("The AFC overall MTF avg less than threshold")
                                        self.overall_result_list["Fixture offset remarks"] = "The AFC overall " \
                                                                                             "MTF avg less than threshold"
                                        self.validation_done = "Failed"

                            except Exception as e:
                                logger.error("Exception occurred in After cure result {}".format(e))
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "Exception occurred in After cure result"
                                self.validation_done = False

                            excel_info = []
                            for label in ui.rois.keys():
                                if self.after_cure[label] == 0:
                                    excel_info.append('NA')
                                else:
                                    excel_info.append(self.after_cure[label])

                            if self.after_cure['All'] == 0:
                                excel_info.append("NA")
                            else:
                                excel_info.append(self.after_cure['All'])

                            self.signals.update_results.emit(frame, self.image_roi.image,
                                                             "after_cure", self.withoutdb8bit)
                            self.overall_info.append(excel_info)

                            ui.after_curing_clicked = False
                            del self.final_result
                            del self.image_roi
                            del frame
                            gc.collect()
                            break

                        else:
                            logger.info(f"After cure iteration : {self.after_cure_iteration}")
                            self.after_cure_iteration += 1
                            if self.after_cure_iteration >= 10:
                                logger.debug("MTF value difference is more for after curing validation")
                                try:
                                    if ui.mtf_excel["Center avg only"]:
                                        if self.mtf_roi_avg["C"][-1] >= float(
                                                ui.mtf_excel["Afc Center avg criteria"]):  # Another config
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC MTF values achieved in " \
                                                                            "center avg criteria"
                                            self.validation_done = True

                                        else:
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC MTF values less than in" \
                                                                            "center avg criteria"
                                            self.validation_done = "Failed"

                                    elif ui.mtf_excel["Center and Corners each region avg"]:
                                        if self.mtf_roi_avg["TL"][-1] >= float(
                                                ui.mtf_excel["Afc TL avg criteria"]) and \
                                                self.mtf_roi_avg["TR"][-1] >= float(
                                            ui.mtf_excel["Afc TR avg criteria"]) and \
                                                self.mtf_roi_avg["BL"][-1] >= float(
                                            ui.mtf_excel["Afc BL avg criteria"]) and \
                                                self.mtf_roi_avg["BR"][-1] >= float(
                                            ui.mtf_excel["Afc BR avg criteria"]) and \
                                                self.mtf_roi_avg["C"][-1] >= float(
                                            ui.mtf_excel["Afc Center avg criteria"]):  # Another config
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC MTF values achieved in" \
                                                                            "Center & all corners region"
                                            self.validation_done = True
                                        else:
                                            # Another config
                                            if self.mtf_roi_avg["Center avg criteria"][-1] < float(
                                                    ui.mtf_excel["Afc Center avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFC C MTF avg less than threshold"
                                            elif self.mtf_roi_avg["TL"][-1] < float(
                                                    ui.mtf_excel["Afc TL avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFC TL MTF avg less than in" \
                                                                                "TL corner region"
                                            elif self.mtf_roi_avg["TR"][-1] < float(
                                                    ui.mtf_excel["Afc TR avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFC TR MTF avg less than in" \
                                                                                "TR corner region"
                                            elif self.mtf_roi_avg["BL"][-1] < float(
                                                    ui.mtf_excel["Afc BL avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFC BL MTF avg less than in" \
                                                                                "BL corner region"
                                            elif self.mtf_roi_avg["BR"][-1] < float(
                                                    ui.mtf_excel["Afc BR avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFC BR MTF avg less than in" \
                                                                                "BR corner region"
                                            self.validation_done = "Failed"

                                    elif ui.mtf_excel["Corners each region avg"]:  # Another config
                                        if self.mtf_roi_avg["TL"][-1] >= float(ui.mtf_excel["Afc TL avg criteria"]) and \
                                                self.mtf_roi_avg["TR"][-1] >= float(
                                            ui.mtf_excel["Afc TR avg criteria"]) and \
                                                self.mtf_roi_avg["BL"][-1] >= float(
                                            ui.mtf_excel["Afc BL avg criteria"]) and \
                                                self.mtf_roi_avg["BR"][-1] >= float(
                                            ui.mtf_excel["Afc BR avg criteria"]):
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC MTF values achieved in" \
                                                                            "all corners region"
                                            self.validation_done = True
                                        else:
                                            if self.mtf_roi_avg["TL"][-1] < float(
                                                    ui.mtf_excel["Afc TL avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFC TL MTF avg less than in" \
                                                                                "TL corner region"
                                            elif self.mtf_roi_avg["TR"][-1] < float(
                                                    ui.mtf_excel["Afc TR avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFC TR MTF avg less than in" \
                                                                                "TR corner region"
                                            elif self.mtf_roi_avg["BL"][-1] < float(
                                                    ui.mtf_excel["Afc BL avg criteria"]):  # Another config
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFC BL MTF avg less than in" \
                                                                                "BL corner region"
                                            elif self.mtf_roi_avg["BR"][-1] < float(
                                                    ui.mtf_excel["Afc BR avg criteria"]):
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "AFC BR MTF avg less than in" \
                                                                                "BR corner region"
                                            self.validation_done = "Failed"

                                    elif ui.mtf_excel["Corners all region avg"]:
                                        if sum([self.mtf_roi_avg["TL"][-1], self.mtf_roi_avg["TR"][-1],
                                                self.mtf_roi_avg["BL"][-1], self.mtf_roi_avg["BR"][-1]]) / 4 >= float(
                                            ui.mtf_excel["Afc Corner avg criteria"]):
                                            logger.info("The AFC MTF values achieved Corners all region avg")
                                            self.overall_result_list["Fixture offset remarks"] = "The AFC MTF values " \
                                                                                                 "achieved Corners all region avg"
                                            self.validation_done = True
                                        else:
                                            logger.info("The AFC MTF values less than Corners all region avg")
                                            self.overall_result_list["Fixture offset remarks"] = "The AFC MTF values " \
                                                                                                 "lessthan Corners all region avg"
                                            self.validation_done = "Failed"

                                    elif ui.mtf_excel["Center avg and Corners all region avg"]:
                                        if self.mtf_roi_avg[ui.consider_focus_chart][-1] >= float(
                                                ui.mtf_excel["Afc Center avg criteria"]) and sum(
                                            [self.mtf_roi_avg["TL"][-1],
                                             self.mtf_roi_avg["TR"][-1],
                                             self.mtf_roi_avg["BL"][-1],
                                             self.mtf_roi_avg["BR"][
                                                 -1]]) / 4 >= float(
                                            ui.mtf_excel["Afc Corner avg criteria"]):  # Another config
                                            logger.info("The AFC MTF values achieved center and corner")
                                            self.overall_result_list[
                                                "Fixture offset remarks"] = "AFC MTF values achieved in " \
                                                                            "center & corner "
                                            self.validation_done = True

                                        else:
                                            if self.mtf_roi_avg[ui.consider_focus_chart][-1] < \
                                                    float(ui.mtf_excel["Afc Center avg criteria"]):
                                                logger.debug("The AFC MTF center value less than threshold")
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "The AFC MTF center " \
                                                                                "value less than criteria"

                                            elif sum([self.mtf_roi_avg["TL"][-1],
                                                      self.mtf_roi_avg["TR"][-1],
                                                      self.mtf_roi_avg["BL"][-1],
                                                      self.mtf_roi_avg["BR"][-1]]) / 4 < float(
                                                ui.mtf_excel["Afc Corner avg criteria"]):
                                                logger.debug("The AFC MTF corners value less than threshold")
                                                self.overall_result_list[
                                                    "Fixture offset remarks"] = "The AFC MTF corners value " \
                                                                                "less than criteria"
                                            else:
                                                logger.debug("The AFC lens offset value is not within the "
                                                             "tolerance: dx {} and dy {}".format(dx,
                                                                                                 dy))  # Another config
                                                self.overall_result_list["Fixture offset remarks"] = "AFC lens offset " \
                                                                                                     "value is out of tolerance."
                                            self.validation_done = "Failed"

                                    elif ui.mtf_excel["Overall avg"]:
                                        if self.mtf_roi_avg['All'][-1] >= float(
                                                ui.mtf_excel["Afc Overall avg criteria"]):  # Another config
                                            logger.debug("The AFC overall MTF avg achieved threshold")
                                            self.overall_result_list["Fixture offset remarks"] = "The AFC overall " \
                                                                                                 "MTF avg achieved threshold"
                                            self.validation_done = True
                                        else:
                                            logger.debug("The AFC overall MTF avg less than threshold")
                                            self.overall_result_list["Fixture offset remarks"] = "The AFC overall " \
                                                                                                 "MTF avg less than threshold"
                                            self.validation_done = "Failed"
                                except Exception as e:
                                    logger.error("Exception occurred in after curing result {}".format(e))
                                    self.overall_result_list[
                                        "Fixture offset remarks"] = "Exception occurred in after curing result"
                                    self.validation_done = False

                                excel_info = []

                                for label in ui.rois.keys():
                                    if self.after_cure[label] == 0:
                                        excel_info.append('NA')
                                    else:
                                        excel_info.append(self.after_cure[label])

                                if self.after_cure['All'] == 0:
                                    excel_info.append("NA")
                                else:
                                    excel_info.append(self.after_cure['All'])
                                self.signals.update_results.emit(frame, self.image_roi.image,
                                                                 "after_cure", self.withoutdb8bit)
                                self.overall_info.append(excel_info)
                                ui.after_curing_clicked = False
                                del self.image_roi
                                del self.final_result
                                break

                            else:
                                display_image = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)
                                display_image = cv2.resize(display_image, self.dim,
                                                           interpolation=cv2.INTER_AREA)
                                height, width, channel = display_image.shape
                                step = channel * width
                                qt_img = QImage(display_image.data, width, height, step, QImage.Format_RGB888)
                                self.signals.call_updateLbl.emit(qt_img)
                                del self.image_roi
                                del self.final_result
                                continue

                    elif ui.get_result_clicked:
                        if not self.ip_status:
                            self.start_ip_check = False
                            catch_error = self.catch_and_clear_error(status=self.status_input)
                            if catch_error == "Not Done":
                                del frame
                                gc.collect()
                                self.ip_status = False
                                ui.validation_clicked = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "User cancelled the sequence in before glue check"
                                return

                            elif catch_error == "Done":
                                time.sleep(1)
                                self.ip_status = True

                            else:
                                del frame
                                gc.collect()
                                self.ip_status = False
                                ui.validation_clicked = False
                                self.overall_result_list[
                                    "Fixture offset remarks"] = "Error occurred in catch & clear else case in BFG check"
                                return

                        caluclatable_frames = int(ui.mtf_excel["Median frames count"])
                        if ui.mtf_excel["Final Test"]:  # Another config
                            self.frames_append = []
                            for nof_calculatableFrames in range(caluclatable_frames):
                                ret, frame = self.read_frames()
                                if ret:
                                    self.frames_append.append(frame)

                        for i in range(caluclatable_frames):
                            self.thread_median_cal(self.frames_append[i])
                        try:
                            self.before_median = self.calculation()
                            roi_list = ["TL", "TR", "C", "BL", "BR"]
                            length_roi_list = [len(self.final_result.roi_mtf_value[i]) for i in roi_list]
                            length = 0
                            for index, i in enumerate(length_roi_list):
                                for j in range(i):
                                    self.final_result.roi_mtf_value[roi_list[index]][j]['roi_lum']['mtf50'] = \
                                        self.before_median[length]
                                    length += 1
                        except Exception as e:
                            logger.debug("error in self.before median cal", e)
                            self.before_median = []
                            for label in ui.rois.keys():
                                for x in range(4):
                                    try:
                                        self.before_median.append(
                                            round(self.final_result.roi_mtf_value[label][x]
                                                  ['roi_lum']['mtf50'], 3))
                                    except (IndexError, KeyError):
                                        self.before_median.append("NA")

                        if self.image_roi.image.shape[0] > 1440:
                            overall_avg = []
                            for roi_position, regions in self.final_result.roi_mtf_value.items():
                                if regions:
                                    roi_avg = []
                                    for i in range(len(regions)):
                                        try:
                                            roi_avg.append(round(self.final_result.roi_mtf_value[roi_position][i][
                                                                     'roi_lum'][
                                                                     'mtf50'], 3))
                                            cv2.putText(self.image_roi.image, 'Reg:{}'.format(i + 1),
                                                        (
                                                            self.final_result.roi_mtf_value[roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[roi_position][i][
                                                                'roi_pt'][0][1] + 0),
                                                        cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0),
                                                        2,
                                                        cv2.LINE_AA)
                                            cv2.putText(self.image_roi.image, '{}'.format(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3)),
                                                        (
                                                            self.final_result.roi_mtf_value[roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[roi_position][i][
                                                                'roi_pt'][0][1] + 45),
                                                        cv2.FONT_HERSHEY_SIMPLEX, 1.2,
                                                        (0, 255, 0), 2,
                                                        cv2.LINE_AA)
                                        except KeyError:
                                            logger.debug("MTF50 value is empty")
                                    if len(roi_avg) != 0:
                                        cv2.putText(self.image_roi.image,
                                                    'Avg: {}'.format(
                                                        round(sum(roi_avg) / len(roi_avg), 3)),
                                                    (ui.rois[roi_position][3] - 220,
                                                     ui.rois[roi_position][0] + 45),
                                                    cv2.FONT_HERSHEY_SIMPLEX, 1.2,
                                                    (0, 255, 0), 2, cv2.LINE_AA)
                                        overall_avg.append(round(sum(roi_avg) / len(roi_avg), 3))
                                        self.before_glue[roi_position] = round(sum(roi_avg) / len(roi_avg), 3)
                                    else:
                                        logger.debug("MTF value is not get in this region "
                                                     "{}".format(roi_position))
                                else:
                                    logger.debug("MTF value is not get in this region "
                                                 "{}".format(roi_position))

                            if len(overall_avg) != 0:
                                self.before_glue['All'] = round(sum(overall_avg) / len(overall_avg), 3)
                                cv2.putText(self.image_roi.image, 'Overall Avg: {}'.format(
                                    round(sum(overall_avg) / len(overall_avg), 3)),
                                            (45, 65), cv2.FONT_HERSHEY_SIMPLEX, 2, (0, 255, 0), 2,
                                            cv2.LINE_AA)
                            else:
                                logger.debug("ROI are not detected in this frame")

                        else:
                            overall_avg = []
                            for roi_position, regions in self.final_result.roi_mtf_value.items():
                                if regions:
                                    roi_avg = []
                                    for i in range(len(regions)):
                                        try:
                                            roi_avg.append(round(self.final_result.roi_mtf_value[roi_position][i]
                                                                 ['roi_lum']['mtf50'], 3))
                                            cv2.putText(self.image_roi.image, 'Reg:{}'.format(i + 1),
                                                        (self.final_result.roi_mtf_value[roi_position][i]['roi_pt'][0][
                                                             0],
                                                         self.final_result.roi_mtf_value[roi_position][i][
                                                             'roi_pt'][0][1] + 0),
                                                        cv2.FONT_HERSHEY_SIMPLEX, .5, (0, 255, 0),
                                                        1,
                                                        cv2.LINE_AA)
                                            cv2.putText(self.image_roi.image, '{}'.format(round(
                                                self.final_result.roi_mtf_value[roi_position][i][
                                                    'roi_lum'][
                                                    'mtf50'], 3)),
                                                        (
                                                            self.final_result.roi_mtf_value[roi_position][i][
                                                                'roi_pt'][0][0],
                                                            self.final_result.roi_mtf_value[roi_position][i][
                                                                'roi_pt'][0][1] + 45),
                                                        cv2.FONT_HERSHEY_SIMPLEX, .7, (0, 255, 0),
                                                        2,
                                                        cv2.LINE_AA)
                                        except KeyError:
                                            logger.debug("MTF50 value is empty")

                                    if len(roi_avg) != 0:
                                        cv2.putText(self.image_roi.image,
                                                    'Avg: {}'.format(
                                                        round(sum(roi_avg) / len(roi_avg), 3)),
                                                    (ui.rois[roi_position][3] - 150,
                                                     ui.rois[roi_position][0] + 35),
                                                    cv2.FONT_HERSHEY_SIMPLEX, .9, (0, 255, 0), 2,
                                                    cv2.LINE_AA)
                                        overall_avg.append(round(sum(roi_avg) / len(roi_avg), 3))
                                        self.before_glue[roi_position] = round(sum(roi_avg) / len(roi_avg), 3)
                                    else:
                                        logger.debug("MTF value is not get in this region "
                                                     "{}".format(roi_position))
                                else:
                                    logger.debug("MTF value is not get in this region "
                                                 "{}".format(roi_position))

                            if len(overall_avg) != 0:
                                self.before_glue['All'] = round(sum(overall_avg) / len(overall_avg), 3)
                                cv2.putText(self.image_roi.image, 'Overall Avg: {}'.format(
                                    round(sum(overall_avg) / len(overall_avg), 3)),
                                            (25, 45), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 2,
                                            cv2.LINE_AA)
                            else:
                                logger.debug("ROI are not detected in this frame")

                        display_image = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)
                        display_image = cv2.resize(display_image, self.dim, interpolation=cv2.INTER_AREA)
                        height, width, channel = display_image.shape
                        step = channel * width
                        qt_img = QImage(display_image.data, width, height, step, QImage.Format_RGB888)
                        self.signals.call_updateLbl.emit(qt_img)
                        try:
                            # Another config
                            if ui.mtf_excel["Center avg only"]:
                                if self.before_glue["C"] >= float(
                                        ui.mtf_excel["Center avg criteria"]):
                                    self.overall_result_list["Fixture offset remarks"] = "BFG MTF values achieved in " \
                                                                                         "center avg criteria"
                                    self.validation_done = True

                                else:
                                    self.overall_result_list["Fixture offset remarks"] = "BFG MTF values less than" \
                                                                                         "center avg criteria"
                                    self.validation_done = "Failed"

                            elif ui.mtf_excel["Center and Corners each region avg"]:
                                if self.before_glue["TL"] >= float(ui.mtf_excel["TL avg criteria"]) and \
                                        self.before_glue["TR"] >= float(ui.mtf_excel["TR avg criteria"]) and \
                                        self.before_glue["BL"] >= float(ui.mtf_excel["BL avg criteria"]) and \
                                        self.before_glue["BR"] >= float(ui.mtf_excel["BR avg criteria"]) and \
                                        self.before_glue["C"] >= float(ui.mtf_excel["Center avg criteria"]):
                                    self.overall_result_list["Fixture offset remarks"] = "BFG MTF values achieved in" \
                                                                                         "Center & all corners region"
                                    self.validation_done = True
                                else:
                                    if self.before_glue["C"] < float(ui.mtf_excel["Center avg criteria"]):
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "BFG C MTF avg less than threshold"
                                    elif self.before_glue["TL"] < float(ui.mtf_excel["TL avg criteria"]):
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "BFG TL MTF avg less than threshold"
                                    elif self.before_glue["TR"] < float(ui.mtf_excel["TR avg criteria"]):
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "BFG TR MTF avg less than threshold"
                                    elif self.before_glue["BL"] < float(ui.mtf_excel["BL avg criteria"]):
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "BFG BL MTF avg less than threshold"
                                    elif self.before_glue["BR"] < float(ui.mtf_excel["BR avg criteria"]):
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "BFG BR MTF avg less than threshold"

                                    self.validation_done = "Failed"

                            elif ui.mtf_excel["Corners each region avg"]:
                                if self.before_glue["TL"] >= float(ui.mtf_excel["TL avg criteria"]) and \
                                        self.before_glue["TR"] >= float(ui.mtf_excel["TR avg criteria"]) and \
                                        self.before_glue["BL"] >= float(ui.mtf_excel["BL avg criteria"]) and \
                                        self.before_glue["BR"] >= float(ui.mtf_excel["BR avg criteria"]):
                                    self.overall_result_list["Fixture offset remarks"] = "BFG MTF values achieved in" \
                                                                                         "all corners region"
                                    self.validation_done = True
                                else:
                                    if self.before_glue["TL"] < float(ui.mtf_excel["TL avg criteria"]):
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "BFG TL MTF avg less than threshold"
                                    elif self.before_glue["TR"] < float(ui.mtf_excel["TR avg criteria"]):
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "BFG TR MTF avg less than threshold"
                                    elif self.before_glue["BL"] < float(ui.mtf_excel["BL avg criteria"]):
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "BFG BL MTF avg less than threshold"
                                    elif self.before_glue["BR"] < float(ui.mtf_excel["BR avg criteria"]):
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "BFG BR MTF avg less than threshold"
                                    self.validation_done = "Failed"

                            elif ui.mtf_excel["Corners all region avg"]:
                                if sum([self.before_glue["TL"], self.before_glue["TR"],
                                        self.before_glue["BL"], self.before_glue["BR"]]) / 4 >= float(
                                    ui.mtf_excel["Corner avg criteria"]):
                                    logger.info("The BFG MTF values achieved Corners all region avg")
                                    self.overall_result_list["Fixture offset remarks"] = "The BFG MTF values " \
                                                                                         "achieved Corners all region avg"
                                    self.validation_done = True
                                else:
                                    logger.info("The BFG MTF values less than Corners all region avg")
                                    self.overall_result_list["Fixture offset remarks"] = "The BFG MTF values " \
                                                                                         "lessthan Corners all region avg"
                                    self.validation_done = "Failed"

                            elif ui.mtf_excel["Center avg and Corners all region avg"]:
                                if self.before_glue[ui.consider_focus_chart] >= float(
                                        ui.mtf_excel["Center avg criteria"]) and sum([self.before_glue["TL"],
                                                                                      self.before_glue["TR"],
                                                                                      self.before_glue["BL"],
                                                                                      self.before_glue[
                                                                                          "BR"]]) / 4 >= float(
                                    ui.mtf_excel["Corner avg criteria"]):
                                    logger.info("The BFG MTF values achieved center and corner")
                                    self.overall_result_list["Fixture offset remarks"] = "BFG MTF values achieved in " \
                                                                                         "center & corner"
                                    self.validation_done = True

                                else:
                                    if self.before_glue[ui.consider_focus_chart] < \
                                            float(ui.mtf_excel["Center avg criteria"]):
                                        logger.debug("The BFG MTF center value less than threshold")
                                        self.overall_result_list["Fixture offset remarks"] = "The BFG MTF center " \
                                                                                             "value less than criteria"

                                    elif sum([self.before_glue["TL"],
                                              self.before_glue["TR"],
                                              self.before_glue["BL"],
                                              self.before_glue["BR"]]) / 4 < float(
                                        ui.mtf_excel["Corner avg criteria"]):
                                        logger.debug("The BFG MTF corners value less than threshold")
                                        self.overall_result_list[
                                            "Fixture offset remarks"] = "The BFG MTF corners value " \
                                                                        "less than criteria"


                                    else:
                                        logger.debug("The BFG lens offset value is not within the "
                                                     "tolerance: dx {} and dy {}".format(dx, dy))
                                        self.overall_result_list["Fixture offset remarks"] = "Before-glue lens offset " \
                                                                                             "value is out of tolerance."
                                    self.validation_done = "Failed"

                            elif ui.mtf_excel["Overall avg"]:
                                if self.before_glue['All'] >= float(ui.mtf_excel["Overall avg criteria"]):
                                    logger.debug("The BFG overall MTF avg achieved threshold")
                                    self.overall_result_list["Fixture offset remarks"] = "The BFG overall " \
                                                                                         "MTF avg achieved threshold"
                                    self.validation_done = True
                                else:
                                    logger.debug("The BFG overall MTF avg less than threshold")
                                    self.overall_result_list["Fixture offset remarks"] = "The BFG overall " \
                                                                                         "MTF avg less than threshold"
                                    self.validation_done = "Failed"

                        except Exception as e:
                            exc_type, exc_obj, exc_tb = sys.exc_info()
                            f_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
                            logger.error(
                                "Exception occurred in before glue result :{}|{}|{}|{}".format(exc_type, f_name,
                                                                                               exc_tb.tb_lineno, e))
                            self.overall_result_list[
                                "Fixture offset remarks"] = "Exception occurred in before glue result"
                            self.validation_done = False

                        excel_info = []
                        for label in ui.rois.keys():
                            if self.before_glue[label] == 0:
                                excel_info.append('NA')
                            else:
                                excel_info.append(self.before_glue[label])

                        if self.before_glue['All'] == 0:
                            excel_info.append("NA")
                        else:
                            excel_info.append(self.before_glue['All'])
                        self.overall_info.append(excel_info)

                        if not ui.excel["After glue focus"][ui.setup_type]:
                            excel_info = []
                            for label in ui.rois.keys():
                                if self.after_glue[label] == 0:
                                    excel_info.append('NA')
                                else:
                                    excel_info.append(self.after_glue[label])

                            if self.after_glue['All'] == 0:
                                excel_info.append("NA")
                            else:
                                excel_info.append(self.after_glue['All'])
                            self.overall_info.append(excel_info)

                        if not ui.mtf_excel["Final Test"] and self.validation_done:  # Another config
                            pass
                        self.signals.update_results.emit(frame, self.image_roi.image, "before_glue", self.withoutdb8bit)

                        del self.final_result
                        ui.get_result_clicked = False
                        del self.image_roi
                        del frame
                        gc.collect()
                        break  # break the for loop

                    else:
                        try:
                            display_image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                        except Exception as e:
                            pass
                    try:
                        display_image = cv2.resize(display_image, self.dim, interpolation=cv2.INTER_AREA)
                        height, width, channel = display_image.shape
                        step = channel * width
                        qt_img = QImage(display_image.data, width, height, step, QImage.Format_RGB888)
                        self.signals.call_updateLbl.emit(qt_img)
                        del frame
                        del qt_img
                        del display_image
                        gc.collect()

                    except Exception as e:
                        pass

                elif not ret:
                    for x in range(int(self.fps)):
                        _, __ = self.cap.read()
                        logger.error('Frame skip')
                    ret_false_count += 1
                    time.sleep(1)
                    if ret_false_count == 5:
                        self.validation_done = False
                        self.start_ip_check = False
                        ui.validation_clicked = False
                        self.overall_result_list["Fixture offset remarks"] = "Frame not received"
                        return
                else:
                    for x in range(int(self.fps)):
                        _, __ = self.cap.read()
                        logger.error('Frame skip')
                    time.sleep(1)
                    if self.gr_fr_rec == 5:
                        self.validation_done = False
                        self.start_ip_check = False
                        ui.validation_clicked = False
                        self.overall_result_list["Fixture offset remarks"] = "Frame not received"
                        return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at Streaming function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.validation_done = False
            self.start_ip_check = False
            ui.validation_clicked = False
            self.overall_result_list["Fixture offset remarks"] = "Error at streaming func"
            return


class Runnable_streaming(QRunnable):
    def __init__(self, threadpool):
        """
        This class is used to run the Qrunnable thread for recipe creation streaming.
        """
        try:
            super(Runnable_streaming, self).__init__()
            try:
                self.cap = cv2.VideoCapture(0)
            except Exception as e:
                logger.error("got in to the exception, no cap", e)

            self.signals = WorkerSignals()
            self.eCAM_dll = None
            self.format_type = None
            self.image = None
            self.final_result = None
            self.firmware = None
            self.mtf_roi_avg = {"All": []}
            self.relay_roi = {"C": [], "TR": [], "TL": [], "BL": [], "BR": []}
            self.collimator_roi = {"C": [], "TR": [], "TL": [], "BL": [], "BR": []}
            self.threadpool = threadpool
            ui.exposure_box.currentIndexChanged.connect(self.on_exposure_changed)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at Runnable init function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def run(self):
        """
        This function is used to call validate_center_alignment function.
        """
        try:
            logger.info("*********Thread Started!*************")
            self.threadpool.reserveThread()
            if ui.update:
                self.device_details()
                ui.update = False

            ui.get_device_btn.setEnabled(True)
            self.cap.release()
            cv2.destroyAllWindows()
            logger.info("Thread completed")
            self.threadpool.releaseThread()
            logger.info("*********Thread Completed!*************")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at run function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))
            self.cap.release()
            cv2.destroyAllWindows()
            logger.info("Thread completed")
            self.threadpool.releaseThread()
            logger.info("*********Thread Completed!*************")

    def get_firmware_version(self):
        try:
            """
                Used to get the Firmware version of the e-con camera for the give node using HID commands.
                 Parameters:
                 - node (int): camera node which was get using the get devices.
                 Returns:
                 str: Firmware version.
                                  """
            var = None
            self.firmware = None
            cam_info_1 = self.cap.getDeviceInfo(0)[2]
            cam_info_2 = self.cap.getDeviceInfo(0)[3]
            self.devices = hid.enumerate(
                int('0x' + cam_info_1, 16),
                int('0x' + cam_info_2, 16))
            self.device = hid.device()
            self.device.open_path(self.devices[0]["path"])
            # Refer the HID command.
            command = [0x00, 0x40]
            # Send the command to the camera
            self.device.write(command)
            # Read the response (adjust the length as per your expected response)
            response = self.device.read(65, 1000)
            SDK_VER = (response[3] << 8) + response[4]
            SVN_VER = (response[5] << 8) + response[6]
            pMajorVersion = response[1]
            pMinorVersion1 = response[2]
            self.firmware = str(pMajorVersion) + "." + str(pMinorVersion1) + "." + str(SDK_VER) + "." + str(SVN_VER)
            return self.firmware

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at get firmware function : {}|{}|{}|{}".format(exc_type, func_name, exc_tb.tb_lineno, e))

    def device_details(self):
        try:
            """
              This method is used to connect the camera.
              param lists: None
              return: None
            """
            logger.debug('clicked the get device button')
            if not self.cap.isOpened():
                self.signals.call_MsgBox.emit("Warning", "Please connect the camera", "Critical")
                return

            self.signals.update_statusbar.emit('Camera is connecting...')
            self.clear()
            ret, device_count = self.cap.getDevices()
            if not ret:
                logger.error("cap.getDevices Failed")
                self.signals.update_statusbar.emit('Camera connection failed.')
                self.signals.call_MsgBox.emit("Enumeration Failed!", "cap.getDevices Failed", "Critical")
                return

            logger.info(f"Total Number of devices:{device_count}")
            device_list = []
            for i in range(0, device_count):
                ret, device_name, vid, pid, device_path = self.cap.getDeviceInfo(i)
                device_list.append(device_name)
            logger.info(f"Connected devices:{device_list}")
            self.signals.update_device_text.emit("Camera name", device_list[0])

            get_exposure = self.cap.get(cv2.CAP_PROP_EXPOSURE, -1, -1, -1, -1, -1, -1, -1)
            exposure_list = ["Auto"]
            for i in range(get_exposure[1], get_exposure[2] + 1):
                exposure_list.append(str(i))
            for x in exposure_list:
                if x in [ui.exposure_box.itemText(i) for i in range(ui.exposure_box.count())]:
                    pass
                else:
                    ui.exposure_box.addItem(x)
            self.signals.update_device_text.emit("Exposure", exposure_list[0])

            ret, total_formats = self.cap.getFormats()
            if not ret:
                logger.error("cap.getFormats Failed")
                self.signals.update_statusbar.emit('Camera connection failed.')
                self.signals.call_MsgBox.emit("Enumeration Failed!", "cap.getFormats Failed", "Critical")
                return

            resolution_list = []
            for cnt in range(total_formats):
                ret, self.format_type, width, height, fps = self.cap.getFormatType(cnt)
                if not ret:
                    logger.error("cap.getFormatType Failed")
                    self.signals.update_statusbar.emit('Camera connection failed.')
                    self.signals.call_MsgBox.emit("Enumeration Failed!", "cap.getFormatType Failed",
                                                  "Critical")
                    return

                elif self.format_type == "MJPEG" or self.format_type == "MJPG" or self.format_type == "Y16":
                    continue
                else:
                    resolution_list.append(str(self.cap.getFormatType(cnt)))
            self.signals.update_device_text.emit("Resolution", resolution_list)
            firmware_version = self.get_firmware_version()
            if firmware_version is not None:
                ui.firmware_value_lbl.setText(str(firmware_version))
            ui.camera_connect = True
            self.signals.update_statusbar.emit('Camera is connected.')
            self.format_type = "".join(
                [chr((int(self.cap.get(cv2.CAP_PROP_FOURCC)) >> 8 * i) & 0xFF) for i in range(4)])
            self.format_type = self.format_type.strip()
            self.streaming()

        except cv2.error as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at device details function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at device details function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def on_exposure_changed(self):
        try:
            """
              This method is used to set the exposure.
              param lists: None
              return: None
            """
            get_exposure = ui.exposure_box.currentText()
            if get_exposure == "Auto":
                if self.cap.set(cv2.CAP_PROP_EXPOSURE, -5, 1):
                    logger.debug('exposure value: Auto')
                else:
                    logger.error('CAP_PROP_EXPOSURE is Failed')
                    self.signals.call_MsgBox.emit("Enumeration Failed!",
                                                  "CAP_PROP_EXPOSURE is Failed", "Critical")
                return
            else:
                value = int(get_exposure)
                if self.cap.set(cv2.CAP_PROP_EXPOSURE, value, 2):
                    logger.debug('exposure value: {}'.format(self.cap.get(cv2.CAP_PROP_EXPOSURE)))
                else:
                    logger.error('CAP_PROP_EXPOSURE is Failed')
                    self.signals.call_MsgBox.emit("Enumeration Failed!",
                                                  "CAP_PROP_EXPOSURE is Failed", "Critical")
                    return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at on_exposure_changed function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def clear(self):
        try:
            """
              This method is used to clear the textboxes and labels in recipe creation page.
              param lists: None
              return: None
            """
            ui.collimator_simulate_clicked = False
            ui.collimator_clicked = False
            ui.collimator_chart_check_clicked = False
            ui.collimator_validation = False
            ui.relay_validation = False
            ui.collimator_offset_clicked = False
            ui.relay_simulate_clicked = False
            ui.relay_clicked = False
            ui.relay_chart_check_clicked = False
            ui.relay_offset_clicked = False
            ui.device_name_box.clear()
            ui.exposure_box.clear()
            ui.resolution_box.currentIndexChanged.disconnect(ui.on_resolution_changed)
            ui.resolution_box.clear()
            ui.resolution_box.currentIndexChanged.connect(ui.on_resolution_changed)
            ui.device_name_box.setText("No Devices")
            ui.firmware_value_lbl.setText("None")
            ui.collimator_azimuth_lndt.setText("")
            ui.collimator_radius_lndt.setText("")
            ui.collimator_width_lndt.setText("")
            ui.collimator_height_lndt.setText("")
            ui.no_of_ROI_txtbox.setCurrentText("5")
            ui.chart_position_box.setCurrentText("C, TL, TR, BL, BR")
            ui.azimuth_ang_txtbox.setText("")
            ui.outer_radius_txtbox.setText("")
            ui.width_txtbox.setText("")
            ui.height_txtbox.setText("")
            ui.inr_radius_txtbox.setText("")
            ui.inr_azimuth_ang_txtbox.setText("")
            ui.collimator_red_value_lndt.setText("")
            ui.collimator_blue_value_lndt.setText("")
            ui.collimator_green_value_lndt.setText("")
            ui.relay_red_value_lndt.setText("")
            ui.relay_blue_value_lndt.setText("")
            ui.relay_green_value_lndt.setText("")
            ui.relay_black_lvl_value_lndt.setText("")
            ui.collimator_black_lvl_value_lndt.setText("")
            ui.collimator_median_frame_cnt_lndt.setText("")
            ui.relay_median_frame_cnt_lndt.setText("")
            ui.get_device_btn.setEnabled(True)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at recipe creation clear function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def calculation(self):
        try:
            """
              This method is used to calculate the median.
              param lists: None
              return: None
            """
            average_results = []
            max_results = []
            min_results = []
            median = []
            for i in range(len(self.final_outputs[0])):
                dummy = []
                for j in range(len(self.final_outputs)):
                    dummy.append(self.final_outputs[j][i])
                dummy.sort()

                median.append(np.median(dummy))
                max_results.append(np.max(dummy))
                min_results.append(np.min(dummy))
                average_results.append(np.mean(dummy))
            self.final_outputs = []
            return median

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at calculation function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def thread_median_cal(self, frame, roi_type=None, setup_type="Relay station"):
        try:
            """
              This method is used to mtf roi selection.
              param lists: frame is object, roi_type is dict, setup_type is str
              return: None
            """
            result = []
            self.image_roi = mtf.ROISelection(input_image=self.processed_frame,
                                              cropped_area_coordinate=roi_type,
                                              setup=setup_type, roi_frame=frame)
            roi_count = 0
            for r, s in self.image_roi.cropped_roi.items():
                roi_count += 1
                if s:
                    self.final_result = mtf.MTFCalculation("Monochrome", roi_list=self.image_roi.cropped_roi,
                                                           all_channel=False)
                    break
                else:
                    logger.error('MTF ROI are not detected')
                    display_image = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)

            try:
                roi_list = ["TL", "TR", "C", "BL", "BR"]
                length_roi_list = [len(self.final_result.roi_mtf_value[i]) for i in roi_list]
                tl = [round(self.final_result.roi_mtf_value['TL'][i]['roi_lum']['mtf50'], 3) for i in
                      range(length_roi_list[0])]
                tr = [round(self.final_result.roi_mtf_value['TR'][i]['roi_lum']['mtf50'], 3) for i in
                      range(length_roi_list[1])]
                c = [round(self.final_result.roi_mtf_value['C'][i]['roi_lum']['mtf50'], 3) for i in
                     range(length_roi_list[2])]
                bl = [round(self.final_result.roi_mtf_value['BL'][i]['roi_lum']['mtf50'], 3) for i in
                      range(length_roi_list[3])]
                br = [round(self.final_result.roi_mtf_value['BR'][i]['roi_lum']['mtf50'], 3) for i in
                      range(length_roi_list[4])]
                for i in tl, tr, c, bl, br:
                    result.append(i)
                result_to_avg = sum(result, [])
                self.final_outputs.append(result_to_avg)
                result = []

            except Exception as e:
                logger.error(f"ROI list error {e}")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at thread median cal function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def channel_normalization(self, y8_frame):
        try:
            """Read RGB values as list from config file
            self.rgb_values[0] - R, self.rgb_values[1] - G, self.rgb_valuFes[2] - B and get Bayer pattern as input"""

            blue_ratio = float(
                float(ui.collimator_green_value_lndt.text()) / float(ui.collimator_blue_value_lndt.text()))
            red_ratio = float(float(ui.collimator_green_value_lndt.text()) / float(ui.collimator_red_value_lndt.text()))

            if ui.excel["Raw FW"]["Loading"].split(",")[1] == "GB":
                """GRBG"""
                for y in range(y8_frame.shape[0]):
                    if y % 2 == 0:
                        y8_frame[y, 1:][::2] = (y8_frame[y, 1:][::2] * red_ratio).clip(0, 255)
                    elif y % 2 != 0:
                        y8_frame[y, :][::2] = (y8_frame[y, :][::2] * blue_ratio).clip(0, 255)

            elif ui.excel["Raw FW"]["Loading"].split(",")[1] == "BG":
                """RGGB"""
                for y in range(y8_frame.shape[0]):
                    if y % 2 == 0:
                        y8_frame[y, :][::2] = (y8_frame[y, :][::2] * red_ratio).clip(0, 255)
                    elif y % 2 != 0:
                        y8_frame[y, 1:][::2] = (y8_frame[y, 1:][::2] * blue_ratio).clip(0, 255)
            return y8_frame

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at channel normalization function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            return

    def read_frames(self):
        try:
            """
              This method is used to read the frames.
              param lists: None
              return: None
            """
            gr_rec = 0
            if self.cap.isOpened():
                ret, frame = self.cap.read()
                if ret:
                    if np.sum(frame) != 0:
                        gr_rec = 0

                        if self.format_type == "UYVY":
                            ui.change_format_type = False
                            frame = cv2.cvtColor(frame, cv2.COLOR_YUV2BGR_UYVY)

                        elif self.format_type == "YUY2":
                            ui.change_format_type = False
                            frame = cv2.cvtColor(frame, cv2.COLOR_YUV2BGR_YUY2)

                        elif self.format_type == 'Y8':
                            if ui.change_format_type:
                                ui.change_format_type = False
                                if ui.collimator_black_lvl_value_lndt.text() != "":
                                    frame = self.black_level_subtraction(frame)

                                self.frame_to_cn = frame.copy()
                                """Add Black Level Subtraction before DB/CN for before option also add if condition for before and after
                                BLS."""
                                if ui.img_frmt_box.currentText() == "CN":
                                    self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                    frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)

                                elif ui.img_frmt_box.currentText() == "Monochrome":
                                    self.processed_frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)

                                elif ui.img_frmt_box.currentText() == 'No':
                                    green_only = np.zeros((frame.shape[0] // 2, frame.shape[1] // 2),
                                                          dtype=np.uint8)
                                    for y in range(frame.shape[0]):
                                        if y % 2 == 0:
                                            green_only[y // 2, :] = frame[y, 1:][::2]

                                    frame = cv2.cvtColor(green_only, cv2.COLOR_GRAY2BGR)
                                    del green_only

                                elif ui.img_frmt_box.currentText() == "RG":
                                    self.processed_frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_RG2BGR)

                                elif ui.img_frmt_box.currentText() == "BG":
                                    self.processed_frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_BG2BGR)

                                elif ui.img_frmt_box.currentText() == "GR":
                                    self.processed_frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_GR2BGR)

                                elif ui.img_frmt_box.currentText() == "GB":
                                    self.processed_frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_GB2BGR)

                                if ui.img_frmt_box.currentText() != "CN" and \
                                        ui.img_frmt_box.currentText() != "Monochrome":
                                    frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)

                            else:
                                if ui.collimator_black_lvl_value_lndt.text() != "":
                                    frame = self.black_level_subtraction(frame)

                                self.frame_to_cn = frame.copy()
                                """Add Black Level Subtraction before DB/CN for before option also add if condition for before and after
                                BLS."""
                                if ui.img_frmt_box.currentText() == "CN":
                                    self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                    frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)

                                elif ui.img_frmt_box.currentText() == "Monochrome":
                                    frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)
                                    self.processed_frame = frame

                                elif ui.img_frmt_box.currentText() == 'No':
                                    green_only = np.zeros((frame.shape[0] // 2, frame.shape[1] // 2),
                                                          dtype=np.uint8)
                                    for y in range(frame.shape[0]):
                                        if y % 2 == 0:
                                            green_only[y // 2, :] = frame[y, 1:][::2]

                                    frame = cv2.cvtColor(green_only, cv2.COLOR_GRAY2BGR)
                                    del green_only

                                elif ui.img_frmt_box.currentText() == "RG":
                                    self.processed_frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_RG2BGR)

                                elif ui.img_frmt_box.currentText() == "BG":
                                    self.processed_frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_BG2BGR)

                                elif ui.img_frmt_box.currentText() == "GR":
                                    self.processed_frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_GR2BGR)

                                elif ui.img_frmt_box.currentText() == "GB":
                                    self.processed_frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_GB2BGR)

                        elif self.format_type == 'Y16':
                            frame = cv2.convertScaleAbs(frame, 0.000000065)

                        elif self.format_type == "Y12":
                            if ui.change_format_type:
                                ui.change_format_type = False
                                raw_bytes = frame.tobytes()
                                filtered_bytes = np.frombuffer(raw_bytes, dtype=np.uint8)
                                filtered_bytes = np.reshape(filtered_bytes, (-1, 3))
                                filtered_bytes = np.delete(filtered_bytes, 2, 1)
                                filtered_bytes = np.reshape(filtered_bytes, -1)
                                y8_frame = np.zeros(shape=(int(ui.resolution[1]), int(ui.resolution[0])),
                                                    dtype=np.uint8)
                                m = 0
                                for i in range(0, int(frame.shape[1])):
                                    y8_frame[i, :] = filtered_bytes[m:m + int(frame.shape[0])]
                                    m += int(frame.shape[0])

                                self.withoutdb8bit = y8_frame
                                if ui.collimator_black_lvl_value_lndt.text() != "":
                                    frame = self.black_level_subtraction(y8_frame)

                                self.frame_to_cn = frame.copy()
                                """Add Black Level Subtraction before DB/CN for before option also add if condition for before and after
                                BLS."""
                                if ui.img_frmt_box.currentText() == "CN":
                                    self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                    frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)

                                elif ui.img_frmt_box.currentText() == "Monochrome":
                                    self.processed_frame = frame = cv2.cvtColor(y8_frame, cv2.COLOR_GRAY2BGR)

                                elif ui.img_frmt_box.currentText() == 'No':
                                    green_only = np.zeros((y8_frame.shape[0] // 2, y8_frame.shape[1] // 2),
                                                          dtype=np.uint8)
                                    for y in range(y8_frame.shape[0]):
                                        if y % 2 == 0:
                                            green_only[y // 2, :] = y8_frame[y, 1:][::2]

                                    frame = cv2.cvtColor(green_only, cv2.COLOR_GRAY2BGR)
                                    del green_only

                                elif ui.img_frmt_box.currentText() == "RG":
                                    self.processed_frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_RG2BGR)

                                elif ui.img_frmt_box.currentText() == "BG":
                                    self.processed_frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_BG2BGR)

                                elif ui.img_frmt_box.currentText() == "GR":
                                    self.processed_frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_GR2BGR)

                                elif ui.img_frmt_box.currentText() == "GB":
                                    self.processed_frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_GB2BGR)

                                if ui.img_frmt_box.currentText() != "CN" and \
                                        ui.img_frmt_box.currentText() != "Monochrome":
                                    frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)

                                del y8_frame
                                del filtered_bytes

                            else:
                                raw_bytes = frame.tobytes()
                                filtered_bytes = np.frombuffer(raw_bytes, dtype=np.uint8)
                                filtered_bytes = np.reshape(filtered_bytes, (-1, 3))
                                filtered_bytes = np.delete(filtered_bytes, 2, 1)
                                filtered_bytes = np.reshape(filtered_bytes, -1)
                                y8_frame = np.zeros(shape=(int(frame.shape[1]), int(frame.shape[0])),
                                                    dtype=np.uint8)
                                m = 0
                                for i in range(0, int(frame.shape[1])):
                                    y8_frame[i, :] = filtered_bytes[m:m + int(frame.shape[0])]
                                    m += int(frame.shape[0])

                                self.withoutdb8bit = y8_frame
                                if ui.collimator_black_lvl_value_lndt.text() != "":
                                    frame = self.black_level_subtraction(y8_frame)

                                self.frame_to_cn = frame.copy()
                                """Add Black Level Subtraction before DB/CN for before option also add if condition for before and after
                                BLS."""
                                if ui.img_frmt_box.currentText() == "CN":
                                    self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                    frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)

                                elif ui.img_frmt_box.currentText() == "Monochrome":
                                    self.processed_frame = frame = cv2.cvtColor(y8_frame, cv2.COLOR_GRAY2BGR)

                                elif ui.img_frmt_box.currentText() == 'No':
                                    green_only = np.zeros((y8_frame.shape[0] // 2, y8_frame.shape[1] // 2),
                                                          dtype=np.uint8)
                                    for y in range(y8_frame.shape[0]):
                                        if y % 2 == 0:
                                            green_only[y // 2, :] = y8_frame[y, 1:][::2]

                                    frame = cv2.cvtColor(green_only, cv2.COLOR_GRAY2BGR)
                                    del green_only

                                elif ui.img_frmt_box.currentText() == "RG":
                                    self.processed_frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_RG2BGR)

                                elif ui.img_frmt_box.currentText() == "BG":
                                    self.processed_frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_BG2BGR)

                                elif ui.img_frmt_box.currentText() == "GR":
                                    self.processed_frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_GR2BGR)

                                elif ui.img_frmt_box.currentText() == "GB":
                                    self.processed_frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_GB2BGR)

                                if ui.img_frmt_box.currentText() != "CN" and \
                                        ui.img_frmt_box.currentText() != "Monochrome":
                                    frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)

                                del y8_frame
                                del filtered_bytes

                        if frame is not None:
                            return True, frame

                    else:
                        self.signals.update_statusbar.emit('Frame not received')
                        logger.error('Frame not received')
                        gr_rec += 1
                        return "", ""

                else:
                    self.signals.call_MsgBox.emit("Alert", "Please connect the camera.", "Warning")
                    return False, ""

            else:
                self.signals.call_MsgBox.emit("Alert", "Please connect the camera.", "Warning")
                return False, ""

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at read frames function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            return

    def black_level_subtraction(self, image):
        try:
            """
              This method is used to subtract the black level.
              param lists: image is object
              return: None
            """
            black_level = int(ui.collimator_black_lvl_value_lndt.text())
            black_level_ratio = 255 / (255 - black_level)

            table = []
            for i in range(256):
                if (i - black_level) <= 0:
                    table.append(0)
                else:
                    table.append((i - black_level) * black_level_ratio)
            table = np.array(table, np.uint8)
            return cv2.LUT(image, table)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at black_level_subtraction function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            return

    def streaming(self):
        try:
            """
              This method is used to mtf calculation in recipe creation page.
              param lists: None
              return: None
            """
            gr_rec = 0
            self.final_outputs = []
            empty_frame_count = 0
            while True:
                if self.cap.isOpened():
                    if ui.change_resolution:
                        ui.change_resolution = False
                        self.cap.setFormatType(ui.resolution_index)
                        self.format_type = "".join(
                            [chr((int(self.cap.get(cv2.CAP_PROP_FOURCC)) >> 8 * i) & 0xFF) for i in range(4)])
                        self.format_type = self.format_type.strip()
                    try:
                        ret, frame = self.cap.read()

                    except Exception as e:
                        logger.error("Unable to read frame {}".format(e))
                        empty_frame_count += 1
                        self.signals.update_statusbar.emit("Frame not received")
                        if empty_frame_count == 10:
                            self.signals.update_statusbar.emit('')
                            self.clear()
                            self.signals.call_ResetPreview_recipe_page.emit()
                            return
                        continue

                    if ret:
                        if np.sum(frame) != 0:
                            gr_rec = 0

                            if self.format_type == "UYVY":
                                ui.change_format_type = False
                                frame = cv2.cvtColor(frame, cv2.COLOR_YUV2BGR_UYVY)

                            elif self.format_type == "YUY2":
                                ui.change_format_type = False
                                frame = cv2.cvtColor(frame, cv2.COLOR_YUV2BGR_YUY2)

                            elif self.format_type == 'Y8':
                                self.withoutdb8bit_frame = frame
                                if ui.change_format_type:
                                    ui.change_format_type = False
                                    if ui.collimator_validation:
                                        if int(ui.collimator_black_lvl_value_lndt.text()) != 0:
                                            frame = self.black_level_subtraction(frame)
                                    elif ui.relay_validation:
                                        if int(ui.relay_black_lvl_value_lndt.text()) != 0:
                                            frame = self.black_level_subtraction(frame)

                                    if ui.img_frmt_box.currentText() == "CN":
                                        self.frame_to_cn = frame.copy()
                                        if ui.collimator_validation:
                                            if ui.collimator_green_value_lndt.text() != "" and \
                                                    ui.collimator_blue_value_lndt.text() != "" and \
                                                    ui.collimator_red_value_lndt.text() != "":
                                                self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                                frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)

                                        elif ui.relay_validation:
                                            if ui.relay_green_value_lndt.text() != "" and \
                                                    ui.relay_blue_value_lndt.text() != "" and \
                                                    ui.relay_red_value_lndt.text() != "":
                                                self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                                frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)

                                    if ui.img_frmt_box.currentText() == "Monochrome":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == 'No':
                                        green_only = np.zeros((frame.shape[0] // 2, frame.shape[1] // 2),
                                                              dtype=np.uint8)
                                        for y in range(frame.shape[0]):
                                            if y % 2 == 0:
                                                green_only[y // 2, :] = frame[y, 1:][::2]

                                        frame = cv2.cvtColor(green_only, cv2.COLOR_GRAY2BGR)
                                        self.processed_frame = frame
                                        del green_only

                                    elif ui.img_frmt_box.currentText() == "DB, RG":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_RG2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == "DB, BG":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_BG2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == "DB, GR":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_GR2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == "DB, GB":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_GB2BGR)
                                        self.processed_frame = frame

                                    else:
                                        frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)
                                        self.processed_frame = frame

                                else:
                                    if ui.collimator_validation:
                                        if int(ui.collimator_black_lvl_value_lndt.text()) != 0:
                                            frame = self.black_level_subtraction(frame)
                                    elif ui.relay_validation:
                                        if int(ui.relay_black_lvl_value_lndt.text()) != 0:
                                            frame = self.black_level_subtraction(frame)

                                    if ui.img_frmt_box.currentText() == "CN":
                                        self.frame_to_cn = frame.copy()
                                        if ui.collimator_validation:
                                            if ui.collimator_green_value_lndt.text() != "" and \
                                                    ui.collimator_blue_value_lndt.text() != "" and \
                                                    ui.collimator_red_value_lndt.text() != "":
                                                self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                                frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)
                                        elif ui.relay_validation:
                                            if ui.relay_green_value_lndt.text() != "" and \
                                                    ui.relay_blue_value_lndt.text() != "" and \
                                                    ui.relay_red_value_lndt.text() != "":
                                                self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                                frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)

                                    elif ui.img_frmt_box.currentText() == "Monochrome":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == 'No':
                                        green_only = np.zeros((frame.shape[0] // 2, frame.shape[1] // 2),
                                                              dtype=np.uint8)
                                        for y in range(frame.shape[0]):
                                            if y % 2 == 0:
                                                green_only[y // 2, :] = frame[y, 1:][::2]

                                        frame = cv2.cvtColor(green_only, cv2.COLOR_GRAY2BGR)
                                        self.processed_frame = frame
                                        del green_only

                                    elif ui.img_frmt_box.currentText() == "DB, RG":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_RG2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == "DB, BG":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_BG2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == "DB, GR":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_GR2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == "DB, GB":
                                        frame = cv2.cvtColor(frame, cv2.COLOR_BAYER_GB2BGR)
                                        self.processed_frame = frame

                                    else:
                                        frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)
                                        self.processed_frame = frame

                            elif self.format_type == "Y12":
                                if ui.change_format_type:
                                    ui.change_format_type = False
                                    raw_bytes = frame.tobytes()
                                    filtered_bytes = np.frombuffer(raw_bytes, dtype=np.uint8)
                                    filtered_bytes = np.reshape(filtered_bytes, (-1, 3))
                                    filtered_bytes = np.delete(filtered_bytes, 2, 1)
                                    filtered_bytes = np.reshape(filtered_bytes, -1)
                                    y8_frame = np.zeros(shape=(int(frame.shape[0]), int(frame.shape[1])),
                                                        dtype=np.uint8)
                                    m = 0
                                    for i in range(0, int(frame.shape[0])):
                                        y8_frame[i, :] = filtered_bytes[m:m + int(frame.shape[1])]
                                        m += int(frame.shape[1])

                                    self.withoutdb8bit_frame = y8_frame

                                    if ui.collimator_validation:
                                        if int(ui.collimator_black_lvl_value_lndt.text()) != 0:
                                            frame = self.black_level_subtraction(frame)
                                    elif ui.relay_validation:
                                        if int(ui.relay_black_lvl_value_lndt.text()) != 0:
                                            frame = self.black_level_subtraction(frame)

                                    if ui.img_frmt_box.currentText() == "CN":
                                        self.frame_to_cn = frame.copy()
                                        if ui.collimator_validation:
                                            if ui.collimator_green_value_lndt.text() != "" and \
                                                    ui.collimator_blue_value_lndt.text() != "" and \
                                                    ui.collimator_red_value_lndt.text() != "":
                                                self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                                frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)

                                        elif ui.relay_validation:
                                            if ui.relay_green_value_lndt.text() != "" and \
                                                    ui.relay_blue_value_lndt.text() != "" and \
                                                    ui.relay_red_value_lndt.text() != "":
                                                self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                                frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)

                                    if ui.img_frmt_box.currentText() == "Monochrome":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_GRAY2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == 'No':
                                        green_only = np.zeros((y8_frame.shape[0] // 2, y8_frame.shape[1] // 2),
                                                              dtype=np.uint8)
                                        for y in range(y8_frame.shape[0]):
                                            if y % 2 == 0:
                                                green_only[y // 2, :] = y8_frame[y, 1:][::2]

                                        frame = cv2.cvtColor(green_only, cv2.COLOR_GRAY2BGR)
                                        self.processed_frame = frame
                                        del green_only

                                    elif ui.img_frmt_box.currentText() == "DB, RG":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_RG2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == "DB, BG":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_BG2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == "DB, GR":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_GR2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == "DB, GB":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_GB2BGR)
                                        self.processed_frame = frame
                                else:
                                    raw_bytes = frame.tobytes()
                                    filtered_bytes = np.frombuffer(raw_bytes, dtype=np.uint8)
                                    filtered_bytes = np.reshape(filtered_bytes, (-1, 3))
                                    filtered_bytes = np.delete(filtered_bytes, 2, 1)
                                    filtered_bytes = np.reshape(filtered_bytes, -1)
                                    y8_frame = np.zeros(shape=(int(frame.shape[0]), int(frame.shape[1])),
                                                        dtype=np.uint8)
                                    m = 0
                                    for i in range(0, int(frame.shape[0])):
                                        y8_frame[i, :] = filtered_bytes[m:m + int(frame.shape[1])]

                                        m += int(frame.shape[1])

                                    self.withoutdb8bit_frame = y8_frame

                                    if ui.collimator_validation:
                                        if int(ui.collimator_black_lvl_value_lndt.text()) != 0:
                                            frame = self.black_level_subtraction(frame)
                                    elif ui.relay_validation:
                                        if int(ui.relay_black_lvl_value_lndt.text()) != 0:
                                            frame = self.black_level_subtraction(frame)

                                    if ui.img_frmt_box.currentText() == "CN":
                                        self.frame_to_cn = frame.copy()
                                        if ui.collimator_validation:
                                            if ui.collimator_green_value_lndt.text() != "" and \
                                                    ui.collimator_blue_value_lndt.text() != "" and \
                                                    ui.collimator_red_value_lndt.text() != "":
                                                self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                                frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)
                                        elif ui.relay_validation:
                                            if ui.relay_green_value_lndt.text() != "" and \
                                                    ui.relay_blue_value_lndt.text() != "" and \
                                                    ui.relay_red_value_lndt.text() != "":
                                                self.processed_frame = self.channel_normalization(self.frame_to_cn)
                                                frame = cv2.cvtColor(self.frame_to_cn, cv2.COLOR_GRAY2BGR)

                                    if ui.img_frmt_box.currentText() == "Monochrome":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_GRAY2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == 'No':
                                        green_only = np.zeros((y8_frame.shape[0] // 2, y8_frame.shape[1] // 2),
                                                              dtype=np.uint8)
                                        for y in range(y8_frame.shape[0]):
                                            if y % 2 == 0:
                                                green_only[y // 2, :] = y8_frame[y, 1:][::2]

                                        frame = cv2.cvtColor(green_only, cv2.COLOR_GRAY2BGR)
                                        self.processed_frame = frame
                                        del green_only

                                    elif ui.img_frmt_box.currentText() == "DB, RG":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_RG2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == "DB, BG":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_BG2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == "DB, GR":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_GR2BGR)
                                        self.processed_frame = frame

                                    elif ui.img_frmt_box.currentText() == "DB, GB":
                                        frame = cv2.cvtColor(y8_frame, cv2.COLOR_BAYER_GB2BGR)
                                        self.processed_frame = frame

                            elif self.format_type == 'Y16':
                                ui.change_format_type = False
                                frame = cv2.convertScaleAbs(frame, 0.000000065)
                                self.processed_frame = frame

                            if ui.stackedWidget.currentIndex() == 3:
                                if ui.collimator_clicked:
                                    width_half = frame.shape[1] // 2
                                    height_half = frame.shape[0] // 2
                                    self.collimator_roi["C"] = []
                                    x = width_half
                                    y = height_half
                                    width = ui.collimator_width_value
                                    height = ui.collimator_height_value
                                    x1, y1 = [int(x - width / 2), int(y - height / 2)]
                                    x2, y2 = [int(x + width / 2), int(y + height / 2)]

                                    if (int(frame.shape[0]) >= y1 >= 0) and (int(frame.shape[0]) >= y2 >= 0) and \
                                            (int(frame.shape[1]) >= x1 >= 0) and (
                                            int(frame.shape[1]) >= x2 >= 0):
                                        self.collimator_roi["C"] = [y1, y2, x1, x2]

                                    else:
                                        logger.error(
                                            "'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                            "the config file at Center.")
                                        # return

                                    azimuth_angle = ui.collimator_angle_value
                                    angles = [azimuth_angle, 180 - azimuth_angle, 180 + azimuth_angle,
                                              360 - azimuth_angle]
                                    radius = ui.collimator_radius_value
                                    positions = ["TR", "TL", "BL", "BR"]

                                    for angle, position in zip(angles, positions):
                                        dy = radius * math.sin(math.radians(angle))
                                        dx = radius * math.cos(math.radians(angle))
                                        x = width_half + dx
                                        y = height_half - dy
                                        x1, y1 = [int(x - width / 2), int(y - height / 2)]
                                        x2, y2 = [int(x + width / 2), int(y + height / 2)]
                                        if (int(frame.shape[0]) >= y1 >= 0) and (
                                                int(frame.shape[0]) >= y2 >= 0) and \
                                                (int(frame.shape[1]) >= x1 >= 0) and (
                                                int(frame.shape[1]) >= x2 >= 0):
                                            self.collimator_roi[position] = [y1, y2, x1, x2]

                                    for x in self.collimator_roi.keys():
                                        self.mtf_roi_avg[x] = []

                                    for j, k in self.collimator_roi.items():
                                        radius = int(np.math.sqrt(
                                            abs(frame.shape[1] // 2 - (k[2] + (k[3] - k[2]) // 2)) ** 2
                                            + abs(frame.shape[0] // 2 - (k[0] + (k[1] - k[0]) // 2)) ** 2))

                                        cv2.circle(frame,
                                                   (frame.shape[1] // 2, frame.shape[0] // 2),
                                                   radius, (0, 255, 255), 2)

                                        cv2.line(frame,
                                                 (frame.shape[1] // 2, frame.shape[0] // 2),
                                                 (int(k[2] + (k[3] - k[2]) // 2), int(k[0] + (k[1] - k[0]) // 2)),
                                                 (0, 255, 255), 2)

                                        cv2.rectangle(frame, tuple([k[2], k[0]]), tuple([k[3], k[1]]),
                                                      (0, 255, 255), 2)

                                elif ui.collimator_simulate_clicked:
                                    ui.collimator_simulate(image=frame)

                                elif ui.collimator_offset_clicked:
                                    frame, dx, dy = ui.lens_offset_class.validate_lens_offset(
                                        image=frame, roi_width=500)

                                elif ui.collimator_chart_check_clicked:
                                    try:
                                        self.frames_append = []
                                        for x in range(int(ui.collimator_median_frame_cnt_lndt.text())):
                                            self.frames_append.append(frame)

                                        for i in range(int(ui.collimator_median_frame_cnt_lndt.text())):
                                            self.thread_median_cal(frame=self.frames_append[i],
                                                                   roi_type=self.collimator_roi,
                                                                   setup_type="Collimator station")

                                        median = self.calculation()
                                        roi_list = ["TL", "TR", "C", "BL", "BR"]
                                        length_roi_list = [len(self.final_result.roi_mtf_value[i]) for i in roi_list]
                                        length = 0
                                        for index, i in enumerate(length_roi_list):
                                            for j in range(i):
                                                self.final_result.roi_mtf_value[roi_list[index]][j]['roi_lum'][
                                                    'mtf50'] = median[length]
                                                length += 1
                                        empty_frame_count = 0

                                        if self.image_roi.image.shape[0] > 1440:
                                            overall_avg = []
                                            for roi_position, regions in self.final_result.roi_mtf_value.items():
                                                if regions:
                                                    roi_avg = []
                                                    for i in range(len(regions)):
                                                        try:
                                                            roi_avg.append(round(
                                                                self.final_result.roi_mtf_value[roi_position][i][
                                                                    'roi_lum'][
                                                                    'mtf50'], 3))
                                                        except KeyError:
                                                            logger.debug("MTF50 value is empty")

                                                    if len(roi_avg) != 0:
                                                        cv2.putText(self.image_roi.image, 'Avg: {}'.format(
                                                            round(sum(roi_avg) / len(roi_avg), 3)),
                                                                    (self.collimator_roi[roi_position][3] - 220,
                                                                     self.collimator_roi[roi_position][0] + 45),
                                                                    cv2.FONT_HERSHEY_SIMPLEX, 1.2,
                                                                    (0, 255, 0), 2, cv2.LINE_AA)
                                                        overall_avg.append(round(sum(roi_avg) / len(roi_avg), 3))

                                            if len(overall_avg) != 0:
                                                cv2.putText(self.image_roi.image, 'Overall Avg: {}'.format(
                                                    round(sum(overall_avg) / len(overall_avg), 3)),
                                                            (25, 45), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 2,
                                                            cv2.LINE_AA)
                                                frame = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)

                                        else:
                                            overall_avg = []
                                            for roi_position, regions in self.final_result.roi_mtf_value.items():
                                                if regions:
                                                    roi_avg = []
                                                    for i in range(len(regions)):
                                                        try:
                                                            roi_avg.append(round(
                                                                self.final_result.roi_mtf_value[roi_position][i][
                                                                    'roi_lum'][
                                                                    'mtf50'], 3))
                                                        except KeyError:
                                                            logger.debug("MTF50 value is empty")
                                                    if len(roi_avg) != 0:
                                                        cv2.putText(self.image_roi.image, 'Avg: {}'.format(
                                                            round(sum(roi_avg) / len(roi_avg), 3)),
                                                                    (self.collimator_roi[roi_position][3] - 150,
                                                                     self.collimator_roi[roi_position][0] + 35),
                                                                    cv2.FONT_HERSHEY_SIMPLEX, .9, (0, 255, 0), 2,
                                                                    cv2.LINE_AA)
                                                        overall_avg.append(round(sum(roi_avg) / len(roi_avg), 3))

                                            if len(overall_avg) != 0:
                                                cv2.putText(self.image_roi.image, 'Overall Avg: {}'.format(
                                                    round(sum(overall_avg) / len(overall_avg), 3)),
                                                            (25, 45), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 2,
                                                            cv2.LINE_AA)
                                                frame = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)

                                    except Exception as e:
                                        logger.error("Error at mtf calculation {}".format(e))
                                        try:
                                            display_image = cv2.resize(frame, ui.dim, interpolation=cv2.INTER_AREA)
                                            height, width, channel = display_image.shape
                                            step = channel * width
                                            qt_img = QImage(display_image.data, width, height, step,
                                                            QImage.Format_RGB888)
                                            self.signals.call_updateLbl.emit(qt_img)
                                            if ui.statusbar.text() == 'Frame not received':
                                                self.signals.update_statusbar.emit('')

                                            del frame
                                            del qt_img
                                            del display_image
                                            gc.collect()

                                        except Exception as e:
                                            pass

                                if ui.abort_clicked:
                                    self.clear()
                                    self.signals.update_statusbar.emit('')
                                    self.signals.call_ResetPreview_recipe_page.emit()
                                    break

                                try:
                                    display_image = cv2.resize(frame, ui.dim, interpolation=cv2.INTER_AREA)
                                    height, width, channel = display_image.shape
                                    step = channel * width
                                    qt_img = QImage(display_image.data, width, height, step, QImage.Format_RGB888)
                                    self.signals.call_updateLbl.emit(qt_img)
                                    if ui.statusbar.text() == 'Frame not received':
                                        self.signals.update_statusbar.emit('')

                                    del frame
                                    del qt_img
                                    del display_image
                                    gc.collect()

                                except Exception as e:
                                    pass

                                if ui.frame_saved:
                                    ui.frame_saved = False
                                    try:
                                        now = datetime.datetime.now()
                                        result_name = now.strftime("%H%M%S")
                                        desktop_path = os.path.join(os.environ["USERPROFILE"], "Desktop")
                                        f = open("{}\\{}.raw".format(desktop_path, result_name), "wb+")
                                        f.write(self.withoutdb8bit_frame)
                                        f.close()
                                        cv2.imwrite("{}\\{}.bmp".format(desktop_path, result_name),
                                                    self.image_roi.image)
                                        self.signals.update_statusbar.emit('Image saved in desktop path')

                                    except Exception as e:
                                        self.signals.update_statusbar.emit('Unable to save raw frame.')

                            elif ui.stackedWidget.currentIndex() == 4:
                                if ui.relay_clicked:
                                    width_half = frame.shape[1] // 2
                                    height_half = frame.shape[0] // 2
                                    self.relay_roi["C"] = []
                                    x = width_half
                                    y = height_half
                                    width = ui.relay_width_value
                                    height = ui.relay_height_value
                                    x1, y1 = [int(x - width / 2), int(y - height / 2)]
                                    x2, y2 = [int(x + width / 2), int(y + height / 2)]

                                    if (int(frame.shape[0]) >= y1 >= 0) and (int(frame.shape[0]) >= y2 >= 0) and \
                                            (int(frame.shape[1]) >= x1 >= 0) and (
                                            int(frame.shape[1]) >= x2 >= 0):
                                        self.relay_roi["C"] = [y1, y2, x1, x2]

                                    else:
                                        logger.error(
                                            "'Azimuth Angle' or 'Radius' or 'Width' or 'Height' is incorrect in "
                                            "the config file at Center.")

                                    azimuth_angle = ui.relay_angle_value
                                    angles = [azimuth_angle, 180 - azimuth_angle, 180 + azimuth_angle,
                                              360 - azimuth_angle]
                                    radius = ui.relay_radius_value
                                    positions = ["TR", "TL", "BL", "BR"]

                                    for angle, position in zip(angles, positions):
                                        dy = radius * math.sin(math.radians(angle))
                                        dx = radius * math.cos(math.radians(angle))
                                        x = width_half + dx
                                        y = height_half - dy
                                        x1, y1 = [int(x - width / 2), int(y - height / 2)]
                                        x2, y2 = [int(x + width / 2), int(y + height / 2)]
                                        if (int(frame.shape[0]) >= y1 >= 0) and (
                                                int(frame.shape[0]) >= y2 >= 0) and \
                                                (int(frame.shape[1]) >= x1 >= 0) and (
                                                int(frame.shape[1]) >= x2 >= 0):
                                            self.relay_roi[position] = [y1, y2, x1, x2]

                                    for x in self.relay_roi.keys():
                                        self.mtf_roi_avg[x] = []

                                    for j, k in self.relay_roi.items():
                                        radius = int(np.math.sqrt(
                                            abs(frame.shape[1] // 2 - (k[2] + (k[3] - k[2]) // 2)) ** 2
                                            + abs(frame.shape[0] // 2 - (k[0] + (k[1] - k[0]) // 2)) ** 2))

                                        cv2.circle(frame,
                                                   (frame.shape[1] // 2, frame.shape[0] // 2),
                                                   radius, (0, 255, 255), 2)

                                        cv2.line(frame,
                                                 (frame.shape[1] // 2, frame.shape[0] // 2),
                                                 (int(k[2] + (k[3] - k[2]) // 2), int(k[0] + (k[1] - k[0]) // 2)),
                                                 (0, 255, 255), 2)

                                        cv2.rectangle(frame, tuple([k[2], k[0]]), tuple([k[3], k[1]]),
                                                      (0, 255, 255), 2)

                                elif ui.relay_simulate_clicked:
                                    ui.relay_simulate(image=frame)

                                elif ui.relay_offset_clicked:
                                    frame, dx, dy = ui.lens_offset_class.validate_lens_offset(
                                        image=frame, roi_width=500)

                                elif ui.relay_chart_check_clicked:
                                    try:
                                        self.frames_append = []
                                        for nof_calculatableFrames in range(1):
                                            self.frames_append.append(frame)

                                        for i in range(1):
                                            self.thread_median_cal(self.frames_append[i], roi_type=self.relay_roi,
                                                                   setup_type="Relay station")
                                        median = self.calculation()
                                        roi_list = ["TL", "TR", "C", "BL", "BR"]
                                        length_roi_list = [len(self.final_result.roi_mtf_value[i]) for i in roi_list]
                                        length = 0
                                        for index, i in enumerate(length_roi_list):
                                            for j in range(i):
                                                self.final_result.roi_mtf_value[roi_list[index]][j]['roi_lum'][
                                                    'mtf50'] = \
                                                    median[length]
                                                length += 1

                                    except Exception as e:
                                        logger.error("Error at mtf calculation {}".format(e))

                                    if self.image_roi.image.shape[0] > 1440:
                                        overall_avg = []
                                        for roi_position, regions in self.final_result.roi_mtf_value.items():
                                            if regions:
                                                roi_avg = []
                                                for i in range(len(regions)):
                                                    try:
                                                        roi_avg.append(round(
                                                            self.final_result.roi_mtf_value[roi_position][i][
                                                                'roi_lum'][
                                                                'mtf50'], 3))
                                                    except KeyError:
                                                        logger.debug("MTF50 value is empty")

                                                if len(roi_avg) != 0:
                                                    cv2.putText(self.image_roi.image, 'Avg: {}'.format(
                                                        round(sum(roi_avg) / len(roi_avg), 3)),
                                                                (self.relay_roi[roi_position][3] - 220,
                                                                 self.relay_roi[roi_position][0] + 45),
                                                                cv2.FONT_HERSHEY_SIMPLEX, 1.2,
                                                                (0, 255, 0), 2, cv2.LINE_AA)
                                                    overall_avg.append(round(sum(roi_avg) / len(roi_avg), 3))

                                        if len(overall_avg) != 0:
                                            cv2.putText(self.image_roi.image, 'Overall Avg: {}'.format(
                                                round(sum(overall_avg) / len(overall_avg), 3)),
                                                        (25, 45), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 2,
                                                        cv2.LINE_AA)
                                            frame = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)

                                    else:
                                        overall_avg = []
                                        for roi_position, regions in self.final_result.roi_mtf_value.items():
                                            if regions:
                                                roi_avg = []
                                                for i in range(len(regions)):
                                                    try:
                                                        roi_avg.append(round(
                                                            self.final_result.roi_mtf_value[roi_position][i][
                                                                'roi_lum'][
                                                                'mtf50'], 3))
                                                    except KeyError:
                                                        logger.debug("MTF50 value is empty")
                                                if len(roi_avg) != 0:
                                                    cv2.putText(self.image_roi.image, 'Avg: {}'.format(
                                                        round(sum(roi_avg) / len(roi_avg), 3)),
                                                                (self.relay_roi[roi_position][3] - 150,
                                                                 self.relay_roi[roi_position][0] + 35),
                                                                cv2.FONT_HERSHEY_SIMPLEX, .9, (0, 255, 0), 2,
                                                                cv2.LINE_AA)
                                                    overall_avg.append(round(sum(roi_avg) / len(roi_avg), 3))

                                        if len(overall_avg) != 0:
                                            cv2.putText(self.image_roi.image, 'Overall Avg: {}'.format(
                                                round(sum(overall_avg) / len(overall_avg), 3)),
                                                        (25, 45), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 2,
                                                        cv2.LINE_AA)
                                            frame = cv2.cvtColor(self.image_roi.image, cv2.COLOR_BGR2RGB)

                                if ui.abort_clicked:
                                    self.signals.update_statusbar.emit('')
                                    self.signals.call_ResetPreview_recipe_page.emit()
                                    self.clear()
                                    break

                                try:
                                    display_image = cv2.resize(frame, ui.dim, interpolation=cv2.INTER_AREA)
                                    height, width, channel = display_image.shape
                                    step = channel * width
                                    qt_img = QImage(display_image.data, width, height, step, QImage.Format_RGB888)
                                    self.signals.call_updateLbl.emit(qt_img)
                                    if ui.statusbar.text() == 'Frame not received':
                                        self.signals.update_statusbar.emit('')

                                    del frame
                                    del qt_img
                                    del display_image
                                    gc.collect()

                                except Exception as e:
                                    print("e", e)
                                    pass

                            elif ui.abort_clicked:
                                self.clear()
                                self.signals.update_statusbar.emit('')
                                self.signals.call_ResetPreview_recipe_page.emit()
                                break

                            else:
                                try:
                                    display_image = cv2.resize(frame, ui.dim, interpolation=cv2.INTER_AREA)
                                    height, width, channel = display_image.shape
                                    step = channel * width
                                    qt_img = QImage(display_image.data, width, height, step, QImage.Format_RGB888)
                                    self.signals.call_updateLbl.emit(qt_img)
                                    if ui.statusbar.text() == 'Frame not received':
                                        self.signals.update_statusbar.emit('')
                                    empty_frame_count = 0
                                    del frame
                                    del qt_img
                                    del display_image
                                    gc.collect()

                                except Exception as e:
                                    logger.error(f"Frame unpacked {e}")
                                    empty_frame_count += 1
                                    self.signals.update_statusbar.emit("Frame not received")
                                    if empty_frame_count == 10:
                                        self.signals.update_statusbar.emit('')
                                        self.clear()
                                        self.signals.call_ResetPreview_recipe_page.emit()
                                        return

                        else:
                            self.signals.update_statusbar.emit('Frame not received')
                            logger.error('Frame not received')
                            gr_rec += 1
                            if gr_rec == 10:
                                self.clear()
                                self.signals.update_statusbar.emit('')
                                break

                    else:
                        self.signals.update_statusbar.emit('')
                        self.clear()
                        self.signals.call_MsgBox.emit("Alert", "Please connect the camera.", "Warning")
                        self.signals.call_ResetPreview_recipe_page.emit()
                        break

                else:
                    self.clear()
                    self.signals.call_MsgBox.emit("Alert", "Please connect the camera.", "Warning")
                    break

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at streaming function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.signals.update_statusbar.emit('')
            self.clear()
            self.signals.call_ResetPreview_recipe_page.emit()


class Runnable_teaching_glue(QRunnable):
    """
    This class is used to run the Qrunnable thread for glue purge.
    param threadpool: Qrunnable thread
    """

    def __init__(self, threadpool):
        try:
            super(Runnable_teaching_glue, self).__init__()
            self.signals = WorkerSignals()
            self.threadpool = threadpool

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at Runnable_teaching_glueQRunnable init function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                              exc_tb.tb_lineno, e))

    def run(self):
        try:
            logger.info("*********teaching_glue_connect_Thread Started!*************")
            self.threadpool.reserveThread()
            if ui.teaching_glue_clicked:
                ui.gluing_teaching_purge_btn.setEnabled(False)
                ui.glue_teach_btn_dclose.setEnabled(False)
                ui.teaching_glue_clicked = False
                self.glue_teach()
            ui.gluing_teaching_purge_btn.setEnabled(True)
            ui.glue_teach_btn_dclose.setEnabled(True)
            self.signals.call_ResetPreview.emit("Yes")
            logger.info("teaching_glue_connect_Thread completed")
            self.threadpool.releaseThread()
            logger.info("*********teaching_glue_connect_Thread Completed!*************")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at Runnable_teaching_glue run function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno,
                                                                                    e))

    def glue_teach(self):
        try:
            """
              This method is used to purge the glue.
              param lists: None
              return: None
            """
            check_ip = ui_plc_communication.plc_control_class.check_input_status()
            if check_ip == "Status updated":
                status = ui_plc_communication.plc_control_class.input_status
                if status["EMO"]:
                    self.signals.glue_teach_status_updated.emit("Release the Emergency button.")
                    return
                if not status["Air Pressure"]:
                    self.signals.glue_teach_status_updated.emit("Check the Air pressure.")
                    return
                if not status["EMS"]:
                    self.signals.glue_teach_status_updated.emit("Earth leakage is failed.")
                    return
            else:
                self.signals.glue_teach_status_updated.emit("Failed to get input status.")

            time.sleep(0.5)
            self.signals.glue_teach_status_updated.emit("Gluing purge is in progress...")
            return_value = ui_plc_communication.plc_control_class.glue_dispenser_timer(
                timer=int(ui.gluing_teaching_purge_lndt.text()))
            if return_value == "Passed":
                self.signals.glue_teach_status_updated.emit("Gluing purged")
                logger.info("Gluing purged")
            else:
                self.signals.glue_teach_status_updated.emit("{}".format(return_value))

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at glue_teach function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))


class Runnable_ports(QRunnable):
    """
            This class is used to run the Qrunnable thread for port connection, mahcine homing and io status.
            """

    def __init__(self, threadpool):
        try:
            super(Runnable_ports, self).__init__()
            self.signals = WorkerSignals()
            self.home_threadpool = threadpool
            self.user_call_init_yes = False
            self.user_call_init_no = False
            self.wait_user_response = False
            self.loop_break = False

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at Runnable_ports init function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def run(self):
        try:
            logger.info("*********Port_connect_Thread Started!*************")
            self.home_threadpool.reserveThread()
            if ui.refresh_btn_clicked:
                ui.refresh_btn_clicked = False
                if ui.init_clicked:
                    ui.init_clicked = False
                    self.homing_all_thread()
                elif ui.port_refresh_btn:
                    ui.port_refresh_btn = False
                    self.connect_ports()
                elif ui.i_o_refresh_btn:
                    ui.i_o_refresh_btn = False
                    self.i_o_check_status()
                    ui.machine_flow.sensor_status_btn_refresh.setEnabled(True)
                    ui.machine_flow.sensor_status_btn_dclose.setEnabled(True)

            ui.machine_flow.port_btn_refresh.setEnabled(True)
            ui.machine_flow.port_btn_dclose.setEnabled(True)
            self.signals.call_ResetPreview.emit("")
            logger.info("Port_connect_Thread completed")
            self.home_threadpool.releaseThread()
            logger.info("*********Port_connect_Thread Completed!*************")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at Runnable_ports run function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))

    def homing_all_thread(self):
        try:
            """
              This method is used to perform the machine homing.
              param lists: None
              return: None
            """
            retry_ip_status = 0
            self.signals.update_statusbar.emit("Machine Homing is in progress..")
            if ui.is_all_homing:
                logger.info("Machine homing is already happened Just moving their to 5mm")
                self.signals.show_dialog.emit()
                while not self.loop_break:
                    time.sleep(1)
                    status_result = ui_plc_communication.parallel_homing_old(class_name=ui, homing_position=5)
                    if status_result[0] != "Passed":
                        if status_result[0] == "Air pressure is low" or status_result[0] == "Earth leakage":
                            self.signals.close_dialog.emit()
                            ui.is_all_homing = False
                            self.signals.update_statusbar.emit(f"{status_result[0]}, So unable to proceed homing")
                            return

                        elif status_result[0] == "Emergency is pressed" or status_result[0] == "Emergency pressed" or \
                                status_result[0] == "Left side door is opened" or \
                                status_result[0] == "Right side door is opened":

                            catch_error = self.catch_and_clear_error_homing(status=status_result[0])
                            if catch_error == "Not Done":
                                ui.is_all_homing = False
                                self.signals.close_dialog.emit()
                                self.loop_break = True
                                self.signals.update_statusbar.emit("User cancelled the homing sequence.")
                                return
                            else:
                                continue
                        else:
                            self.signals.close_dialog.emit()
                            ui.is_all_homing = False
                            self.signals.update_statusbar.emit(f"{status_result[0]}, So unable to proceed homing")
                            return

                    elif status_result[0] == "Error in read input status":
                        retry_ip_status += 1
                        if retry_ip_status == 3:
                            self.loop_break = True
                            self.signals.close_dialog.emit()
                            ui.is_all_homing = False
                            self.signals.update_statusbar.emit("Error to read input status")
                            return
                        continue

                    elif status_result[0] == "Passed":
                        self.signals.close_dialog.emit()
                        ui.is_all_homing = True
                        self.signals.update_statusbar.emit("Machine Homing is completed")
                        return

                    else:
                        self.loop_break = True
                        self.signals.close_dialog.emit()
                        ui.is_all_homing = False
                        self.signals.update_statusbar.emit("Error in homing sequence.")
                        return

            else:
                logger.info("Machine not in homing So all actuators try to moving its homing position")
                self.signals.show_dialog.emit()
                while not self.loop_break:
                    time.sleep(1)
                    status_result = ui_plc_communication.parallel_homing_old(class_name=ui)
                    if status_result[0] != "Passed":
                        if status_result[0] == "Air pressure is low" or status_result[0] == "Earth leakage":
                            self.signals.close_dialog.emit()
                            ui.is_all_homing = False
                            self.signals.update_statusbar.emit(f"{status_result[0]}, So unable to proceed homing")
                            return

                        elif status_result[0] == "Emergency is pressed" or status_result[0] == "Emergency pressed" or \
                                status_result[0] == "Left side door is opened" or \
                                status_result[0] == "Right side door is opened":
                            catch_error = self.catch_and_clear_error_homing(status=status_result[0])
                            if catch_error == "Not Done":
                                ui.is_all_homing = False
                                self.signals.close_dialog.emit()
                                self.loop_break = True
                                self.signals.update_statusbar.emit("User cancelled the homing sequence.")
                                return
                            else:
                                continue
                        else:
                            self.signals.close_dialog.emit()
                            ui.is_all_homing = False
                            self.signals.update_statusbar.emit(f"{status_result[0]}, So unable to proceed homing")
                            return

                    elif status_result[0] == "Error in read input status":
                        retry_ip_status += 1
                        if retry_ip_status == 3:
                            self.loop_break = True
                            self.signals.close_dialog.emit()
                            ui.is_all_homing = False
                            self.signals.update_statusbar.emit("Error to read input status")
                            return
                        continue

                    elif status_result[0] == "Passed":
                        self.signals.close_dialog.emit()
                        ui.is_all_homing = True
                        self.signals.update_statusbar.emit("Machine Homing is completed")
                        return

                    else:
                        self.loop_break = True
                        self.signals.close_dialog.emit()
                        ui.is_all_homing = False
                        self.signals.update_statusbar.emit("Error in homing sequence.")
                        return

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at inside thread homing_all_thread function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                                  exc_tb.tb_lineno, e))
            if not ui.is_all_homing:
                ui.is_all_homing = False
            self.signals.close_dialog.emit()
            self.signals.update_statusbar.emit('Error in homing sequence')

    def catch_and_clear_error_homing(self, status='', retry_skip=''):
        try:
            """
              This method is used to clear the error cases.
              param lists: status and retry_skip are str
              return: None
            """
            logger.debug("Error occurred reason {}".format(status))
            if status == "Emergency is pressed" or status == "Air pressure is low" or status == "Emergency pressed":
                while True:
                    time.sleep(0.05)
                    messages = ui_plc_communication.plc_control_class.serial_port.read(
                        ui_plc_communication.plc_control_class.serial_port.inWaiting()).decode('utf-8', 'ignore')

                    if status == "Emergency is pressed" or status == "Emergency pressed":
                        if "K:EMO\r\n" in messages:
                            logger.debug("Release the Emergency button")
                            self.signals.close_MsgBox.emit()
                            break

                        else:
                            if not ui.error_msg_response:
                                self.signals.call_MsgBox.emit("Critical", "Emergency button is pressed",
                                                              "Auto_sequence")
                                ui.error_msg_response = True

                    elif status == "Air pressure is low":
                        if "K:AIR\r\n" in messages:
                            self.signals.close_MsgBox.emit()
                            break

                        else:
                            if not ui.error_msg_response:
                                self.signals.call_MsgBox.emit("Critical", "Air Pressure is low", "Auto_sequence")
                                ui.error_msg_response = True

                    elif status == "Earth leakage":
                        if "K:EMS\r\n" in messages:
                            self.signals.close_MsgBox.emit()
                            break

                        else:
                            if not ui.error_msg_response:
                                self.signals.call_MsgBox.emit("Critical", "Earth leakage is high", "Auto_sequence")
                                ui.error_msg_response = True

                while True:
                    time.sleep(0.05)
                    message = ui_plc_communication.plc_control_class.serial_port.read(
                        ui_plc_communication.plc_control_class.serial_port.inWaiting()).decode('utf-8', 'ignore')

                    if "K:RST\r\n" in message:
                        self.signals.close_MsgBox.emit()
                        break

                    else:
                        if not ui.error_msg_response:
                            self.signals.call_MsgBox.emit("Critical", "Press the reset button", "Auto_sequence")
                            ui.error_msg_response = True

                if retry_skip == '':
                    while True:
                        if not ui.error_msg_response:
                            ui.error_msg_response = True
                            self.signals.call_MsgBox.emit("Question", "Do you want to proceed", "Question")

                        if ui.user_call_init_yes:
                            ui.error_msg_response = False
                            self.signals.close_MsgBox.emit()
                            break

                        elif ui.user_call_init_no:
                            ui.error_msg_response = False
                            self.signals.close_MsgBox.emit()
                            break

                    if ui.user_call_init_yes:
                        ui.user_call_init_yes = False

                        logger.info("User clicked yes in error catch cases")
                        return "Done"

                    elif ui.user_call_init_no:
                        ui.user_call_init_no = False
                        logger.info("User clicked no in error catch cases")
                        return "Not Done"
                else:
                    return "Done"

            elif status == "Left side door is opened" or status == "Right side door is opened" or \
                    status == "Control panel door is opened":
                if ui.bypass_option["Right door"] or ui.bypass_option["Left door"]:
                    return "Done"

                while True:
                    time.sleep(0.05)
                    messages = ui_plc_communication.plc_control_class.serial_port.read(
                        ui_plc_communication.plc_control_class.serial_port.inWaiting()).decode('utf-8', 'ignore')

                    if status == "Left side door is opened":
                        if "K:LSD\r\n" in messages:
                            self.signals.close_MsgBox.emit()
                            break

                        else:
                            if not ui.error_msg_response:
                                self.signals.call_MsgBox.emit("Critical", "Please close the left side door",
                                                              "Auto_sequence")
                                ui.error_msg_response = True

                    elif status == "Right side door is opened":
                        if "K:RSD\r\n" in messages:
                            self.signals.close_MsgBox.emit()
                            break

                        else:
                            if not ui.error_msg_response:
                                self.signals.call_MsgBox.emit("Critical", "Please close the right side door",
                                                              "Auto_sequence")
                                ui.error_msg_response = True

                    elif status == "Control panel door is opened":
                        if "K:CPD\r\n" in messages:
                            self.signals.close_MsgBox.emit()
                            break

                        else:
                            if not ui.error_msg_response:
                                self.signals.call_MsgBox.emit("Critical", "Please close the control panel door",
                                                              "Auto_sequence")
                                ui.error_msg_response = True

                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        self.signals.call_MsgBox.emit("Question", "Do you want to proceed", "Question")

                    if ui.user_call_init_yes:
                        break
                    elif ui.user_call_init_no:
                        break

                if ui.user_call_init_yes:
                    ui.user_call_init_yes = False
                    self.signals.close_MsgBox.emit()
                    logger.info("User clicked yes in error catch(door open) cases")
                    return "Done"

                elif ui.user_call_init_no:
                    ui.user_call_init_no = False
                    logger.info("User clicked no in error catch(door open) cases")
                    self.signals.close_MsgBox.emit()
                    return "Not Done"
            else:
                while True:
                    if not ui.error_msg_response:
                        ui.error_msg_response = True
                        self.signals.call_MsgBox.emit("Question", f"{status}\nDo you want to proceed", "Question")

                    if ui.user_call_init_yes:
                        break
                    elif ui.user_call_init_no:
                        break

                if ui.user_call_init_yes:
                    ui.user_call_init_yes = False
                    self.signals.close_MsgBox.emit()
                    logger.info("User clicked yes in error catch(door open) cases")
                    return "Done"

                elif ui.user_call_init_no:
                    ui.user_call_init_no = False
                    logger.info("User clicked no in error catch(door open) cases")
                    self.signals.close_MsgBox.emit()
                    return "Not Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at catch_and_clear_error function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            return "Not Done"

    def i_o_check_status(self):
        try:
            """
              This method is used to get the io status.
              param lists: None
              return: None
            """
            for x in range(2):
                overall_list = []
                input_list = []
                status = ui_plc_communication.plc_control_class.check_input_status()
                if status == "Status updated":
                    value = ui_plc_communication.plc_control_class.input_status
                    for x in value.values():
                        if x:
                            input_list.append("1")
                        else:
                            input_list.append("0")
                else:
                    continue

                time.sleep(0.5)
                output_list = []
                status = ui_plc_communication.plc_control_class.check_output_status()
                if status == "Status updated":
                    value = ui_plc_communication.plc_control_class.output_status
                    for x in value.values():
                        if x:
                            output_list.append("1")
                        else:
                            output_list.append("0")
                else:
                    continue

                overall_list.append(input_list)
                overall_list.append(output_list)

                for i in range(2):
                    for x, y in list(enumerate(overall_list[i], start=1)):
                        if x < 28:
                            if i == 0:
                                self.signals.update_io_status.emit("input", x, y)
                            else:
                                self.signals.update_io_status.emit("output", x, y)
                        else:
                            if i == 0:
                                self.signals.update_io_status.emit("input", x, y)
                            else:
                                self.signals.update_io_status.emit("output", x, y)
                        time.sleep(0.15)
                break
            else:
                self.signals.call_MsgBox.emit("Error", "Unable to get input/output status", "Critical")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at inside thread homing_all_thread function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                                  exc_tb.tb_lineno, e))

    def connect_ports(self):
        try:
            """
              This method is used to connect the ports.
              param lists: None
              return: None
            """
            port_return_value = ui.auto_port_connection()
            if port_return_value == "Port details csv file not found":
                self.signals.call_MsgBox.emit("Alert", "Port details csv file is not found", "Critical")
                return

            elif port_return_value == "Ports is None":
                self.signals.call_MsgBox.emit("Alert", "ports are not connected", "Critical")
                return

            self.signals.call_text.emit("PLC", "In progress", [])
            time.sleep(1)
            plc_return_value = ui_plc_communication.connect_plc(str(port_return_value[0]))
            if plc_return_value == "Connected":
                self.signals.call_text.emit("PLC", "Connected", [])
            else:
                self.signals.call_text.emit("PLC", "Not Connected", [])
                logger.error("PLC connection error: {}".format(plc_return_value))

            self.signals.call_text.emit("PLC 2", "In progress", [])
            time.sleep(1)
            plc_return_value_1 = ui_plc_communication.connect_plc_2(str(port_return_value[1]))
            if plc_return_value_1 == "Connected":
                self.signals.call_text.emit("PLC 2", "Connected", [])
            else:
                self.signals.call_text.emit("PLC 2", "Not Connected", [])
                logger.error("PLC 2 connection error: {}".format(plc_return_value_1))

            self.signals.call_text.emit("Modbus", "In progress", [])
            time.sleep(1)
            modbus_return_value = ui_plc_communication.connect_modbus(str(port_return_value[2]))
            if modbus_return_value == "Connected":
                self.signals.call_text.emit("Modbus", "Connected", [])
            else:
                logger.error("Modbus connection error: {}".format(modbus_return_value))
                self.signals.call_text.emit("Modbus", "Not Connected", [])

            self.signals.call_text.emit("UV", "In progress", [])
            time.sleep(1)
            uv_return_value = ui_plc_communication.connect_uv(str(port_return_value[3]))
            if uv_return_value == "Connected":
                self.signals.call_text.emit("UV", "Connected", [])
            else:
                logger.error("UV connection error: {}".format(uv_return_value))
                self.signals.call_text.emit("UV", "Not Connected", [])

            self.signals.call_text.emit("Collimator", "In progress", [])

            # collimator_return_value = ui_plc_communication.connect_collimator([1, 2, 3, 4, 5])
            collimator_return_value = "Connected"
            if collimator_return_value == "Connected":
                self.signals.call_text.emit("Collimator", "Connected", [])
            else:
                logger.error("Collimator connection error: {}".format(collimator_return_value))
                self.signals.call_text.emit("Collimator", "Not Connected", [])

            self.signals.call_text.emit("Light_panel", "In progress", [])
            time.sleep(1)
            light_panel_return_value = ui_plc_communication.connect_light_panel(str(port_return_value[4]))
            if light_panel_return_value == "Connected":
                self.signals.call_text.emit("Light_panel", "Connected", [])
            else:
                logger.error("Light panel connection error: {}".format(light_panel_return_value))
                self.signals.call_text.emit("Light_panel", "Not Connected", [])

            if (plc_return_value == "Connected" and plc_return_value_1 == "Connected" and
                    modbus_return_value == "Connected" and uv_return_value == "Connected" and
                    collimator_return_value == "Connected" and light_panel_return_value == "Connected"):
                time.sleep(1)
                if ui.app_opened_now:
                    ui.machine_flow.port_dialog.close()
                    time.sleep(1)
                    ui.ready_port = True
                    ui.is_all_homing = True
                    self.signals.call_MsgBox.emit("Question", "Do you want to perform machine homing?", "Question")
                    while True:
                        if ui.user_call_init_yes:
                            break
                        elif ui.user_call_init_no:
                            break

                    if ui.user_call_init_yes:
                        ui.user_call_init_yes = False
                        self.homing_all_thread()

                    elif ui.user_call_init_no:
                        ui.user_call_init_no = False
                        return

                ui.ready_port = True
                return

            else:
                ui.ready_port = False

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at connect_ports function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
            self.signals.close_dialog.emit()
            if not ui.is_all_homing:
                ui.is_all_homing = False


class diagnostic_control(QRunnable):
    """
    This class is used to run the Qrunnable thread for diagnostic page controller.
    """

    def __init__(self, threadpool):
        super(diagnostic_control, self).__init__()
        self.signals = WorkerSignals()
        self.threadpool = threadpool

    def run(self):
        self.threadpool.reserveThread()
        if ui.machine_movement_clicked:
            ui.machine_movement_clicked = False
            logger.info("*********Diagnostic page thread started*************")
            self.diagnostic_page_controller()
        ui.identify_btn = None
        logger.info("Diagnostic Thread Completed")
        self.threadpool.releaseThread()
        logger.info("*********Diagnostic Thread Completed!*************")

    def verify_input_status(self):
        try:
            """
              This method is used to get the io status.
              param lists: None
              return: None
            """
            while True:
                status = ui_plc_communication.plc_control_class.check_input_status()
                if status == "Status updated":
                    value = ui_plc_communication.plc_control_class.input_status
                    if value["EMO"]:
                        return "Emergency pressed"
                    elif not value["Air Pressure"]:
                        return "Air Pressure is low"
                    elif not value["EMS"]:
                        return "Earth leakage"
                    elif not value["Control Panel Door Sensor"]:
                        return "Control panel door is opened"
                    else:
                        return "Done"
                else:
                    time.sleep(1)

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            func_name = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at verify_input_status function : {}|{}|{}|{}".format(exc_type, func_name,
                                                                                      exc_tb.tb_lineno, e))

    def diagnostic_page_controller(self):
        try:
            """
              This method is used to move the plc and actuators.
              param lists: None
              return: None
            """
            if ui.identify_btn is not None:
                if ui.identify_btn == 'gripper open' or ui.identify_btn == 'gripper manual open':
                    self.signals.call_texts.emit('gripper open', "in progress", str(ui.gripper_act_current_value))
                    time.sleep(0.25)
                    if ui.identify_btn != 'gripper manual open':
                        ui.value_to_move = abs(ui.value_to_move + float(ui.gripper_act_current_value))

                    if ui.value_to_move < float(ui.machine_flow.gripper_min_distance_lnedt.text()):
                        self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                               "value allowed in the textbox.", "Critical")

                    if ui.value_to_move > float(ui.machine_flow.gripper_max_distance_lnedt.text()):
                        self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the maximum "
                                                               "value allowed in the textbox.", "Critical")
                    else:
                        return_value = ui_plc_communication.plc_control_class.gripper(gripper=ui.value_to_move)
                        if return_value == "Passed":
                            ui.gripper_act_current_value = float(ui.value_to_move)
                            self.signals.call_texts.emit('gripper open', "Gripper moved",
                                                         str(ui.gripper_act_current_value))
                            logger.info("Gripper is moved {}mm".format(ui.value_to_move))

                        else:
                            check_error = self.verify_input_status()
                            if check_error != "Done":
                                self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")
                                self.signals.call_texts.emit('gripper open', f"{check_error}",
                                                             str(ui.gripper_act_current_value))
                            else:
                                self.signals.call_MsgBox.emit("Alert", "Gripper movement failed", "Critical")
                                self.signals.call_texts.emit('gripper open', "Gripper movement failed",
                                                             str(ui.gripper_act_current_value))
                            logger.error(f"Gripper movement failed: {return_value}")

                elif ui.identify_btn == 'gripper close' or ui.identify_btn == 'gripper manual close':
                    self.signals.call_texts.emit('gripper close', "in progress", str(ui.gripper_act_current_value))

                    if ui.identify_btn != 'gripper manual close':
                        ui.value_to_move = abs(ui.value_to_move - float(ui.gripper_act_current_value))

                    if ui.value_to_move < float(ui.machine_flow.gripper_min_distance_lnedt.text()):
                        self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                               "value allowed in the textbox.", "Critical")

                    elif ui.value_to_move > float(ui.machine_flow.gripper_max_distance_lnedt.text()):
                        self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the maximum "
                                                               "value allowed in the textbox.", "Critical")
                    else:
                        return_value = ui_plc_communication.plc_control_class.gripper(gripper=ui.value_to_move)
                        if return_value == "Passed":
                            ui.gripper_act_current_value = float(ui.value_to_move)
                            self.signals.call_texts.emit('gripper close', "Gripper moved",
                                                         str(ui.gripper_act_current_value))
                            logger.info("Gripper is moved {}mm".format(ui.value_to_move))

                        else:
                            check_error = self.verify_input_status()
                            if check_error != "Done":
                                self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")
                                self.signals.call_texts.emit('gripper open', f"{check_error}",
                                                             str(ui.gripper_act_current_value))
                            else:
                                self.signals.call_MsgBox.emit("Alert", "Gripper movement failed", "Critical")
                                self.signals.call_texts.emit('gripper open', "Gripper movement failed",
                                                             str(ui.gripper_act_current_value))
                            logger.error(f"Gripper movement failed: {return_value}")

                elif ui.identify_btn == "Slider homing" or ui.identify_btn == "Gripper homing":
                    self.signals.call_texts.emit("Slider homing", "in progress", str(ui.slider_act_current_value))
                    self.signals.call_texts.emit("Gripper homing", "in progress", str(ui.gripper_act_current_value))
                    return_value = ui_plc_communication.plc_control_class.plc_initialize()
                    if return_value == "Passed":
                        ui.slider_act_current_value = 0.0
                        ui.gripper_act_current_value = 40.0
                        self.signals.call_texts.emit("Slider homing", "completed", "")
                        self.signals.call_texts.emit("Gripper homing", "completed", "")
                        logger.info("Plc init done")

                    else:
                        check_error = self.verify_input_status()
                        if check_error != "Done":
                            self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")
                            self.signals.call_texts.emit('plc init', f"{check_error}",
                                                         str(ui.slider_act_current_value))
                        else:
                            self.signals.call_MsgBox.emit("Alert", "Slider movement failed", "Critical")
                            self.signals.call_texts.emit('plc init', "Slider movement failed",
                                                         str(ui.slider_act_current_value))
                        logger.error(f"Slider movement failed: {return_value}")

                elif ui.identify_btn == 'slider down' or ui.identify_btn == 'slider manual down':
                    if ui.identify_btn != 'slider manual down':
                        ui.value_to_move = abs(ui.value_to_move - float(ui.slider_act_current_value))

                    if ui.value_to_move < float(ui.machine_flow.slider_min_distance_lnedt.text()):
                        self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                               "value allowed in the textbox.", "Critical")

                    elif ui.value_to_move > float(ui.machine_flow.slider_max_distance_lnedt.text()):
                        self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the maximum "
                                                               "value allowed in the textbox.", "Critical")
                    else:
                        self.signals.call_texts.emit('slider down', "in progress", str(ui.slider_act_current_value))
                        return_value = ui_plc_communication.plc_control_class.slider(slider=ui.value_to_move)
                        if return_value == "Passed":
                            ui.slider_act_current_value = float(ui.value_to_move)
                            self.signals.call_texts.emit('slider down', "Slider moved",
                                                         str(ui.slider_act_current_value))
                            logger.info("Slider is moved {}mm".format(ui.value_to_move))

                        else:
                            check_error = self.verify_input_status()
                            if check_error != "Done":
                                self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")
                            else:
                                self.signals.call_MsgBox.emit("Alert", "Slider movement failed", "Critical")
                            logger.error(f"Slider movement failed: {return_value}")

                elif ui.identify_btn == 'slider up' or ui.identify_btn == 'slider manual up':
                    self.signals.call_texts.emit('slider up', "in progress", str(ui.slider_act_current_value))
                    if ui.identify_btn != 'slider manual up':
                        ui.value_to_move = abs(ui.value_to_move + float(ui.slider_act_current_value))

                    if ui.value_to_move < float(ui.machine_flow.slider_min_distance_lnedt.text()):
                        self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                               "value allowed in the textbox.", "Critical")

                    if ui.value_to_move > float(ui.machine_flow.slider_max_distance_lnedt.text()):
                        self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the maximum "
                                                               "value allowed in the textbox.", "Critical")
                    else:
                        return_value = ui_plc_communication.plc_control_class.slider(slider=ui.value_to_move)
                        if return_value == "Passed":
                            ui.slider_act_current_value = float(ui.value_to_move)
                            self.signals.call_texts.emit('slider up', "Slider moved", str(ui.slider_act_current_value))
                            logger.info("Slider is moved {}mm".format(ui.value_to_move))

                        else:
                            check_error = self.verify_input_status()
                            if check_error != "Done":
                                self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")
                            else:
                                self.signals.call_MsgBox.emit("Alert", "Slider movement failed", "Critical")
                            logger.error(f"Slider movement failed: {return_value}")

                elif ui.identify_btn == 'Y-axis homing diagnostic':
                    self.signals.call_texts.emit('Y-axis homing diagnostic', "in progress", "")
                    return_value = ui_plc_communication.modbus_class.actuator_homing(1)
                    if return_value == "Passed":
                        self.signals.call_texts.emit('Y-axis homing diagnostic', "completed", str(5))
                        logger.info("Y-axis moved its homing position")

                    else:
                        check_error = ui_plc_communication.modbus_class.alarm_display(slave_id=1)
                        if check_error != "Passed":
                            self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")
                        logger.error(f"y-axis movement failed: {return_value}")

                elif ui.identify_btn == 'y-axis forward' or ui.identify_btn == 'y-axis manual forward':
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                    self.signals.call_texts.emit('y-axis forward', "in progress", str(actual_value))
                    if actual_value == float(ui.machine_flow.y_axis_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('y-axis forward', "Y-axis Moved", str(actual_value))
                        self.signals.call_MsgBox.emit("Information", "Y-axis reached the maximum value", "Information")

                    else:
                        if ui.identify_btn != 'y-axis manual forward':
                            ui.value_to_move[0] = abs(ui.value_to_move[0] + float(actual_value))

                        if ui.value_to_move[0] < float(ui.machine_flow.y_axis_min_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                   "value allowed in the textbox.", "Critical")

                        elif ui.value_to_move[0] > float(ui.machine_flow.y_axis_max_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert",
                                                          "The position cannot exceed the maximum value allowed in the "
                                                          "textbox.", "Critical")

                        else:
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=1,
                                                                                               distance=
                                                                                               ui.value_to_move[0],
                                                                                               speed=ui.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                                self.signals.call_texts.emit('y-axis forward', "Y-axis Moved", str(actual_value))
                                logger.info("Y-axis moved {}mm".format(ui.value_to_move))

                            else:
                                check_error = ui_plc_communication.modbus_class.alarm_display(slave_id=1)
                                if check_error != "Passed":
                                    self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")

                                logger.error(f"Y-axis movement failed: {check_error}")

                elif ui.identify_btn == 'y-axis reverse' or ui.identify_btn == 'y-axis manual reverse':
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                    self.signals.call_texts.emit('y-axis reverse', "in progress", str(actual_value))

                    if ui.identify_btn != 'y-axis manual reverse':
                        ui.value_to_move[0] = abs(ui.value_to_move[0] - float(actual_value))

                    if ui.value_to_move[0] < float(ui.machine_flow.y_axis_min_distance_lnedt.text()):
                        self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                               "value allowed in the textbox.", "Critical")

                    elif ui.value_to_move[0] > float(ui.machine_flow.y_axis_max_distance_lnedt.text()):
                        self.signals.call_MsgBox.emit("Alert",
                                                      "The position cannot exceed the maximum value allowed in the "
                                                      "textbox.", "Critical")

                    else:
                        return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=1,
                                                                                           distance=ui.value_to_move[0],
                                                                                           speed=ui.value_to_move[
                                                                                               1])
                        if return_value == "Passed":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                            self.signals.call_texts.emit('y-axis reverse', "Y-axis Moved", str(actual_value))
                            logger.info("Y-axis moved {}mm".format(ui.value_to_move))

                        else:
                            check_error = ui_plc_communication.modbus_class.alarm_display(slave_id=1)
                            if check_error != "Passed":
                                self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")
                            logger.error(f"Y-axis movement failed: {check_error}")

                elif ui.identify_btn == 'X-axis homing diagnostic':
                    self.signals.call_texts.emit('X-axis homing diagnostic', "in progress", "")
                    return_value = ui_plc_communication.modbus_class.actuator_homing(5)
                    if return_value == "Passed":
                        self.signals.call_texts.emit('X-axis homing diagnostic', "completed", str(5))
                        logger.info("X-axis moved its homing position")

                    else:
                        check_error = ui_plc_communication.modbus_class.alarm_display(slave_id=5)
                        if check_error != "Passed":
                            self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")
                        logger.error(f"x-axis movement failed: {return_value}")

                elif ui.identify_btn == 'x-axis forward' or ui.identify_btn == 'x-axis manual forward':
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                    self.signals.call_texts.emit('x-axis forward', "in progress", str(actual_value))
                    if actual_value == float(ui.machine_flow.x_axis_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('x-axis forward', "X-axis Moved", str(actual_value))
                        self.signals.call_MsgBox.emit("Information", "x-axis reached the maximum value", "Information")

                    else:
                        if ui.identify_btn != 'x-axis manual forward':
                            ui.value_to_move[0] = abs(ui.value_to_move[0] + float(actual_value))

                        if ui.value_to_move[0] < float(ui.machine_flow.x_axis_min_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                   "value allowed in the textbox.", "Critical")

                        elif ui.value_to_move[0] > float(ui.machine_flow.x_axis_max_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert",
                                                          "The position cannot exceed the maximum value allowed in the "
                                                          "textbox.", "Critical")

                        else:
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=5,
                                                                                               distance=
                                                                                               ui.value_to_move[0],
                                                                                               speed=ui.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                                self.signals.call_texts.emit('x-axis forward', "X-axis Moved", str(actual_value))
                                logger.info("x-axis moved {}mm".format(ui.value_to_move))

                            else:
                                self.signals.call_texts.emit('x-axis forward', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"x-axis movement failed: {return_value}")

                elif ui.identify_btn == 'x-axis reverse' or ui.identify_btn == 'x-axis manual reverse':
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                    self.signals.call_texts.emit('x-axis reverse', "in progress", str(actual_value))
                    if ui.identify_btn != 'x-axis manual reverse':
                        ui.value_to_move[0] = abs(ui.value_to_move[0] - float(actual_value))

                    if ui.value_to_move[0] < float(ui.machine_flow.x_axis_min_distance_lnedt.text()):
                        self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                               "value allowed in the textbox.", "Critical")

                    elif ui.value_to_move[0] > float(ui.machine_flow.x_axis_max_distance_lnedt.text()):
                        self.signals.call_MsgBox.emit("Alert",
                                                      "The position cannot exceed the maximum value allowed in the "
                                                      "textbox.", "Critical")

                    else:
                        return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=5,
                                                                                           distance=ui.value_to_move[0],
                                                                                           speed=ui.value_to_move[
                                                                                               1])
                        if return_value == "Passed":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                            self.signals.call_texts.emit('x-axis reverse', "X-axis Moved", str(actual_value))
                            logger.info("x-axis moved {}mm".format(ui.value_to_move))

                        else:
                            self.signals.call_texts.emit('x-axis reverse', "{}".format(return_value),
                                                         str(actual_value))
                            logger.error(f"x-axis movement failed: {return_value}")

                elif ui.identify_btn == "front door open diagnostic":
                    self.signals.call_texts.emit("front door open diagnostic", "in progress", "")
                    return_value = ui_plc_communication.plc_control_class.front_door_open()
                    if return_value == "Passed":
                        ui.uv_door_act_open = True
                        self.signals.call_texts.emit("front door open diagnostic", "completed", "")
                    else:
                        ui.uv_door_act_open = False
                        self.signals.call_texts.emit("front door open diagnostic", "{}".format(return_value), "")
                        logger.info(f"front door open failed: {return_value}")

                elif ui.identify_btn == "front door close diagnostic":
                    self.signals.call_texts.emit("front door close diagnostic", "in progress", "")
                    return_value = ui_plc_communication.plc_control_class.front_door_close()
                    if return_value == "Passed":
                        ui.uv_door_act_open = False
                        self.signals.call_texts.emit("front door close diagnostic", "completed", "")
                    else:
                        ui.uv_door_act_open = True
                        self.signals.call_texts.emit("front door close diagnostic", "{}".format(return_value), "")
                        logger.info(f"front door close failed: {return_value}")

                elif ui.identify_btn == 'clockwise btn':
                    self.signals.call_texts.emit('clockwise btn', "in progress", "")
                    return_value = ui_plc_communication.plc_control_class.lens_rotate(degree=ui.value_to_move,
                                                                                      direction='clockwise')
                    if return_value == "Passed":
                        self.signals.call_texts.emit('clockwise btn', "clockwise rotation is done", "")
                        logger.info(f"{ui.value_to_move} degree clockwise rotation is completed")

                    else:
                        check_error = self.verify_input_status()
                        if check_error != "Done":
                            self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")
                        else:
                            self.signals.call_MsgBox.emit("Alert", "Rotation failed", "Critical")
                        logger.error(f"Lens rotation failed: {return_value}")

                elif ui.identify_btn == 'anti-clockwise btn':
                    self.signals.call_texts.emit('anti-clockwise btn', "in progress", "")
                    return_value = ui_plc_communication.plc_control_class.lens_rotate(degree=ui.value_to_move,
                                                                                      direction='anticlockwise')
                    if return_value == "Passed":
                        self.signals.call_texts.emit('anti-clockwise btn', "anti-clockwise rotation is done", "")
                        logger.info(f"{ui.value_to_move} degree anti-clockwise rotation is completed")

                    else:
                        check_error = self.verify_input_status()
                        if check_error != "Done":
                            self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")
                        else:
                            self.signals.call_MsgBox.emit("Alert", "Rotation failed", "Critical")
                        logger.error(f"Lens rotation failed: {return_value}")

                elif ui.identify_btn == "Relay Z-axis homing diagnostic":
                    self.signals.call_texts.emit("Relay Z-axis homing diagnostic", "in progress", "")
                    return_value = ui_plc_communication.modbus_class.actuator_homing(2)
                    if return_value == "Passed":
                        self.signals.call_texts.emit("Relay Z-axis homing diagnostic", "completed", str(5))
                        logger.info("X-axis moved its homing position")

                    else:
                        check_error = ui_plc_communication.modbus_class.alarm_display(slave_id=2)
                        if check_error != "Passed":
                            self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")
                        logger.error(f"x-axis movement failed: {return_value}")

                elif ui.identify_btn == 'light panel up' or ui.identify_btn == 'light panel manual up':
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(2)
                    self.signals.call_texts.emit('light panel up', "in progress", str(actual_value))
                    if actual_value == float(ui.machine_flow.light_panel_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('light panel up', "Z-axis Moved", str(actual_value))
                        self.signals.call_MsgBox.emit("Information", "Z-axis reached the maximum value", "Information")

                    else:
                        if ui.identify_btn != 'light panel manual up':
                            ui.value_to_move[0] = abs(ui.value_to_move[0] + float(actual_value))

                        if ui.value_to_move[0] < float(ui.machine_flow.light_panel_min_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                   "value allowed in the textbox.", "Critical")

                        elif ui.value_to_move[0] > float(ui.machine_flow.light_panel_max_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert",
                                                          "The position cannot exceed the maximum value allowed in the "
                                                          "textbox.", "Critical")

                        else:
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=2,
                                                                                               distance=
                                                                                               ui.value_to_move[0],
                                                                                               speed=ui.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(2)
                                self.signals.call_texts.emit('light panel up', "Z-axis Moved", str(actual_value))
                                logger.info("Z-axis moved {}mm".format(ui.value_to_move))

                            else:
                                self.signals.call_texts.emit('light panel up', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"Z-axis movement failed: {return_value}")

                elif ui.identify_btn == 'light panel down' or ui.identify_btn == 'light panel manual down':
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(2)
                    self.signals.call_texts.emit('light panel down', "in progress", str(actual_value))
                    if actual_value == float(ui.machine_flow.light_panel_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('light panel down', "Z-axis Moved", str(actual_value))
                        self.signals.call_MsgBox.emit("Information", "Z-axis reached the maximum value", "Information")

                    else:
                        if ui.identify_btn != 'light panel manual down':
                            ui.value_to_move[0] = abs(ui.value_to_move[0] - float(actual_value))

                        if ui.value_to_move[0] < float(ui.machine_flow.light_panel_min_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                   "value allowed in the textbox.", "Critical")

                        elif ui.value_to_move[0] > float(ui.machine_flow.light_panel_max_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert",
                                                          "The position cannot exceed the maximum value allowed in the "
                                                          "textbox.", "Critical")

                        else:
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=2,
                                                                                               distance=
                                                                                               ui.value_to_move[0],
                                                                                               speed=ui.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(2)
                                self.signals.call_texts.emit('light panel down', "Z-axis Moved", str(actual_value))
                                logger.info("Z-axis moved {}mm".format(ui.value_to_move))

                            else:
                                self.signals.call_texts.emit('light panel down', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"Z-axis movement failed: {return_value}")

                elif ui.identify_btn == "Relay intensity":
                    self.signals.call_texts.emit("Relay intensity", "in progress", "")
                    return_value = ui_plc_communication.plc_control_class.light_panel_lux(value=ui.value_to_move)
                    if return_value == "Passed":
                        self.signals.call_texts.emit("Relay intensity", "lux set", '')
                        logger.info("Relay lux value is set")
                    else:
                        self.signals.call_texts.emit("Relay intensity", "{}".format(return_value),
                                                     "")
                        logger.info(f"Unable to set relay lux value {return_value}")

                elif ui.identify_btn == "Gluing Z-axis homing diagnostic":
                    self.signals.call_texts.emit("Gluing Z-axis homing diagnostic", "in progress", "")
                    return_value = ui_plc_communication.modbus_class.actuator_homing(3)
                    if return_value == "Passed":
                        self.signals.call_texts.emit("Gluing Z-axis homing diagnostic", "completed", str(5))
                        logger.info("Z-axis moved its homing position")

                    else:
                        check_error = ui_plc_communication.modbus_class.alarm_display(slave_id=3)
                        if check_error != "Passed":
                            self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")
                        logger.error(f"z-axis movement failed: {return_value}")

                elif ui.identify_btn == 'Gluing z-axis down' or ui.identify_btn == 'light panel manual down':
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(3)
                    self.signals.call_texts.emit('Gluing z-axis down', "in progress", str(actual_value))
                    if actual_value == float(ui.machine_flow.gd_z_axis_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('Gluing z-axis down', "Z-axis Moved", str(actual_value))
                        self.signals.call_MsgBox.emit("Information", "Z-axis reached the maximum value", "Information")

                    else:
                        if ui.identify_btn != 'light panel manual down':
                            ui.value_to_move[0] = abs(ui.value_to_move[0] - float(actual_value))

                        if ui.value_to_move[0] < float(ui.machine_flow.gd_z_axis_min_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                   "value allowed in the textbox.", "Critical")

                        elif ui.value_to_move[0] > float(ui.machine_flow.gd_z_axis_max_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert",
                                                          "The position cannot exceed the maximum value allowed in the "
                                                          "textbox.", "Critical")

                        else:
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=3,
                                                                                               distance=
                                                                                               ui.value_to_move[0],
                                                                                               speed=ui.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(3)
                                self.signals.call_texts.emit('Gluing z-axis down', "Z-axis Moved", str(actual_value))
                                logger.info("Z-axis moved {}mm".format(ui.value_to_move))

                            else:
                                self.signals.call_texts.emit('Gluing z-axis down', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"Z-axis movement failed: {return_value}")

                elif ui.identify_btn == 'Gluing z-axis up' or ui.identify_btn == 'Gluing z-axis manual up':
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(3)
                    self.signals.call_texts.emit('Gluing z-axis up', "in progress", str(actual_value))
                    if actual_value == float(ui.machine_flow.gd_z_axis_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('Gluing z-axis up', "Z-axis Moved", str(actual_value))
                        self.signals.call_MsgBox.emit("Information", "Z-axis reached the maximum value", "Information")

                    else:
                        if ui.identify_btn != 'Gluing z-axis manual up':
                            ui.value_to_move[0] = abs(ui.value_to_move[0] + float(actual_value))

                        if ui.value_to_move[0] < float(ui.machine_flow.gd_z_axis_min_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                   "value allowed in the textbox.", "Critical")

                        if ui.value_to_move[0] > float(ui.machine_flow.gd_z_axis_max_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert",
                                                          "The position cannot exceed the maximum value allowed in the "
                                                          "textbox.", "Critical")

                        else:
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=3,
                                                                                               distance=
                                                                                               ui.value_to_move[0],
                                                                                               speed=ui.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(3)
                                self.signals.call_texts.emit('Gluing z-axis up', "Z-axis Moved", str(actual_value))
                                logger.info("Z-axis moved {}mm".format(ui.value_to_move))

                            else:
                                self.signals.call_texts.emit('Gluing z-axis up', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"Z-axis movement failed: {return_value}")

                elif ui.identify_btn == 'Gluing x1 inside' or ui.identify_btn == 'Gluing x1 manual inside':
                    self.signals.call_texts.emit('Gluing x1 inside', "in progress", str(ui.gluing_x1_act_current_value))
                    if float(ui.gluing_x1_act_current_value) == float(
                            ui.machine_flow.gluing_x1_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('Gluing x1 inside', "Gluing X1 moved",
                                                     str(ui.gluing_x1_act_current_value))
                    else:
                        time.sleep(0.15)
                        speed = ui_plc_communication.plc_control_class.write_glue_speed(speed=float(ui.value_to_move[1]))
                        if speed == "Passed":
                            time.sleep(0.15)
                            if ui.identify_btn != 'Gluing x1 manual inside':
                                ui.value_to_move[0] = abs(ui.value_to_move[0] + float(ui.gluing_x1_act_current_value))

                            if ui.value_to_move[0] < float(ui.machine_flow.gluing_x1_min_distance_lnedt.text()):
                                self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                       "value allowed in the textbox.", "Critical")

                            elif ui.value_to_move[0] > float(ui.machine_flow.gluing_x1_max_distance_lnedt.text()):
                                self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the maximum "
                                                                       "value allowed in the textbox.", "Critical")
                            else:
                                return_value = ui_plc_communication.plc_control_class. \
                                    glue_manual_move_recipe(x1_manual=ui.value_to_move[0])
                                if return_value == "Passed":
                                    ui.gluing_x1_act_current_value = float(ui.value_to_move[0])
                                    self.signals.call_texts.emit('Gluing x1 inside', "Gluing X1 moved",
                                                                 str(ui.gluing_x1_act_current_value))
                                    logger.info("Gluing X1 is moved {}mm".format(ui.value_to_move[0]))

                                else:
                                    ui.gripper_act_current_value = 2.0
                                    self.signals.call_texts.emit('Gluing x1 inside', "{}".format(return_value),
                                                                 str(ui.gluing_x1_act_current_value))
                                    logger.error(f"Gluing X1 movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", "Unable to write speed", "Critical")

                elif ui.identify_btn == 'Gluing x1 outside' or ui.identify_btn == 'Gluing x1 manual outside':
                    self.signals.call_texts.emit('Gluing x1 outside', "in progress",
                                                 str(ui.gluing_x1_act_current_value))
                    if float(ui.gluing_x1_act_current_value) == float(
                            ui.machine_flow.gluing_x1_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('Gluing x1 outside', "Gluing X1 moved",
                                                     str(ui.gluing_x1_act_current_value))
                    else:
                        time.sleep(0.25)
                        speed = ui_plc_communication.plc_control_class.write_glue_speed(speed=float(ui.value_to_move[1]))
                        if speed == "Passed":
                            time.sleep(0.15)
                            if ui.identify_btn != 'Gluing x1 manual outside':
                                ui.value_to_move[0] = abs(ui.value_to_move[0] - float(ui.gluing_x1_act_current_value))

                            if ui.value_to_move[0] < float(ui.machine_flow.gluing_x1_min_distance_lnedt.text()):
                                self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                       "value allowed in the textbox.", "Critical")

                            elif ui.value_to_move[0] > float(ui.machine_flow.gluing_x1_max_distance_lnedt.text()):
                                self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the maximum "
                                                                       "value allowed in the textbox.", "Critical")
                            else:
                                return_value = ui_plc_communication.plc_control_class. \
                                    glue_manual_move_recipe(x1_manual=ui.value_to_move[0])
                                if return_value == "Passed":
                                    ui.gluing_x1_act_current_value = float(ui.value_to_move[0])
                                    self.signals.call_texts.emit('Gluing x1 outside', "Gluing X1 moved",
                                                                 str(ui.gluing_x1_act_current_value))
                                    logger.info("Gluing X1 is moved {}mm".format(ui.value_to_move[0]))

                                else:
                                    ui.gripper_act_current_value = 2.0
                                    self.signals.call_texts.emit('Gluing x1 outside', "{}".format(return_value),
                                                                 str(ui.gluing_x1_act_current_value))
                                    logger.error(f"Gluing X1 movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", "Unable to write speed", "Critical")

                elif ui.identify_btn == 'Gluing x2 inside' or ui.identify_btn == 'Gluing x2 manual inside':
                    self.signals.call_texts.emit('Gluing x2 inside', "in progress", str(ui.gluing_x2_act_current_value))
                    if float(ui.gluing_x2_act_current_value) == float(
                            ui.machine_flow.gluing_x2_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('Gluing x2 inside', "Gluing x2 moved",
                                                     str(ui.gluing_x2_act_current_value))

                    else:
                        time.sleep(0.25)
                        speed = ui_plc_communication.plc_control_class.write_glue_speed(
                            speed=float(ui.value_to_move[1]))
                        if speed == "Passed":
                            time.sleep(0.15)
                            if ui.identify_btn != 'Gluing x2 manual inside':
                                ui.value_to_move[0] = abs(ui.value_to_move[0] + float(ui.gluing_x2_act_current_value))

                            if ui.value_to_move[0] < float(ui.machine_flow.gluing_x2_min_distance_lnedt.text()):
                                self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                       "value allowed in the textbox.", "Critical")

                            elif ui.value_to_move[0] > float(ui.machine_flow.gluing_x2_max_distance_lnedt.text()):
                                self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the maximum "
                                                                       "value allowed in the textbox.", "Critical")
                            else:
                                return_value = ui_plc_communication.plc_control_class. \
                                    glue_manual_move_recipe(x2_manual=ui.value_to_move[0], port_number="Port 2")
                                if return_value == "Passed":
                                    ui.gluing_x2_act_current_value = float(ui.value_to_move[0])
                                    self.signals.call_texts.emit('Gluing x2 inside', "Gluing x2 moved",
                                                                 str(ui.gluing_x2_act_current_value))
                                    logger.info("Gluing x2 is moved {}mm".format(ui.value_to_move[0]))

                                else:
                                    ui.gripper_act_current_value = 2.0
                                    self.signals.call_texts.emit('Gluing x2 inside', "{}".format(return_value),
                                                                 str(ui.gluing_x2_act_current_value))
                                    logger.error(f"Gluing X2 movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", "Unable to write speed", "Critical")

                elif ui.identify_btn == 'Gluing x2 outside' or ui.identify_btn == 'Gluing x2 manual outside':
                    self.signals.call_texts.emit('Gluing x2 outside', "in progress",
                                                 str(ui.gluing_x2_act_current_value))
                    if float(ui.gluing_x2_act_current_value) == float(
                            ui.machine_flow.gluing_x2_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('Gluing x2 outside', "Gluing x2 moved",
                                                     str(ui.gluing_x2_act_current_value))
                    else:
                        time.sleep(0.25)
                        speed = ui_plc_communication.plc_control_class.write_glue_speed(
                            speed=float(ui.value_to_move[1]))
                        if speed == "Passed":
                            time.sleep(0.15)
                            if ui.identify_btn != 'Gluing x2 manual outside':
                                ui.value_to_move[0] = abs(ui.value_to_move[0] - float(ui.gluing_x2_act_current_value))

                            if ui.value_to_move[0] < float(ui.machine_flow.gluing_x2_min_distance_lnedt.text()):
                                self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                       "value allowed in the textbox.", "Critical")

                            elif ui.value_to_move[0] > float(ui.machine_flow.gluing_x2_max_distance_lnedt.text()):
                                self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the maximum "
                                                                       "value allowed in the textbox.", "Critical")
                            else:
                                return_value = ui_plc_communication.plc_control_class. \
                                    glue_manual_move_recipe(x2_manual=ui.value_to_move[0], port_number="Port 2")
                                if return_value == "Passed":
                                    ui.gluing_x2_act_current_value = float(ui.value_to_move[0])
                                    self.signals.call_texts.emit('Gluing x2 outside', "Gluing x2 moved",
                                                                 str(ui.gluing_x2_act_current_value))
                                    logger.info("Gluing x2 is moved {}mm".format(ui.value_to_move[0]))

                                else:
                                    ui.gripper_act_current_value = 2.0
                                    self.signals.call_texts.emit('Gluing x2 outside', "{}".format(return_value),
                                                                 str(ui.gluing_x2_act_current_value))
                                    logger.error(f"Gluing X2 movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", "Unable to write speed", "Critical")

                elif ui.identify_btn == 'Gluing y inside' or ui.identify_btn == 'Gluing y manual inside':
                    self.signals.call_texts.emit('Gluing y inside', "in progress", str(ui.gluing_y_act_current_value))
                    if float(ui.gluing_y_act_current_value) == float(
                            ui.machine_flow.gluing_y_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('Gluing y inside', "Gluing y moved",
                                                     str(ui.gluing_y_act_current_value))
                    else:
                        time.sleep(0.25)
                        speed = ui_plc_communication.plc_control_class.write_glue_speed(
                            speed=float(ui.value_to_move[1]))
                        if speed == "Passed":
                            time.sleep(0.15)
                            if ui.identify_btn != 'Gluing y manual inside':
                                ui.value_to_move[0] = abs(ui.value_to_move[0] + float(ui.gluing_y_act_current_value))

                            if ui.value_to_move[0] < float(ui.machine_flow.gluing_y_min_distance_lnedt.text()):
                                self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                       "value allowed in the textbox.", "Critical")

                            elif ui.value_to_move[0] > float(ui.machine_flow.gluing_y_max_distance_lnedt.text()):
                                self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the maximum "
                                                                       "value allowed in the textbox.", "Critical")
                            else:
                                return_value = ui_plc_communication.plc_control_class. \
                                    glue_manual_move_recipe(y_manual=ui.value_to_move[0])
                                if return_value == "Passed":
                                    ui.gluing_y_act_current_value = float(ui.value_to_move[0])
                                    self.signals.call_texts.emit('Gluing y inside', "Gluing y moved",
                                                                 str(ui.gluing_y_act_current_value))
                                    logger.info("Gluing y is moved {}mm".format(ui.value_to_move[0]))

                                else:
                                    ui.gripper_act_current_value = 2.0
                                    self.signals.call_texts.emit('Gluing y inside', "{}".format(return_value),
                                                                 str(ui.gluing_y_act_current_value))
                                    logger.error(f"Gluing y movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", "Unable to write speed", "Critical")

                elif ui.identify_btn == 'Gluing y outside' or ui.identify_btn == 'Gluing y manual outside':
                    self.signals.call_texts.emit('Gluing y outside', "in progress", str(ui.gluing_y_act_current_value))
                    if float(ui.gluing_y_act_current_value) == float(
                            ui.machine_flow.gluing_y_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('Gluing y outside', "Gluing y moved",
                                                     str(ui.gluing_y_act_current_value))
                    else:
                        time.sleep(0.25)
                        speed = ui_plc_communication.plc_control_class.write_glue_speed(
                            speed=float(ui.value_to_move[1]))
                        if speed == "Passed":
                            time.sleep(0.15)
                            if ui.identify_btn != 'Gluing y manual outside':
                                ui.value_to_move[0] = abs(ui.value_to_move[0] - float(ui.gluing_y_act_current_value))

                            if ui.value_to_move[0] < float(ui.machine_flow.gluing_y_min_distance_lnedt.text()):
                                self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                       "value allowed in the textbox.", "Critical")

                            if ui.value_to_move[0] > float(ui.machine_flow.gluing_y_max_distance_lnedt.text()):
                                self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the maximum "
                                                                       "value allowed in the textbox.", "Critical")
                            else:
                                return_value = ui_plc_communication.plc_control_class. \
                                    glue_manual_move_recipe(y_manual=ui.value_to_move[0])
                                if return_value == "Passed":
                                    ui.gluing_y_act_current_value = float(ui.value_to_move[0])
                                    self.signals.call_texts.emit('Gluing y outside', "Gluing y moved",
                                                                 str(ui.gluing_y_act_current_value))
                                    logger.info("Gluing y is moved {}mm".format(ui.value_to_move[0]))

                                else:
                                    ui.gripper_act_current_value = 2.0
                                    self.signals.call_texts.emit('Gluing y outside', "{}".format(return_value),
                                                                 str(ui.gluing_y_act_current_value))
                                    logger.error(f"Gluing y movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", "Unable to write speed", "Critical")

                elif ui.identify_btn == "Glue purge":
                    self.signals.call_texts.emit('Glue purge diagnostic', "in progress", "")
                    return_value = ui_plc_communication.plc_control_class.glue_dispenser_timer(timer=ui.value_to_move)
                    if return_value == "Passed":
                        self.signals.call_texts.emit('Glue purge diagnostic', "Gluing purge is done", "")
                    else:
                        self.signals.call_texts.emit('Glue purge diagnostic', "{}".format(return_value), "")
                        logger.error(f"Gluing purge failed: {return_value}")

                elif ui.identify_btn == "Gluing homing":
                    self.signals.call_texts.emit('Gluing init diagnostic', "in progress", "")
                    return_value = ui_plc_communication.plc_control_class.gluing_init()
                    if return_value == "Passed":
                        ui.gluing_y_act_current_value = 0
                        ui.gluing_x1_act_current_value = 0
                        ui.gluing_x2_act_current_value = 0
                        self.signals.call_texts.emit('Gluing init diagnostic', "Gluing init is done", "")
                        logger.info("Gluing homing is done")

                    else:
                        self.signals.call_texts.emit('Gluing init diagnostic', "{}".format(return_value), "")
                        logger.error(f"Gluing init failed: {return_value}")

                elif ui.identify_btn == "Curing Z-axis homing diagnostic":
                    self.signals.call_texts.emit("Curing Z-axis homing diagnostic", "in progress", "")
                    return_value = ui_plc_communication.modbus_class.actuator_homing(4)
                    if return_value == "Passed":
                        self.signals.call_texts.emit("Curing Z-axis homing diagnostic", "completed", str(5))
                        logger.info("Curing Z-axis moved its homing position")

                    else:
                        check_error = ui_plc_communication.modbus_class.alarm_display(slave_id=4)
                        if check_error != "Passed":
                            self.signals.call_MsgBox.emit("Alert", f"{check_error}", "Critical")
                        logger.error(f"z-axis movement failed: {return_value}")

                elif ui.identify_btn == 'curing z-axis down' or ui.identify_btn == 'light panel manual down':
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(4)
                    self.signals.call_texts.emit('curing z-axis down', "in progress", str(actual_value))
                    if actual_value == float(ui.machine_flow.uv_z_axis_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('curing z-axis down', "Z-axis Moved", str(actual_value))
                        self.signals.call_MsgBox.emit("Information", "Z-axis reached the maximum value", "Information")

                    else:
                        if ui.identify_btn != 'light panel manual down':
                            ui.value_to_move[0] = abs(ui.value_to_move[0] - float(actual_value))

                        if ui.value_to_move[0] < float(ui.machine_flow.uv_z_axis_min_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                   "value allowed in the textbox.", "Critical")

                        elif ui.value_to_move[0] > float(ui.machine_flow.uv_z_axis_max_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert",
                                                          "The position cannot exceed the maximum value allowed in the "
                                                          "textbox.", "Critical")

                        else:
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=4,
                                                                                               distance=
                                                                                               ui.value_to_move[0],
                                                                                               speed=ui.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(4)
                                self.signals.call_texts.emit('curing z-axis down', "Z-axis Moved", str(actual_value))
                                logger.info("Z-axis moved {}mm".format(ui.value_to_move))

                            else:
                                self.signals.call_texts.emit('curing z-axis down', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"Z-axis movement failed: {return_value}")

                elif ui.identify_btn == 'curing z-axis up' or ui.identify_btn == 'curing z-axis manual up':
                    actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(4)
                    self.signals.call_texts.emit('curing z-axis up', "in progress", str(actual_value))
                    if actual_value == float(ui.machine_flow.uv_z_axis_max_distance_lnedt.text()):
                        self.signals.call_texts.emit('curing z-axis up', "Z-axis Moved", str(actual_value))
                        self.signals.call_MsgBox.emit("Information", "Z-axis reached the maximum value", "Information")

                    else:
                        if ui.identify_btn != 'curing z-axis manual up':
                            ui.value_to_move[0] = abs(ui.value_to_move[0] + float(actual_value))

                        if ui.value_to_move[0] < float(ui.machine_flow.uv_z_axis_min_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert", "The position cannot exceed the minimum "
                                                                   "value allowed in the textbox.", "Critical")

                        elif ui.value_to_move[0] > float(ui.machine_flow.uv_z_axis_max_distance_lnedt.text()):
                            self.signals.call_MsgBox.emit("Alert",
                                                          "The position cannot exceed the maximum value allowed in the "
                                                          "textbox.", "Critical")

                        else:
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=4,
                                                                                               distance=
                                                                                               ui.value_to_move[0],
                                                                                               speed=ui.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(4)
                                self.signals.call_texts.emit('curing z-axis up', "Z-axis Moved", str(actual_value))
                                logger.info("Z-axis moved {}mm".format(ui.value_to_move))

                            else:
                                self.signals.call_texts.emit('curing z-axis up', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"Z-axis movement failed: {return_value}")

                elif ui.identify_btn == "curing door open diagnostic":
                    self.signals.call_texts.emit("curing door open diagnostic", "in progress", "")
                    return_value = ui_plc_communication.plc_control_class.uv_door_open()
                    if return_value == "Passed":
                        ui.uv_door_act_open = True
                        self.signals.call_texts.emit("curing door open diagnostic", "completed", "")
                    else:
                        ui.uv_door_act_open = False
                        self.signals.call_texts.emit("curing door open diagnostic", "{}".format(return_value), "")
                        logger.info(f"Curing door open failed: {return_value}")

                elif ui.identify_btn == "curing door close diagnostic":
                    self.signals.call_texts.emit("curing door close diagnostic", "in progress", "")
                    return_value = ui_plc_communication.plc_control_class.uv_door_close()
                    if return_value == "Passed":
                        ui.uv_door_act_open = False
                        self.signals.call_texts.emit("curing door close diagnostic", "completed", "")
                    else:
                        ui.uv_door_act_open = True
                        self.signals.call_texts.emit("curing door close diagnostic", "{}".format(return_value), "")
                        logger.info(f"Curing door close failed: {return_value}")

                elif ui.identify_btn == "Uv curing diagnostic":
                    self.signals.call_texts.emit("Uv curing diagnostic", "in progress", "")
                    uv_write = ui_plc_communication.uv_control_class.write_values(brightness=ui.value_to_move[1],
                                                                                  delay=ui.value_to_move[0])
                    if uv_write == "Passed":
                        return_value = ui_plc_communication.uv_control_class.uv_power_on()
                        if return_value == "Passed":
                            time.sleep(float(ui.value_to_move[0]))
                            self.signals.call_texts.emit("Uv curing diagnostic", "completed", "")
                        else:
                            self.signals.call_texts.emit("Uv curing diagnostic", "{}".format(return_value), "")
                            logger.info(f"Curing on failed: {return_value}")
                    else:
                        self.signals.call_texts.emit("Uv curing diagnostic", "{}".format(uv_write), "")
                        logger.info(f"Curing write failed: {uv_write}")

                ui.is_all_homing = False
                ui.identify_btn = None
                ui.value_to_move = 0

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at do_work init function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))


class Runnable_recipe_create(QRunnable):
    """
    This class is used to run the Qrunnable thread for machine movement in recipe creation page.
    """

    def __init__(self, threadpool, btn_type, position):
        try:
            super(Runnable_recipe_create, self).__init__()
            self.signals = WorkerSignals()
            self.threadpool = threadpool
            self.identify_btn = btn_type
            self.value_to_move = position

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(
                "Error at Runnable_recipe_create init function : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno,
                                                                                     e))

    def run(self):
        try:
            logger.info("*********Runnable_recipe_create_Thread Started!*************")
            self.threadpool.reserveThread()
            if ui.machine_movement_clicked:
                ui.machine_movement_clicked = False
                self.machine_move()
            self.identify_btn = None
            self.value_to_move = 0
            ui.recipe_btn_type = None
            logger.info("Runnable_recipe_create_Thread completed")
            self.threadpool.releaseThread()
            logger.info("*********Runnable_recipe_create_Thread Completed!*************")

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at Runnable_recipe_create run function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                             exc_tb.tb_lineno, e))

    @staticmethod
    def interlock_check(move="Y-axis"):
        try:
            """
              This method is used to verify the interlock before move the plc and actuators.
              param lists: None
              return: None
            """
            print(ui.gluing_x1_act_current_value, type(ui.gluing_x1_act_current_value),
                  ui.gluing_x2_act_current_value, type(ui.gluing_x2_act_current_value),
                  ui.gluing_y_act_current_value, type(ui.gluing_y_act_current_value),
                  ui.slider_act_current_value, type(ui.slider_act_current_value),
                  ui.gripper_act_current_value, type(ui.gripper_act_current_value),
                  ui.gluing_z_act_current_value, type(ui.gluing_z_act_current_value),
                  ui.y_act_current_value, type(ui.y_act_current_value),
                  ui.uv_door_act_open, type(ui.uv_door_act_open))

            if move == "Y-axis" or move == "Y-axis homing" or move == "Gluing Z-axis":
                if ui.gluing_x1_act_current_value != 0.0 or ui.gluing_x2_act_current_value != 0.0 or \
                        ui.gluing_y_act_current_value != 0.0:
                    logger.error("Unable to move Y-axis because of gluing not in homing")
                    return "Gluing actuators not in homing"

                elif move != "Gluing Z-axis":
                    if not ui.uv_door_act_open:
                        logger.error("Unable to move Y-axis because of UV door and cylinder is closed")
                        return "UV door and cylinder is closed"
                    else:
                        return "Done"
                else:
                    return "Done"

            elif move == "Gripper close":
                if ui.slider_act_current_value < 15:  # Add config
                    logger.error("Unable to close gripper because of slider value less than 30")
                    return "The slider value is below the minimum value."

                if not ui.part_loading_act_in:
                    logger.error("Unable to close gripper because of part loading not inside")
                    return "Part-loading doesn't inside."
                else:
                    return "Done"

            elif move == "part_loading out" or move == 'slider out' or move == "part_loading in":
                if ui.gripper_act_current_value != 40.0:
                    logger.error(f"Unable to {move} because of gripper doesn't opened")
                    return "Gripper should be opened"
                else:
                    return "Done"

            elif move == "X-axis homing" or move == "Plc int":
                if ui.gluing_z_act_current_value >= 15.0 and ui.y_act_current_value >= 1900:
                    logger.error(f"Unable to do {move} because of gluing Z-axis not in homing")
                    return f"Unable to do {move} because of gluing Z-axis not in homing"
                if ui.curing_z_act_current_value >= 15.0 and ui.y_act_current_value >= 1900:
                    logger.error(f"Unable to do {move} because of curing Z-axis not in homing")
                    return f"Unable to do {move} because of curing Z-axis not in homing"
                else:
                    return "Done"

            elif move == "UV door close":
                if ui.y_act_current_value >= 2380.0 or ui.y_act_current_value <= 1400.0:
                    return "Done"
                else:
                    logger.error("Unable to do UV door close because of Y-axis not in safe position.")
                    return "Unable to do UV door close because of Y-axis not in safe position."

            elif move == "UV Z-axis":
                if not ui.uv_door_act_open:
                    logger.error("Unable to move Z-axis because of UV cylinder is inside")
                    return "UV cylinder is inside"
                else:
                    return "Done"

            elif move == "Gluing x1" or move == "Gluing x2":
                if ui.gluing_y_act_current_value != 20.0:
                    logger.error(f"Unable to move {move} because of gluing y not in 20")
                    return "Gluing y value should be 20"
                else:
                    return "Done"

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at interlock_check function : {}|{}|{}|{}".format(exc_type, fname,
                                                                                  exc_tb.tb_lineno, e))

    def machine_move(self):
        try:
            """
              This method is used to move the plc and actuators.
              param lists: None
              return: None
            """
            if self.identify_btn is not None:
                if self.identify_btn is not None and self.value_to_move is not None:
                    if self.identify_btn == "front door open":
                        self.signals.call_texts.emit("front door open", "in progress", "")
                        return_value = ui_plc_communication.plc_control_class.front_door_open()
                        if return_value == "Passed":
                            self.signals.call_texts.emit("front door open", "completed", "")
                        else:
                            self.signals.call_texts.emit("front door open", "{}".format(return_value), "")
                            logger.error(f"front door open failed: {return_value}")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == "front door close":
                        self.signals.call_texts.emit("front door close", "in progress", "")
                        return_value = ui_plc_communication.plc_control_class.front_door_close()
                        if return_value == "Passed":
                            self.signals.call_texts.emit("front door close", "completed", "")
                        else:
                            self.signals.call_texts.emit("front door close", "{}".format(return_value), "")
                            logger.error(f"front door close failed: {return_value}")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == "part_loading out":
                        il_check = self.interlock_check(move="part_loading out")
                        if il_check == "Done":
                            self.signals.call_texts.emit("part_loading out", "in progress", "")
                            return_value = ui_plc_communication.plc_control_class.module_loading_out()
                            if return_value == "Passed":
                                ui.part_loading_act_in = False
                                self.signals.call_texts.emit("part_loading out", "completed", "")
                            else:
                                ui.part_loading_act_in = True
                                self.signals.call_texts.emit("part_loading out", "{}".format(return_value), "")
                                logger.error(f"part loading out failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == "part_loading in":
                        il_check = self.interlock_check(move="part_loading out")
                        if il_check == "Done":
                            self.signals.call_texts.emit("part_loading in", "in progress", "")
                            return_value = ui_plc_communication.plc_control_class.module_loading_in()
                            if return_value == "Passed":
                                ui.part_loading_act_in = True
                                self.signals.call_texts.emit("part_loading in", "completed", "")
                            else:
                                ui.part_loading_act_in = False
                                self.signals.call_texts.emit("part_loading in", "{}".format(return_value), "")
                                logger.error(f"part loading in failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")

                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == "loading_init":
                        il_check = self.interlock_check(move="Plc int")
                        if il_check == "Done":
                            self.signals.call_texts.emit("loading init", "in progress", "")
                            return_value = ui_plc_communication.plc_control_class.plc_initialize()
                            if return_value == "Passed":
                                ui.part_loading_act_in = False
                                ui.slider_act_current_value = 0.0
                                ui.gripper_act_current_value = 40.0
                                self.signals.call_texts.emit("loading init", "completed", "")
                            else:
                                ui.part_loading_act_in = True
                                ui.slider_act_current_value = 2.0
                                ui.gripper_act_current_value = 2.0
                                self.signals.call_texts.emit("loading init", "{}".format(return_value), "")
                                logger.error(f"plc init failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == "loading x_axis_homing btn":
                        il_check = self.interlock_check(move="X-axis homing")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                            self.signals.call_texts.emit("loading x_axis_homing btn", "in progress", str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_homing(5)
                            if return_value == "Passed":
                                ui.x_act_current_value = 10.0
                                self.signals.call_texts.emit("loading x_axis_homing btn", "completed", "10")
                            else:
                                ui.x_act_current_value = 2.0
                                self.signals.call_texts.emit("loading x_axis_homing btn", "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"X-axis homing failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == "loading y_axis_homing btn":
                        il_check = self.interlock_check(move="Y-axis homing")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                            self.signals.call_texts.emit("loading y_axis_homing btn", "in progress", str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_homing(1)
                            if return_value == "Passed":
                                ui.y_act_current_value = 5.0
                                self.signals.call_texts.emit("loading y_axis_homing btn", "completed", "5.0")
                            else:
                                ui.y_act_current_value = 2.0
                                self.signals.call_texts.emit("loading y_axis_homing btn", "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"Y-axis homing failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'loading_x_axis_run_btn':
                        actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                        self.signals.call_texts.emit('loading_x_axis_run_btn', "in progress", str(actual_value))
                        return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=5,
                                                                                           distance=self.value_to_move[
                                                                                               0],
                                                                                           speed=self.value_to_move[1])
                        if return_value == "Passed":
                            ui.x_act_current_value = float(self.value_to_move[0])
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                            self.signals.call_texts.emit('loading_x_axis_run_btn', "X-axis Moved", str(actual_value))
                            logger.info("X-axis moved {}mm".format(self.value_to_move))

                        else:
                            ui.x_act_current_value = 2.0
                            self.signals.call_texts.emit('loading_x_axis_run_btn', "{}".format(return_value),
                                                         str(actual_value))
                            logger.error(f"X-axis movement failed: {return_value}")

                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'loading_y_axis_run_btn':
                        il_check = self.interlock_check(move="Y-axis")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                            self.signals.call_texts.emit('loading_y_axis_run_btn', "in progress", str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=1,
                                                                                               distance=
                                                                                               self.value_to_move[0],
                                                                                               speed=self.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                ui.y_act_current_value = float(self.value_to_move[0])
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                                self.signals.call_texts.emit('loading_y_axis_run_btn', "Y-axis Moved",
                                                             str(actual_value))
                                logger.info("Y-axis moved {}mm".format(self.value_to_move))
                            else:
                                ui.y_act_current_value = 2.0
                                self.signals.call_texts.emit('loading_y_axis_run_btn', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"Y-axis movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")

                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'loading_slider_run_btn':
                        il_check = self.interlock_check(move='slider out')
                        if il_check == "Done":
                            self.signals.call_texts.emit('loading_slider_run_btn', "in progress", "")
                            return_value = ui_plc_communication.plc_control_class.slider(slider=self.value_to_move)
                            if return_value == "Passed":
                                ui.slider_act_current_value = float(self.value_to_move)
                                ui.part_loading_act_in = True
                                actual_value = ui_plc_communication.plc_control_class.read_current_values_plc(
                                    text="Slider")
                                self.signals.call_texts.emit('loading_slider_run_btn', "Slider moved",
                                                             str(actual_value))
                                logger.info("Slider is moved {}mm".format(self.value_to_move))

                            else:
                                ui.slider_act_current_value = 2.0
                                ui.part_loading_act_in = False
                                self.signals.call_texts.emit('loading_slider_run_btn', "{}".format(return_value),
                                                             str(ui.slider_act_current_value))
                                logger.error(f"Slider movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")

                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'loading slider_homing btn':
                        il_check = self.interlock_check(move="Plc int")
                        if il_check == "Done":
                            self.signals.call_texts.emit('loading slider_homing btn', "in progress", "")
                            return_value = ui_plc_communication.plc_control_class.plc_initialize()
                            if return_value == "Passed":
                                ui.slider_act_current_value = 0.0
                                ui.gripper_act_current_value = 40.0
                                ui.part_loading_act_in = False
                                self.signals.call_texts.emit('loading slider_homing btn', "Slider moved", "")
                                logger.info("Plc init done")
                            else:
                                ui.slider_act_current_value = 2.0
                                ui.gripper_act_current_value = 2.0
                                ui.part_loading_act_in = False
                                self.signals.call_texts.emit('loading slider_homing btn', "{}".format(return_value), "")
                                logger.error(f"Plc init failed {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")

                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == "loading_gripper_run_btn":
                        il_check = self.interlock_check(move="Gripper close")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.plc_control_class.read_current_values_plc(
                                text="Gripper")
                            self.signals.call_texts.emit("loading_gripper_run_btn", "in progress", str(actual_value))

                            return_value = ui_plc_communication.plc_control_class.gripper(gripper=self.value_to_move)
                            if return_value == "Passed":
                                ui.gripper_act_current_value = float(self.value_to_move)
                                actual_value = ui_plc_communication.plc_control_class.read_current_values_plc(
                                    text="Gripper")
                                self.signals.call_texts.emit("loading_gripper_run_btn", "Gripper moved",
                                                             str(actual_value))
                                logger.info("Gripper is moved {}mm".format(self.value_to_move))

                            else:
                                ui.gripper_act_current_value = 2.0
                                self.signals.call_texts.emit("loading_gripper_run_btn", "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"Gripper movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'loading gripper_homing btn':
                        self.signals.call_texts.emit('loading gripper_homing btn', "in progress", "")
                        return_value = ui_plc_communication.plc_control_class.gripper(40)
                        if return_value == "Passed":
                            ui.gripper_act_current_value = 40.0
                            self.signals.call_texts.emit('loading gripper_homing btn', "Gripper moved", "")
                            logger.info("Plc init done")
                        else:
                            ui.gripper_act_current_value = 2.0
                            self.signals.call_texts.emit('loading gripper_homing btn', "{}".format(return_value), "")
                            logger.error(f"Plc init failed {return_value}")

                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'loading_clockwise':
                        self.signals.call_texts.emit('loading_clockwise', "in progress", "")
                        return_value = ui_plc_communication.plc_control_class.lens_rotate(direction='clockwise',
                                                                                          degree=self.value_to_move)
                        if return_value == "Passed":
                            self.signals.call_texts.emit('loading_clockwise', "clockwise rotation is done", "")
                            logger.info("loading_clockwise is rotate")
                        else:
                            self.signals.call_texts.emit('loading_clockwise', "{}".format(return_value), "")
                            logger.error(f"Clockwise rotation failed: {return_value}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'loading_anti_clockwise':
                        self.signals.call_texts.emit('loading_anti_clockwise', "in progress", "")
                        return_value = ui_plc_communication.plc_control_class.lens_rotate(direction='anticlockwise',
                                                                                          degree=self.value_to_move)
                        if return_value == "Passed":
                            self.signals.call_texts.emit('loading_anti_clockwise', "anti-clockwise rotation is done",
                                                         "")
                            logger.info("loading_anti_clockwise is rotate")
                        else:
                            self.signals.call_texts.emit('loading_anti_clockwise', "{}".format(return_value), "")
                            logger.error(f"Anti-clockwise rotation failed: {return_value}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'lens_rotator_x_axis_homing_btn':
                        il_check = self.interlock_check(move="X-axis homing")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                            self.signals.call_texts.emit('lens_rotator_x_axis_homing_btn', "in progress",
                                                         str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_homing(5)
                            if return_value == "Passed":
                                ui.x_act_current_value = 10.0
                                self.signals.call_texts.emit('lens_rotator_x_axis_homing_btn', "completed", "10")
                            else:
                                ui.x_act_current_value = 2.0
                                self.signals.call_texts.emit('lens_rotator_x_axis_homing_btn',
                                                             "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"X-axis homing failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'lens_rotator_y_axis_homing_btn':
                        il_check = self.interlock_check(move="Y-axis homing")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                            self.signals.call_texts.emit('lens_rotator_y_axis_homing_btn', "in progress",
                                                         str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_homing(1)
                            if return_value == "Passed":
                                ui.y_act_current_value = 5.0
                                self.signals.call_texts.emit('lens_rotator_y_axis_homing_btn', "completed", "5.0")
                            else:
                                ui.x_act_current_value = 2.0
                                self.signals.call_texts.emit('lens_rotator_y_axis_homing_btn',
                                                             "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"Y-axis homing failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'lens_rotator_x_axis_run_btn':
                        actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                        self.signals.call_texts.emit('lens_rotator_x_axis_run_btn', "in progress", str(actual_value))
                        return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=5,
                                                                                           distance=self.value_to_move[
                                                                                               0],
                                                                                           speed=self.value_to_move[1])
                        if return_value == "Passed":
                            ui.x_act_current_value = float(self.value_to_move[0])
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                            self.signals.call_texts.emit('lens_rotator_x_axis_run_btn', "X-axis Moved",
                                                         str(actual_value))
                            logger.info("Y-axis moved {}mm".format(self.value_to_move))
                        else:
                            ui.x_act_current_value = 2.0
                            self.signals.call_texts.emit('lens_rotator_x_axis_run_btn', "{}".format(return_value),
                                                         str(actual_value))
                            logger.error(f"x-axis movement failed: {return_value}")

                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'lens_rotator_y_axis_run_btn':
                        il_check = self.interlock_check(move="Y-axis")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                            self.signals.call_texts.emit('lens_rotator_y_axis_run_btn', "in progress",
                                                         str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=1,
                                                                                               distance=
                                                                                               self.value_to_move[0],
                                                                                               speed=self.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                ui.y_act_current_value = float(self.value_to_move[0])
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                                self.signals.call_texts.emit('lens_rotator_y_axis_run_btn', "Y-axis Moved",
                                                             str(actual_value))
                                logger.info("Y-axis moved {}mm".format(self.value_to_move))
                            else:
                                ui.y_act_current_value = 2.0
                                self.signals.call_texts.emit('lens_rotator_y_axis_run_btn', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"Y-axis movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'lens_rotator_clockwise':
                        self.signals.call_texts.emit('lens_rotator_clockwise', "in progress", "")
                        return_value = ui_plc_communication.plc_control_class.lens_rotate(direction='clockwise',
                                                                                          degree=self.value_to_move)
                        if return_value == "Passed":
                            self.signals.call_texts.emit('lens_rotator_clockwise', "clockwise rotation is done", "")
                            logger.info("Lens_rotator_gripper is rotate")
                            list_value = []
                            for x in range(10):
                                value = ui_plc_communication.modbus_class.height_sensor_value()
                                if value != "Error":
                                    list_value.append(value)
                            try:
                                value = (sum(list_value) // len(list_value))
                                if value:
                                    self.signals.call_texts.emit("Lens height_value", "{}".format(value), '')
                                else:
                                    self.signals.call_texts.emit("Lens height_value", "{}".format("Error"), '')
                            except Exception as e:
                                self.signals.call_texts.emit("Lens height_value", "{}".format("Error"), '')
                        else:
                            self.signals.call_texts.emit('lens_rotator_clockwise', "{}".format(return_value), "")
                            logger.error(f"Clockwise rotation failed: {return_value}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'lens_rotator_anti_clockwise':
                        self.signals.call_texts.emit('lens_rotator_anti_clockwise', "in progress", "")
                        return_value = ui_plc_communication.plc_control_class.lens_rotate(direction='anticlockwise',
                                                                                          degree=self.value_to_move)
                        if return_value == "Passed":
                            self.signals.call_texts.emit('lens_rotator_anti_clockwise',
                                                         "anti-clockwise rotation is done",
                                                         "")
                            logger.info("Lens_rotator_gripper is rotate")
                            list_value = []
                            for x in range(10):
                                value = ui_plc_communication.modbus_class.height_sensor_value()
                                if value != "Error":
                                    list_value.append(value)
                            try:
                                value = (sum(list_value) // len(list_value))
                                if value:
                                    self.signals.call_texts.emit("Lens height_value", "{}".format(value), "")
                                else:
                                    self.signals.call_texts.emit("Lens height_value", "{}".format("Error"), "")

                            except Exception as e:
                                self.signals.call_texts.emit("Lens height_value", "{}".format("Error"), '')
                        else:
                            self.signals.call_texts.emit('lens_rotator_anti_clockwise', "{}".format(return_value), "")
                            logger.error(f"Anti-clockwise rotation failed: {return_value}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'collimator_x_axis_homing_btn':
                        il_check = self.interlock_check(move="X-axis homing")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                            self.signals.call_texts.emit('collimator_x_axis_homing_btn', "in progress",
                                                         str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_homing(5)
                            if return_value == "Passed":
                                ui.x_act_current_value = 10.0
                                self.signals.call_texts.emit('collimator_x_axis_homing_btn', "completed", "10")
                            else:
                                ui.x_act_current_value = 2.0
                                self.signals.call_texts.emit('collimator_x_axis_homing_btn', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"x-axis homing failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'collimator_y_axis_homing_btn':
                        il_check = self.interlock_check(move="Y-axis homing")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                            self.signals.call_texts.emit('collimator_y_axis_homing_btn', "in progress",
                                                         str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_homing(1)
                            if return_value == "Passed":
                                ui.y_act_current_value = 5.0
                                self.signals.call_texts.emit('collimator_y_axis_homing_btn', "completed", "5.0")
                            else:
                                ui.y_act_current_value = 2.0
                                self.signals.call_texts.emit('collimator_y_axis_homing_btn', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"y-axis homing failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'collimator_x_axis_run_btn':
                        actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                        self.signals.call_texts.emit('collimator_x_axis_run_btn', "in progress", str(actual_value))
                        return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=5,
                                                                                           distance=self.value_to_move[
                                                                                               0],
                                                                                           speed=self.value_to_move[1])
                        if return_value == "Passed":
                            ui.x_act_current_value = float(self.value_to_move[0])
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                            self.signals.call_texts.emit('collimator_x_axis_run_btn', "X-axis Moved", str(actual_value))
                            logger.info("Y-axis moved {}mm".format(self.value_to_move))
                        else:
                            ui.x_act_current_value = 2.0
                            self.signals.call_texts.emit('collimator_x_axis_run_btn', "{}".format(return_value),
                                                         str(actual_value))
                            logger.error(f"x-axis movement failed: {return_value}")

                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'collimator_y_axis_run_btn':
                        il_check = self.interlock_check(move="Y-axis")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                            self.signals.call_texts.emit('collimator_y_axis_run_btn', "in progress", str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=1,
                                                                                               distance=
                                                                                               self.value_to_move[0],
                                                                                               speed=self.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                ui.y_act_current_value = float(self.value_to_move[0])
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                                self.signals.call_texts.emit('collimator_y_axis_run_btn', "Y-axis Moved",
                                                             str(actual_value))
                                logger.info("Y-axis moved {}mm".format(self.value_to_move))
                            else:
                                ui.y_act_current_value = 2.0
                                self.signals.call_texts.emit('collimator_y_axis_run_btn', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error(f"y-axis movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'collimator_clockwise_btn':
                        self.signals.call_texts.emit('collimator_clockwise_btn', "in progress", "")
                        return_value = ui_plc_communication.plc_control_class.lens_rotate(direction='clockwise',
                                                                                          degree=self.value_to_move)
                        if return_value == "Passed":
                            self.signals.call_texts.emit('collimator_clockwise_btn', "clockwise rotation is done", "")
                            logger.info('collimator clockwise direction rotated')
                        else:
                            self.signals.call_texts.emit('collimator_clockwise_btn', "{}".format(return_value), "")
                            logger.error(f"clockwise rotation failed: {return_value}")

                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'collimator_anti_clockwise_btn':
                        self.signals.call_texts.emit('collimator_anti_clockwise_btn', "in progress", "")
                        return_value = ui_plc_communication.plc_control_class.lens_rotate(direction='anticlockwise',
                                                                                          degree=self.value_to_move)
                        if return_value == "Passed":
                            self.signals.call_texts.emit('collimator_anti_clockwise_btn',
                                                         "anti-clockwise rotation is done",
                                                         "")
                            logger.info('collimator anti-clockwise direction rotated')
                        else:
                            self.signals.call_texts.emit('collimator_anti_clockwise_btn', "{}".format(return_value), "")
                            logger.error(f"Anti-clockwise rotation failed: {return_value}")

                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == "Collimator_chart_dst_lux_btn":
                        self.signals.call_texts.emit("Collimator_chart_dst_lux_btn",
                                                     "chart_distance&intensity in progress",
                                                     "")
                        chart_distance = ui_plc_communication.collimator_class. \
                            change_collimator_distance(distances=self.value_to_move[0], collimator_list=[1, 2, 3, 4, ])
                        if chart_distance == "Passed":
                            logger.info("Collimator distance value {} is set".format(self.value_to_move[0]))
                        else:
                            logger.info("Error to set chart distance {}".format(chart_distance))

                        time.sleep(0.05)
                        light = ui_plc_communication.collimator_class.change_collimator_light(
                            light=self.value_to_move[1:], light_type=ui.collimator_light_cmb.currentText(),
                            collimator_list=[1, 2, 3, 4, 5])
                        if light == 'Passed':
                            logger.info("Lux value set to top left")
                        else:
                            logger.info("Error to set intensity TL position {}".format(light))

                        if chart_distance == "Passed" and light == "Passed":
                            self.signals.call_texts.emit("Collimator_chart_dst_lux_btn", "chart_distance&intensity is "
                                                                                         "completed", "")
                        else:
                            if chart_distance != "Passed":
                                logger.error("Error to set Chart distance {}".format(chart_distance))
                            elif light != "Passed":
                                logger.error("Error to set Chart intensity for TL {}".format(light))
                            self.signals.call_texts.emit("Collimator_chart_dst_lux_btn",
                                                         "chart_distance&intensity Error",
                                                         "")
                        self.identify_btn = None
                        self.value_to_move = None

                    elif self.identify_btn == "New collimator parameters":
                        self.signals.call_texts.emit("Collimator_chart_dst_lux_btn",
                                                     "chart_distance & intensity in progress",
                                                     "")
                        chart_distance = ui_plc_communication.collimator_class. \
                            change_collimator_distance(distances=self.value_to_move[0], collimator_list=[1, 2, 3, 4, ])
                        if chart_distance == "Passed":
                            logger.info("Collimator distance value {} is set".format(self.value_to_move[0]))
                        else:
                            logger.info("Error to set chart distance {}".format(chart_distance))

                        time.sleep(0.05)
                        light = ui_plc_communication.collimator_class.change_collimator_light(
                            light=self.value_to_move[1:], light_type=ui.collimator_light_cmb.currentText(),
                            collimator_list=[1, 2, 3, 4, 5])
                        if light == 'Passed':
                            logger.info("Lux value set to top left")
                        else:
                            logger.info("Error to set intensity TL position {}".format(light))

                        self.identify_btn = None
                        self.value_to_move = None

                    elif self.identify_btn == 'relay_x_axis_homing_btn':
                        il_check = self.interlock_check(move="X-axis homing")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                            self.signals.call_texts.emit('relay_x_axis_homing_btn', "in progress", str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_homing(5)
                            if return_value == "Passed":
                                ui.x_act_current_value = 10.0
                                self.signals.call_texts.emit('relay_x_axis_homing_btn', "completed", "10")
                            else:
                                ui.x_act_current_value = 2.0
                                self.signals.call_texts.emit('relay_x_axis_homing_btn', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error("x-axis homing failed".format(return_value))
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")

                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'relay_y_axis_homing_btn':
                        il_check = self.interlock_check(move="Y-axis homing")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                            self.signals.call_texts.emit('relay_y_axis_homing_btn', "in progress", str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_homing(1)
                            if return_value == "Passed":
                                ui.y_act_current_value = 5.0
                                self.signals.call_texts.emit('relay_y_axis_homing_btn', "completed", "5.0")
                            else:
                                ui.x_act_current_value = 2.0
                                self.signals.call_texts.emit('relay_y_axis_homing_btn', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error("Y-axis homing failed".format(return_value))
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'relay_x_axis_run_btn':
                        actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                        self.signals.call_texts.emit('relay_x_axis_run_btn', "in progress", str(actual_value))
                        return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=5,
                                                                                           distance=self.value_to_move[
                                                                                               0],
                                                                                           speed=self.value_to_move[1])
                        if return_value == "Passed":
                            ui.x_act_current_value = float(self.value_to_move[0])
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                            self.signals.call_texts.emit('relay_x_axis_run_btn', "X-axis Moved", str(actual_value))
                            logger.info("Y-axis moved {}mm".format(self.value_to_move))
                        else:
                            ui.x_act_current_value = 2.0
                            self.signals.call_texts.emit('relay_x_axis_run_btn', "{}".format(return_value),
                                                         str(actual_value))
                            logger.error("x-axis movement failed".format(return_value))

                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'relay_y_axis_run_btn':
                        il_check = self.interlock_check(move="Y-axis")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                            self.signals.call_texts.emit('relay_y_axis_run_btn', "in progress", str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=1,
                                                                                               distance=
                                                                                               self.value_to_move[0],
                                                                                               speed=self.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                ui.y_act_current_value = float(self.value_to_move[0])
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                                self.signals.call_texts.emit('relay_y_axis_run_btn', "Y-axis Moved", str(actual_value))
                                logger.info("Y-axis moved {}mm".format(self.value_to_move))
                            else:
                                ui.y_act_current_value = 2.0
                                self.signals.call_texts.emit('relay_y_axis_run_btn', "{}".format(return_value),
                                                             str(actual_value))
                                logger.error("y-axis homing failed".format(return_value))
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'relay_clockwise_btn':
                        self.signals.call_texts.emit('relay_clockwise_btn', "in progress", "")
                        return_value = ui_plc_communication.plc_control_class.lens_rotate(direction='clockwise',
                                                                                          degree=self.value_to_move)
                        if return_value == "Passed":
                            self.signals.call_texts.emit('relay_clockwise_btn', "clockwise rotation is done", "")
                            logger.info('collimator clockwise direction rotated')
                        else:
                            self.signals.call_texts.emit('relay_clockwise_btn', "{}".format(return_value), "")
                            logger.error(f"clockwise rotation failed: {return_value}")

                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'relay_anti_clockwise_btn':
                        self.signals.call_texts.emit('relay_anti_clockwise_btn', "in progress", "")
                        return_value = ui_plc_communication.plc_control_class.lens_rotate(direction='anticlockwise',
                                                                                          degree=self.value_to_move)
                        if return_value == "Passed":
                            self.signals.call_texts.emit('relay_anti_clockwise_btn', "anti-clockwise rotation is done",
                                                         "")
                            logger.info('collimator anti-clockwise direction rotated')
                        else:
                            self.signals.call_texts.emit('relay_anti_clockwise_btn', "{}".format(return_value), "")
                            logger.error(f"Anti-clockwise rotation failed: {return_value}")

                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'relay_light_panel_actuator_run_btn':
                        actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(2)
                        self.signals.call_texts.emit('relay_light_panel_actuator_run_btn', "in progress",
                                                     str(actual_value))
                        return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=2,
                                                                                           distance=self.value_to_move[
                                                                                               0],
                                                                                           speed=self.value_to_move[1])
                        if return_value == "Passed":
                            ui.relay_z_act_current_value = float(self.value_to_move[0])
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(2)
                            self.signals.call_texts.emit('relay_light_panel_actuator_run_btn', "relay z-axis Moved",
                                                         str(actual_value))
                            logger.info("Z-axis moved {}mm".format(self.value_to_move))
                        else:
                            ui.relay_z_act_current_value = 2.0
                            self.signals.call_texts.emit('relay_light_panel_actuator_run_btn',
                                                         "{}".format(return_value),
                                                         str(actual_value))
                            logger.info(f"Relay z-axis movement failed: {return_value}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'relay_light_panel_actuator_homing_btn':
                        actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(2)
                        self.signals.call_texts.emit('relay_light_panel_actuator_homing_btn', "in progress",
                                                     str(actual_value))
                        return_value = ui_plc_communication.modbus_class.actuator_homing(2)
                        if return_value == "Passed":
                            ui.relay_z_act_current_value = 5.0
                            self.signals.call_texts.emit('relay_light_panel_actuator_homing_btn', "completed", "5.0")
                        else:
                            ui.relay_z_act_current_value = 2.0
                            self.signals.call_texts.emit('relay_light_panel_actuator_homing_btn',
                                                         "{}".format(return_value),
                                                         str(actual_value))
                            logger.info(f"Relay z-axis homing failed: {return_value}")

                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'relay_light_panel_intensity_btn':
                        self.signals.call_texts.emit('relay_light_panel_intensity_btn', "in progress", "")
                        return_value = ui_plc_communication.plc_control_class.light_panel_lux(value=self.value_to_move)
                        if return_value == "Passed":
                            self.signals.call_texts.emit('relay_light_panel_intensity_btn', "lux set", '')
                            logger.info("Relay lux value is set")
                        else:
                            self.signals.call_texts.emit('relay_light_panel_intensity_btn', "{}".format(return_value),
                                                         "")
                            logger.info(f"Unable to set relay lux value {return_value}")

                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'gluing_x_axis_run_btn':
                        actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                        self.signals.call_texts.emit('gluing_x_axis_run_btn', "in progress", str(actual_value))
                        return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=5,
                                                                                           distance=self.value_to_move[
                                                                                               0],
                                                                                           speed=self.value_to_move[1])
                        if return_value == "Passed":
                            ui.x_act_current_value = float(self.value_to_move[0])
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                            self.signals.call_texts.emit('gluing_x_axis_run_btn', "X-axis Moved", str(actual_value))
                            logger.info("X-axis moved {}mm".format(self.value_to_move))
                        else:
                            ui.x_act_current_value = 2.0
                            self.signals.call_texts.emit('gluing_x_axis_run_btn', "{}".format(return_value),
                                                         str(actual_value))
                            logger.info(f"X-axis movement failed: {return_value}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'gluing_y_axis_run_btn':
                        il_check = self.interlock_check(move="Y-axis")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                            self.signals.call_texts.emit('gluing_y_axis_run_btn', "in progress", str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=1,
                                                                                               distance=
                                                                                               self.value_to_move[0],
                                                                                               speed=self.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                ui.y_act_current_value = float(self.value_to_move[0])
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                                self.signals.call_texts.emit('gluing_y_axis_run_btn', "Y-axis Moved", str(actual_value))
                                logger.info("Y-axis moved {}mm".format(self.value_to_move[0]))
                            else:
                                ui.y_act_current_value = 2.0
                                self.signals.call_texts.emit('gluing_y_axis_run_btn', "{}".format(return_value),
                                                             str(actual_value))
                                logger.info(f"y-axis movement failed: {return_value}")

                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'gluing_z_axis_run_btn':
                        il_check = self.interlock_check(move="Gluing Z-axis")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(3)
                            self.signals.call_texts.emit('gluing_z_axis_run_btn', "in progress", str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=3,
                                                                                               distance=
                                                                                               self.value_to_move[0],
                                                                                               speed=self.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                ui.gluing_z_act_current_value = float(self.value_to_move[0])
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(3)
                                self.signals.call_texts.emit('gluing_z_axis_run_btn', "Z-axis Moved", str(actual_value))
                                logger.info("Z-axis moved {}mm".format(self.value_to_move))
                            else:
                                ui.gluing_z_act_current_value = 2.0
                                self.signals.call_texts.emit('gluing_z_axis_run_btn', "{}".format(return_value),
                                                             str(actual_value))
                                logger.info(f"Gluing z-axis movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'gluing_z_axis_homing_btn':
                        il_check = self.interlock_check(move="Gluing Z-axis")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(3)
                            self.signals.call_texts.emit('gluing_z_axis_homing_btn', "in progress", str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_homing(3)
                            if return_value == "Passed":
                                ui.gluing_z_act_current_value = 5.0
                                self.signals.call_texts.emit('gluing_z_axis_homing_btn', "completed", "5.0")
                            else:
                                ui.gluing_z_act_current_value = 2.0
                                self.signals.call_texts.emit('gluing_z_axis_homing_btn', "{}".format(return_value),
                                                             str(actual_value))
                                logger.info(f"Gluing z-axis homing failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == 'gluing_teaching_x1_run_btn':
                        il_check = self.interlock_check(move="Gluing x1")
                        if il_check == "Done":
                            self.signals.call_texts.emit('gluing_teaching_x1_run_btn', "in progress", "")
                            return_value = ui_plc_communication.plc_control_class.glue_manual_move_recipe(
                                x1_manual=self.value_to_move)
                            if return_value == "Passed":
                                ui.gluing_x1_act_current_value = float(self.value_to_move)
                                self.signals.call_texts.emit('gluing_teaching_x1_run_btn', "gluing_x1-axis moved",
                                                             str(ui.gluing_x1_act_current_value))
                                logger.info("gluing_x1-axis is moved {}mm".format(self.value_to_move))
                            else:
                                current_value = ui_plc_communication.plc_control_class.read_current_values_plc(
                                    text="Gluing_x1")
                                ui.gluing_x1_act_current_value = float(current_value)
                                self.signals.call_texts.emit('gluing_teaching_x1_run_btn', "Gluing x1 movement failed",
                                                             str(ui.gluing_x1_act_current_value))
                                logger.info(f"Gluing x1 movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'gluing_teaching_x2_run_btn':
                        il_check = self.interlock_check(move="Gluing x2")
                        if il_check == "Done":
                            self.signals.call_texts.emit('gluing_teaching_x2_run_btn', "in progress", "")
                            return_value = ui_plc_communication.plc_control_class.glue_manual_move_recipe(
                                x2_manual=self.value_to_move, port_number="Port 2")
                            if return_value == "Passed":
                                ui.gluing_x2_act_current_value = float(self.value_to_move)
                                self.signals.call_texts.emit('gluing_teaching_x2_run_btn', "gluing_x2-axis moved",
                                                             str(ui.gluing_x2_act_current_value))
                                logger.info("gluing_x2-axis is moved {}mm".format(self.value_to_move))
                            else:
                                current_value = ui_plc_communication.plc_control_class.read_current_values_plc(
                                    text="Gluing_x2")
                                ui.gluing_x2_act_current_value = float(current_value)
                                self.signals.call_texts.emit('gluing_teaching_x2_run_btn', "Gluing x2 movement failed",
                                                             str(ui.gluing_x2_act_current_value))
                                logger.info(f"Gluing x2 movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'gluing_teaching_y_run_btn':
                        self.signals.call_texts.emit('gluing_teaching_y_run_btn', "in progress", "")
                        return_value = ui_plc_communication.plc_control_class.glue_manual_move_recipe(
                            y_manual=self.value_to_move)
                        if return_value == "Passed":
                            ui.gluing_y_act_current_value = float(self.value_to_move)
                            self.signals.call_texts.emit('gluing_teaching_y_run_btn', "gluing_y-axis moved",
                                                         str(ui.gluing_y_act_current_value))
                            logger.info("gluing_y-axis is moved {}mm".format(self.value_to_move))
                        else:
                            current_value = ui_plc_communication.plc_control_class.read_current_values_plc(
                                text="Gluing_y")
                            ui.gluing_y_act_current_value = float(current_value)
                            self.signals.call_texts.emit('gluing_teaching_y_run_btn', "Gluing y movement failed",
                                                         str(ui.gluing_y_act_current_value))
                            logger.info(f"Gluing y movement failed: {return_value}")

                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'Gluing init btn':
                        self.signals.call_texts.emit('Gluing init btn', "in progress", "")
                        gluing_home = ui_plc_communication.plc_control_class.gluing_init()
                        if gluing_home == "Passed":
                            ui.gluing_x1_act_current_value = 0.0
                            ui.gluing_x2_act_current_value = 0.0
                            ui.gluing_y_act_current_value = 0.0
                            self.signals.call_texts.emit('Gluing init btn', "Completed", "")
                            logger.info("Gluing initialization is completed")
                        else:
                            ui.gluing_x1_act_current_value = 5.0
                            ui.gluing_x2_act_current_value = 5.0
                            ui.gluing_y_act_current_value = 5.0
                            self.signals.call_texts.emit('Gluing init btn', "{}".format(gluing_home), "")
                            logger.info(f"Gluing init failed: {gluing_home}")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == "Gluing apply btn":
                        self.signals.call_texts.emit("Gluing apply btn", "in progress", "")
                        glue_apply = ui_plc_communication.plc_control_class.apply_glue(speed=self.value_to_move[1],
                                                                                       diameter=self.value_to_move[2],
                                                                                       glue_type=self.value_to_move[0])
                        if glue_apply == "Passed":
                            self.signals.call_texts.emit("Gluing apply btn", "Glue applied", "")
                        else:
                            self.signals.call_texts.emit("Gluing apply btn", "{}".format(glue_apply), "")
                            logger.info(f"Gluing apply failed: {glue_apply}")

                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == "Gluing with both time_delay":
                        self.signals.call_texts.emit('Gluing apply btn', "in progress", "")
                        glue_apply = ui_plc_communication.plc_control_class.apply_glue(speed=self.value_to_move[0],
                                                                                       diameter=self.value_to_move[1],
                                                                                       glue_type="Continuous glue",
                                                                                       on_delay=self.value_to_move[2],
                                                                                       off_delay=self.value_to_move[3])
                        if glue_apply == "Passed":
                            self.signals.call_texts.emit('Gluing apply btn', "Glue applied", "")
                        else:
                            self.signals.call_texts.emit('Gluing apply btn', "{}".format(glue_apply), "")
                            logger.info(f"Gluing apply failed: {glue_apply}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == "Gluing with on time_delay":
                        self.signals.call_texts.emit('Gluing apply btn', "in progress", "")
                        glue_apply = ui_plc_communication.plc_control_class.apply_glue(speed=self.value_to_move[0],
                                                                                       diameter=self.value_to_move[1],
                                                                                       glue_type="Continuous glue",
                                                                                       on_delay=self.value_to_move[2])
                        if glue_apply == "Passed":
                            self.signals.call_texts.emit('Gluing apply btn', "Glue applied", "")
                        else:
                            self.signals.call_texts.emit('Gluing apply btn', "{}".format(glue_apply), "")
                            logger.info(f"Gluing apply failed: {glue_apply}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == "Gluing with off time_delay":
                        self.signals.call_texts.emit('Gluing apply btn', "in progress", "")
                        glue_apply = ui_plc_communication.plc_control_class.apply_glue(speed=self.value_to_move[0],
                                                                                       diameter=self.value_to_move[1],
                                                                                       glue_type="Continuous glue",
                                                                                       off_delay=self.value_to_move[2])
                        if glue_apply == "Passed":
                            self.signals.call_texts.emit('Gluing apply btn', "Glue applied", "")
                        else:
                            self.signals.call_texts.emit('Gluing apply btn', "{}".format(glue_apply), "")
                            logger.info(f"Gluing apply failed: {glue_apply}")

                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == "spot gluing first dispenser":
                        self.signals.call_texts.emit('Gluing apply btn', "in progress", "")
                        spot_glue = ui_plc_communication.plc_control_class.glue_dispenser_timer(dispenser_type="First",
                                                                                                timer=float(
                                                                                                    self.value_to_move))
                        if spot_glue == "Passed":
                            self.signals.call_texts.emit('Gluing apply btn', "Glue applied", "")
                        else:
                            self.signals.call_texts.emit('Gluing apply btn', "{}".format(spot_glue), "")
                            logger.info(f"Gluing apply failed: {spot_glue}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == "spot gluing second dispenser":
                        self.signals.call_texts.emit('Gluing apply btn', "in progress", "")
                        spot_glue = ui_plc_communication.plc_control_class.glue_dispenser_timer(dispenser_type="Second",
                                                                                                timer=float(
                                                                                                    self.value_to_move))
                        if spot_glue == "Passed":
                            self.signals.call_texts.emit('Gluing apply btn', "Glue applied", "")
                        else:
                            self.signals.call_texts.emit('Gluing apply btn', "{}".format(spot_glue), "")
                            logger.info(f"Gluing apply failed: {spot_glue}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == "spot gluing both dispenser":
                        self.signals.call_texts.emit('Gluing apply btn', "in progress", "")
                        spot_glue = ui_plc_communication.plc_control_class.glue_dispenser_timer(dispenser_type="Both",
                                                                                                timer=float(
                                                                                                    self.value_to_move))
                        if spot_glue == "Passed":
                            self.signals.call_texts.emit('Gluing apply btn', "Glue applied", "")
                        else:
                            self.signals.call_texts.emit('Gluing apply btn', "{}".format(spot_glue), "")
                            logger.info(f"Gluing apply failed: {spot_glue}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'gluing_dispenser_off_btn':
                        self.signals.call_texts.emit('gluing_dispenser_off_btn', "in progress", "")
                        spot_glue = ui_plc_communication.plc_control_class.glue_dispenser_timer(dispenser_type="Both")
                        if spot_glue == "Passed":
                            self.signals.call_texts.emit('gluing_dispenser_off_btn', "Glue off", "")
                        else:
                            self.signals.call_texts.emit('gluing_dispenser_off_btn', "{}".format(spot_glue), "")
                            logger.info(f"Gluing apply failed: {spot_glue}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'curing_x_axis_run_btn':
                        actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                        self.signals.call_texts.emit('curing_x_axis_run_btn', "in progress", str(actual_value))
                        return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=5,
                                                                                           distance=self.value_to_move[
                                                                                               0],
                                                                                           speed=self.value_to_move[1])
                        if return_value == "Passed":
                            ui.x_act_current_value = float(self.value_to_move[0])
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(5)
                            self.signals.call_texts.emit('curing_x_axis_run_btn', "X-axis Moved", str(actual_value))
                            logger.info("Y-axis moved {}mm".format(self.value_to_move))
                        else:
                            ui.x_act_current_value = 2.0
                            self.signals.call_texts.emit('curing_x_axis_run_btn', "{}".format(return_value),
                                                         str(actual_value))
                            logger.info(f"X-axis movement failed: {return_value}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'curing_y_axis_run_btn':
                        actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                        self.signals.call_texts.emit('curing_y_axis_run_btn', "in progress", str(actual_value))
                        return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=1,
                                                                                           distance=self.value_to_move[
                                                                                               0],
                                                                                           speed=self.value_to_move[1])
                        if return_value == "Passed":
                            ui.y_act_current_value = float(self.value_to_move[0])
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(1)
                            self.signals.call_texts.emit('curing_y_axis_run_btn', "Y-axis Moved", str(actual_value))
                            logger.info("Y-axis moved {}mm".format(self.value_to_move))
                        else:
                            ui.y_act_current_value = 2.0
                            self.signals.call_texts.emit('curing_y_axis_run_btn', "{}".format(return_value),
                                                         str(actual_value))
                            logger.info(f"Y-axis movement failed: {return_value}")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'curing_z_axis_run_btn':
                        il_check = self.interlock_check(move="UV Z-axis")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(4)
                            self.signals.call_texts.emit('curing_z_axis_run_btn', "in progress", str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_movement(slave_id=4,
                                                                                               distance=
                                                                                               self.value_to_move[0],
                                                                                               speed=self.value_to_move[
                                                                                                   1])
                            if return_value == "Passed":
                                ui.curing_z_act_current_value = float(self.value_to_move[0])
                                actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(4)
                                self.signals.call_texts.emit('curing_z_axis_run_btn', "Z-axis Moved", str(actual_value))
                                logger.info("Z-axis moved {}mm".format(self.value_to_move))
                            else:
                                ui.curing_z_act_current_value = 2.0
                                self.signals.call_texts.emit('curing_z_axis_run_btn', "{}".format(return_value),
                                                             str(actual_value))
                                logger.info(f"Curing z-axis movement failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = 0

                    elif self.identify_btn == 'curing_z_axis_homing_btn':
                        il_check = self.interlock_check(move="UV Z-axis")
                        if il_check == "Done":
                            actual_value = ui_plc_communication.modbus_class.read_actuator_current_position(4)
                            self.signals.call_texts.emit('curing_z_axis_homing_btn', "in progress", str(actual_value))
                            return_value = ui_plc_communication.modbus_class.actuator_homing(4)
                            if return_value == "Passed":
                                ui.curing_z_act_current_value = 5.0
                                self.signals.call_texts.emit('curing_z_axis_homing_btn', "completed", "5.0")
                            else:
                                ui.curing_z_act_current_value = 2.0
                                self.signals.call_texts.emit('curing_z_axis_homing_btn', "{}".format(return_value),
                                                             str(actual_value))
                                logger.info(f"curing z-axis homing failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")
                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == "curing door open":
                        il_check = self.interlock_check(move="UV door close")
                        if il_check == "Done":
                            self.signals.call_texts.emit("curing door open", "in progress", "")
                            return_value = ui_plc_communication.plc_control_class.uv_door_open()
                            if return_value == "Passed":
                                ui.uv_door_act_open = True
                                self.signals.call_texts.emit("curing door open", "completed", "")
                            else:
                                ui.uv_door_act_open = False
                                self.signals.call_texts.emit("curing door open", "{}".format(return_value), "")
                                logger.info(f"Curing door open failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")

                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == "curing door close":
                        il_check = self.interlock_check(move="UV door close")
                        if il_check == "Done":
                            self.signals.call_texts.emit("curing door close", "in progress", "")
                            return_value = ui_plc_communication.plc_control_class.uv_door_close()
                            if return_value == "Passed":
                                ui.uv_door_act_open = False
                                self.signals.call_texts.emit("curing door close", "completed", "")
                            else:
                                ui.uv_door_act_open = True
                                self.signals.call_texts.emit("curing door close", "{}".format(return_value), "")
                                logger.info(f"Curing door close failed: {return_value}")
                        else:
                            self.signals.call_MsgBox.emit("Alert", f"{il_check}", "Critical")

                        self.identify_btn = None
                        self.value_to_move = ""

                    elif self.identify_btn == "Curing_on":
                        self.signals.call_texts.emit("Curing_on", "in progress", "")
                        uv_write = ui_plc_communication.uv_control_class.write_values(brightness=self.value_to_move[0],
                                                                                      delay=self.value_to_move[1])
                        if uv_write == "Passed":
                            return_value = ui_plc_communication.uv_control_class.uv_power_on()
                            if return_value == "Passed":
                                time.sleep(float(self.value_to_move[1]))
                                self.signals.call_texts.emit("Curing_on", "completed", "")
                            else:
                                self.signals.call_texts.emit("Curing_on", "{}".format(return_value), "")
                                logger.info(f"Curing on failed: {return_value}")
                        else:
                            self.signals.call_texts.emit("Curing_on", "{}".format(uv_write), "")
                            logger.info(f"Curing write failed: {uv_write}")

                        self.identify_btn = None
                        self.value_to_move = ""

                    ui.is_all_homing = False

                elif ui.abort_clicked:
                    self.identify_btn = None
                    self.value_to_move = 0

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Error at machine move function : {}|{}|{}|{}".format(exc_type, fname,
                                                                               exc_tb.tb_lineno, e))
            self.identify_btn = None
            self.value_to_move = 0


if __name__ == "__main__":
    try:
        app = QtWidgets.QApplication(sys.argv)
        screen_count = app.screens()
        screen_res = {}
        for i, screen_names in enumerate(screen_count):
            resolution = screen_count[i].size()
            height = resolution.height()
            width = resolution.width()
            screen_res[i] = [width, height]
        ui_plc_communication = ui_to_plc.Communication()
        ui = Main(screen_res)
        ui.stop_duplicate_window()
        ui.setWindowTitle(f"{ui.application_name}_{ui.app_version}")
        ui.setWindowIcon(QtGui.QIcon(r".\media\e-con-systems-logo.png"))
        ui.show()
        logger.info("*****************************************")
        logger.info("***********Launching Application*********")
        logger.info("*****************************************")
        logger.info('************Login Page shows*************')
        sys.exit(app.exec_())

    except Exception as e:
        exc_type, exc_obj, exc_tb = sys.exc_info()
        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
        logger.error("Error at name_main : {}|{}|{}|{}".format(exc_type, fname, exc_tb.tb_lineno, e))
